import { Profile } from 'micro-stacks/connect';
import { HDKey } from '@scure/bip32';
import { StacksNetworkVersion } from 'micro-stacks/crypto';
import * as micro_stacks_storage from 'micro-stacks/storage';
import { GaiaHubConfig } from 'micro-stacks/storage';

/**
 * This object represents the keys that were derived from the root-level
 * keychain of a wallet.
 */

declare type AllowedKeyEntropyBits = 128 | 256;
interface WalletKeys {
    /** Used when generating app private keys, which encrypt app-specific data */
    salt: string;
    /** The private key associated with the root of a BIP39 keychain */
    rootKey: string;
    /** A private key used to encrypt configuration data */
    configPrivateKey: string;
}
interface Wallet extends WalletKeys {
    /** The encrypted secret key */
    encryptedSecretKey: string;
    /** A list of accounts generated by this wallet */
    accounts: Account[];
}
interface LockedWallet {
    encryptedSecretKey: string;
}
interface Account {
    /** The private key used for STX payments */
    stxPrivateKey: string;
    /** The private key used in Stacks 1.0 to register BNS names */
    dataPrivateKey: string;
    /** The salt is the same as the wallet-level salt. Used for app-specific keys */
    salt: string;
    /** A single username registered via BNS for this account */
    username?: string;
    /** A profile object that is publicly associated with this account's username */
    profile?: Profile;
    /** The root of the keychain used to generate app-specific keys */
    appsKey: string;
    /** The index of this account in the user's wallet */
    index: number;
}
interface ConfigApp {
    origin: string;
    scopes: string[];
    lastLoginAt: number;
    appIcon: string;
    name: string;
}
interface ConfigAccount {
    username?: string;
    apps: {
        [origin: string]: ConfigApp;
    };
}
interface WalletConfig {
    accounts: ConfigAccount[];
    meta?: {
        [key: string]: any;
    };
}

/**
 * Generates a bip39 mnemonic phrase of 24 or 12 word length.
 *
 * This function is basically a type guard wrapper for
 * `generateMnemonic` from `micro-stacks/bip39`
 * to enforce either 256 or 128 bits of entropy.
 *
 * @param entropy {AllowedKeyEntropyBits} - 256 (24 words) or 128 (12 words)
 * @return mnemonic - 24 or 12 word mnemonic phrase
 */
declare function generateSecretKey(entropy?: AllowedKeyEntropyBits): string;
/**
 * Generate a new [[Wallet]].
 * @param mnemonic A 12 or 24 word mnemonic phrase. Must be a valid bip39 mnemonic.
 * @param password A password used to encrypt the wallet
 */
declare function generateWallet(mnemonic: string, password: string): Promise<Wallet>;
declare function generateAndInsertNewAccount(wallet: Wallet): Wallet;

/**
 * Derive the `configPrivateKey` for a wallet.
 *
 * This key is derived from the path `m/44/5757'/0'/1`, using `1` for change option,
 * following the bip44 recommendation for keys relating to non-public data.
 *
 * > m / purpose' / coin_type' / account' / change / address_index

 *
 * This key is used to encrypt configuration data related to a wallet, so the user's
 * configuration can be synced across wallets.
 *
 * @param rootNode A keychain that was created using the wallet mnemonic phrase
 */
declare const deriveConfigPrivateKey: (rootNode: HDKey) => string;
/**
 * Before modern Stacks Wallets, previous authenticators used a different format
 * and path for the config file.
 *
 * The path for this key is `m/45'`
 * @param rootKey A base64 encoded HDKeychain (BIP32) that was created using the wallet mnemonic phrase
 * @return privateKey Hex encoded legacy private key
 */
declare const deriveLegacyConfigPrivateKey: (rootKey: string) => string;
/**
 * Generate a salt, which is used for generating an app-specific private key
 * the salt is the hex encoded public key converted to bytes, SHA256 hashed and then hex encoded
 * @param rootNode A keychain that was created using the wallet mnemonic phrase
 * @return salt A hex encoded hash
 */
declare function deriveSalt(rootNode: HDKey): string;
declare function deriveWalletKeys(rootNode: HDKey): WalletKeys;

/**
 * Derive an account from a wallet
 * @param rootNode
 * @param index
 * @param salt
 */
declare function deriveAccount(rootNode: HDKey, index: number, salt: string): Account;
declare function deriveNextAccountFromWallet(wallet: Wallet): Account;
declare function deriveManyAccountsForWallet(wallet: Wallet, count: number, startingIndex?: number): Account[];

/**
 * convert a compressed or uncompressed `stxPrivateKey` to a Stacks address for a given network version (mainnet / testnet)
 * @param account {Account}
 * @param networkVersion {StacksNetworkVersion}
 */
declare function getStxAddressFromAccount(account: Account, networkVersion?: StacksNetworkVersion): string;

declare function getAppPrivateKey(account: Account, appDomain: string, legacy?: boolean): string;

/**
 * Get the gaia hub address (base58) for a given account
 * @param account {Account}
 */
declare function getGaiaAddress(account: Account): string;

/**
 * Encrypt a raw mnemonic phrase to be password protected
 * This should always be used in combination with a library like Argon, eg `argon2-browser`
 *
 * @param {string} mnemonic - Raw mnemonic phrase
 * @param {string} password - Password to encrypt mnemonic with
 * @param {Uint8Array} salt - optional salt
 * @return {Promise<Uint8Array>} The encrypted phrase
 * @private
 * @ignore
 * */
declare function encryptMnemonic(mnemonic: string, password: string, salt?: Uint8Array): Promise<Uint8Array>;

/**
 * Decrypt an encrypted mnemonic phrase with a password.
 * @param encryptedMnemonic - Uint8Array or hex-encoded string of the encrypted mnemonic
 * @param password - Password for data
 * @return the raw mnemonic phrase
 * @private
 * @ignore
 */
declare function decryptMnemonic(encryptedMnemonic: Uint8Array | string, password: string): Promise<string>;

declare function makeDIDFromAddress(address: string): string;
declare function nextMonth(): Date;
declare function makeUUID4(): string;
interface MakeAuthResponseParams {
    privateKey: string;
    profile?: any;
    username?: string;
    metadata?: any;
    coreToken?: string;
    appPrivateKey?: string;
    expiresAt?: number;
    transitPublicKey?: string;
    hubUrl?: string;
    blockstackAPIUrl?: string;
    associationToken?: string;
}
declare function encryptPrivateKey(publicKey: string, privateKey: string): Promise<string>;
declare function makeAuthResponse(params: MakeAuthResponseParams): Promise<string>;

declare function createWalletConfigGaiaHubConfig(privateKey: string, gaiaHubUrl?: string): Promise<micro_stacks_storage.GaiaHubConfig>;

declare function fetchWalletConfig(privateKey: string, options?: {
    gaiaHubConfig?: GaiaHubConfig;
    gaiaHubUrl?: string;
}): Promise<WalletConfig | undefined>;

interface GetOrSetWalletConfig {
    wallet: Wallet;
    gaiaHubConfig?: GaiaHubConfig;
    gaiaHubUrl?: string;
}
declare function getOrSetWalletConfig({ wallet, gaiaHubConfig, gaiaHubUrl, }: GetOrSetWalletConfig): Promise<WalletConfig>;

declare function makeWalletConfig(wallet: Wallet): WalletConfig;

/**
 * This function will look for an existing wallet config from gaia
 * if one is found, it will return a wallet with the correct number of accounts generated
 * if one is not found, it will return the wallet that was passed to it
 * @param wallet
 * @param walletConfig
 */
declare function restoreWalletAccountsFromWalletConfig({ wallet, walletConfig, }: {
    wallet: Wallet;
    walletConfig: WalletConfig;
}): Wallet;

interface SaveWalletConfig {
    walletConfig: WalletConfig;
    gaiaHubConfig?: GaiaHubConfig;
    gaiaHubUrl?: string;
    privateKey: string;
}
declare function saveWalletConfig({ walletConfig, privateKey, gaiaHubConfig, gaiaHubUrl, }: SaveWalletConfig): Promise<void>;

interface UpdateAppsMeta {
    wallet: Wallet;
    app: ConfigApp;
    account: Account;
    walletConfig: WalletConfig;
}
interface UpdateWalletConfigWithApp extends UpdateAppsMeta {
    gaiaHubConfig?: GaiaHubConfig;
}
declare const updateWalletConfigWithApp: ({ wallet, account, app, walletConfig, gaiaHubConfig, }: UpdateWalletConfigWithApp) => Promise<WalletConfig>;
declare const addNewAccountToWalletConfig: ({ wallet, walletConfig, gaiaHubConfig, }: UpdateWalletConfigWithApp) => Promise<WalletConfig>;

export { Account, AllowedKeyEntropyBits, ConfigAccount, ConfigApp, GetOrSetWalletConfig, LockedWallet, Wallet, WalletConfig, WalletKeys, addNewAccountToWalletConfig, createWalletConfigGaiaHubConfig, decryptMnemonic, deriveAccount, deriveConfigPrivateKey, deriveLegacyConfigPrivateKey, deriveManyAccountsForWallet, deriveNextAccountFromWallet, deriveSalt, deriveWalletKeys, encryptMnemonic, encryptPrivateKey, fetchWalletConfig, generateAndInsertNewAccount, generateSecretKey, generateWallet, getAppPrivateKey, getGaiaAddress, getOrSetWalletConfig, getStxAddressFromAccount, makeAuthResponse, makeDIDFromAddress, makeUUID4, makeWalletConfig, nextMonth, restoreWalletAccountsFromWalletConfig, saveWalletConfig, updateWalletConfigWithApp };
