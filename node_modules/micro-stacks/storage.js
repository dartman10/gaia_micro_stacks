"use strict";Object.defineProperty(exports,"__esModule",{value:!0});var crypto=require("micro-stacks/crypto"),common=require("micro-stacks/common"),zoneFile=require("micro-stacks/zone-file"),__defProp$1=Object.defineProperty,__defProps=Object.defineProperties,__getOwnPropDescs=Object.getOwnPropertyDescriptors,__getOwnPropSymbols$1=Object.getOwnPropertySymbols,__hasOwnProp$1=Object.prototype.hasOwnProperty,__propIsEnum$1=Object.prototype.propertyIsEnumerable,__defNormalProp$1=(e,r,t)=>r in e?__defProp$1(e,r,{enumerable:!0,configurable:!0,writable:!0,value:t}):e[r]=t,__spreadValues$1=(e,r)=>{for(var t in r||(r={}))__hasOwnProp$1.call(r,t)&&__defNormalProp$1(e,t,r[t]);if(__getOwnPropSymbols$1)for(var t of __getOwnPropSymbols$1(r))__propIsEnum$1.call(r,t)&&__defNormalProp$1(e,t,r[t]);return e},__spreadProps=(e,r)=>__defProps(e,__getOwnPropDescs(r));function transformScopePath(e){var r;return(r=e==null?void 0:e.map(t=>__spreadProps(__spreadValues$1({},t),{domain:t.path})))!=null?r:null}async function makeScopedGaiaAuthToken(e){const{hubInfo:r,privateKey:t,gaiaHubUrl:o,associationToken:n=null,scopes:s}=e,{challenge_text:i}=r,a=common.bytesToHex(crypto.getPublicKey(t,!0)),u=crypto.getRandomBytes(16).toString(),c={gaiaChallenge:i,hubUrl:o,iss:a,salt:u,associationToken:n,scopes:transformScopePath(s)};return`v1:${await new crypto.TokenSigner("ES256K",t).sign(c)}`}async function generateGaiaHubConfig(e){const{gaiaHubUrl:r,privateKey:t,associationToken:o,scopes:n}=e,i=await(await common.fetchPrivate(`${r}/hub_info`)).json(),{read_url_prefix:a,max_file_upload_size_megabytes:u}=i,c=await makeScopedGaiaAuthToken({hubInfo:i,privateKey:t,gaiaHubUrl:r,associationToken:o,scopes:n});return{address:crypto.privateKeyToBase58Address(t),url_prefix:a,token:c,server:r,max_file_upload_size_megabytes:u}}const ERROR_CODES={MISSING_PARAMETER:"missing_parameter",REMOTE_SERVICE_ERROR:"remote_service_error",INVALID_STATE:"invalid_state",NO_SESSION_DATA:"no_session_data",DOES_NOT_EXIST:"does_not_exist",FAILED_DECRYPTION_ERROR:"failed_decryption_error",INVALID_DID_ERROR:"invalid_did_error",NOT_ENOUGH_FUNDS_ERROR:"not_enough_error",INVALID_AMOUNT_ERROR:"invalid_amount_error",LOGIN_FAILED_ERROR:"login_failed",SIGNATURE_VERIFICATION_ERROR:"signature_verification_failure",CONFLICT_ERROR:"conflict_error",NOT_ENOUGH_PROOF_ERROR:"not_enough_proof_error",BAD_PATH_ERROR:"bad_path_error",VALIDATION_ERROR:"validation_error",PAYLOAD_TOO_LARGE_ERROR:"payload_too_large_error",PRECONDITION_FAILED_ERROR:"precondition_failed_error",UNKNOWN:"unknown"};Object.freeze(ERROR_CODES);class BlockstackError extends Error{constructor(r){super();let t=r.message,o=`Error Code: ${r.code}`,n=this.stack;if(n)o+=`Stack Trace:
${n}`;else try{throw new Error}catch(s){n=s.stack}t+=`
If you believe this exception is caused by a bug in blockstack.js,
      please file a bug report: https://github.com/blockstack/blockstack.js/issues

${o}`,this.message=t,this.code=r.code,this.parameter=r.parameter?r.parameter:void 0}toString(){return`${super.toString()}
    code: ${this.code} param: ${this.parameter?this.parameter:"n/a"}`}}class SignatureVerificationError extends BlockstackError{constructor(r){const t=`Failed to verify signature: ${r}`;super({code:ERROR_CODES.SIGNATURE_VERIFICATION_ERROR,message:t});this.message=t,this.name="SignatureVerificationError"}}class GaiaHubError extends BlockstackError{constructor(r,t){super(r);t&&(this.hubError={statusCode:t.status,statusText:t.statusText},typeof t.body=="string"?this.hubError.message=t.body:typeof t.body=="object"&&Object.assign(this.hubError,t.body))}}class DoesNotExist extends GaiaHubError{constructor(r,t){super({message:r,code:ERROR_CODES.DOES_NOT_EXIST},t);this.name="DoesNotExist"}}class ConflictError extends GaiaHubError{constructor(r,t){super({message:r,code:ERROR_CODES.CONFLICT_ERROR},t);this.name="ConflictError"}}class NotEnoughProofError extends GaiaHubError{constructor(r,t){super({message:r,code:ERROR_CODES.NOT_ENOUGH_PROOF_ERROR},t);this.name="NotEnoughProofError"}}class BadPathError extends GaiaHubError{constructor(r,t){super({message:r,code:ERROR_CODES.BAD_PATH_ERROR},t);this.name="BadPathError"}}class ValidationError extends GaiaHubError{constructor(r,t){super({message:r,code:ERROR_CODES.VALIDATION_ERROR},t);this.name="ValidationError"}}class PayloadTooLargeError extends GaiaHubError{constructor(r,t,o){super({message:r,code:ERROR_CODES.PAYLOAD_TOO_LARGE_ERROR},t);this.name="PayloadTooLargeError",this.maxUploadByteSize=o}}class PreconditionFailedError extends GaiaHubError{constructor(r,t){super({message:r,code:ERROR_CODES.PRECONDITION_FAILED_ERROR},t);this.name="PreconditionFailedError"}}async function getGaiaErrorResponse(e){let r="",t;try{r=await e.text();try{t=JSON.parse(r)}catch{}}catch(i){console.debug(`Error getting bad http response text: ${i}`)}const o=e.status,n=e.statusText;return{status:o,statusText:n,body:t||r}}function megabytesToBytes(e){return Number.isFinite(e)?Math.floor(e*1024*1024):0}async function getBlockstackErrorFromResponse(e,r,t){if(e.ok)throw new Error("Cannot get a Stacks from a valid response.");const o=await getGaiaErrorResponse(e);if(o.status===401)throw new ValidationError(r,o);if(o.status===402)throw new NotEnoughProofError(r,o);if(o.status===403)throw new BadPathError(r,o);if(o.status===404)throw new DoesNotExist(r,o);if(o.status===409)throw new ConflictError(r,o);if(o.status===412)throw new PreconditionFailedError(r,o);if(o.status===413){const n=t&&t.max_file_upload_size_megabytes?megabytesToBytes(t.max_file_upload_size_megabytes):0;throw new PayloadTooLargeError(r,o,n)}else throw new Error(r)}function isRecoverableGaiaError(e){if(!e||!e.hubError||!e.hubError.statusCode)return!1;const r=e.hubError.statusCode;return r===401||r===409||r>=500&&r<=599}async function uploadToGaiaHub(e){const{filename:r,contents:t,hubConfig:o,contentType:n="application/octet-stream"}=e,s={"Content-Type":n,Authorization:`bearer ${o.token}`},i=await common.fetchPrivate(`${o.server}/store/${o.address}/${r}`,{method:"POST",headers:s,body:t});if(!i.ok)throw await getBlockstackErrorFromResponse(i,"Error when uploading to Gaia hub.",o);const a=await i.text();return JSON.parse(a)}function getFullReadUrl(e,r){return Promise.resolve(`${r.url_prefix}${r.address}/${e}`)}const SIGNATURE_FILE_SUFFIX=".sig",DEFAULT_ZONEFILE_LOOKUP_URL="https://stacks-node-api.stacks.co/v1/names",_FileContentLoader=class{constructor(e,r){this.wasString=typeof e=="string",this.content=_FileContentLoader.normalizeContentDataType(e,r),this.contentType=r||this.detectContentType(),this.contentByteLength=this.detectContentLength()}static normalizeContentDataType(e,r){try{if(typeof e=="string"){const t=(r||"").toLowerCase().replace("-","");if(t.includes("charset")&&!t.includes("charset=utf8")&&!t.includes("charset=ascii"))throw new Error(`Unable to determine byte length with charset: ${r}`);return new TextEncoder().encode(e)}else{if(e instanceof Uint8Array)return e;if(ArrayBuffer.isView(e))return new Uint8Array(e.buffer,e.byteOffset,e.byteLength);if(typeof Blob!="undefined"&&e instanceof Blob)return e;if(e instanceof ArrayBuffer)return new Uint8Array(e);if(Array.isArray(e)){if(e.length>0&&(!Number.isInteger(e[0])||e[0]<0||e[0]>255))throw new Error(`Unexpected array values provided as file data: value "${e[0]}" at index 0 is not an octet number. ${this.supportedTypesMsg}`);return new Uint8Array(e)}else{const t=Object.prototype.toString.call(e);throw new Error(`Unexpected type provided as file data: ${t}. ${this.supportedTypesMsg}`)}}}catch(t){throw console.error(t),new Error(`Error processing data: ${t}`)}}detectContentType(){return this.wasString?"text/plain; charset=utf-8":typeof Blob!="undefined"&&this.content instanceof Blob&&this.content.type?this.content.type:"application/octet-stream"}detectContentLength(){if(ArrayBuffer.isView(this.content)||this.content instanceof Uint8Array)return this.content.byteLength;if(typeof Blob!="undefined"&&this.content instanceof Blob)return this.content.size;const e=Object.prototype.toString.call(this.content),r=new Error(`Unexpected type "${e}" while detecting content length`);throw console.error(r),r}async loadContent(){try{if(this.content instanceof Uint8Array)return this.content;if(ArrayBuffer.isView(this.content))return new Uint8Array(this.content.buffer,this.content.byteOffset,this.content.byteLength);if(typeof Blob!="undefined"&&this.content instanceof Blob){const e=new FileReader;return await new Promise((o,n)=>{e.onerror=s=>{n(s)},e.onload=()=>{const s=e.result;o(new Uint8Array(s))},e.readAsArrayBuffer(this.content)})}else{const e=Object.prototype.toString.call(this.content);throw new Error(`Unexpected type ${e}`)}}catch(e){console.error(e);const r=new Error(`Error loading content: ${e}`);throw console.error(r),r}}load(){return this.loadedData===void 0&&(this.loadedData=this.loadContent()),this.loadedData}};let FileContentLoader=_FileContentLoader;FileContentLoader.supportedTypesMsg="Supported types are: `string` (to be UTF8 encoded), `Uint8Array`, `Blob`, `File`, `ArrayBuffer`, `UInt8Array` or any other typed array buffer. ";async function putFile(e,r,t){let{privateKey:o}=t;const{encrypt:n,sign:s,gaiaHubConfig:i,cipherTextEncoding:a}=t;let{contentType:u=""}=t;const c=megabytesToBytes(i.max_file_upload_size_megabytes),y=c>0,f=new FileContentLoader(r,u);if(u=f.contentType,!n&&y&&f.contentByteLength>c){const l=`The max file upload size for this hub is ${c} bytes, the given content is ${f.contentByteLength} bytes`,d=new PayloadTooLargeError(l,null,c);throw console.error(d),d}if(n&&y&&a){const l=crypto.eciesGetJsonStringLength({contentLength:f.contentByteLength,wasString:f.wasString,sign:!!s,cipherTextEncoding:a});if(l>c){const d=`The max file upload size for this hub is ${c} bytes, the given content is ${l} bytes after encryption`,p=new PayloadTooLargeError(d,null,c);throw console.error(p),p}}let h;if(!n&&s){const l=await f.load();if(typeof s=="string")o=s;else if(!o)throw Error("Need to pass private key");const d=await crypto.signECDSA({contents:l,privateKey:o});h=async p=>(await Promise.all([uploadToGaiaHub({filename:e,contents:l,hubConfig:p,contentType:u}),uploadToGaiaHub({filename:`${e}${SIGNATURE_FILE_SUFFIX}`,contents:JSON.stringify(d),hubConfig:p,contentType:"application/json"})]))[0].publicURL}else{let l;if(!n&&!s)l=f.content;else{let d;if(typeof n=="string")d=n;else if(typeof s=="string")d=common.bytesToHex(crypto.getPublicKey(s,!0));else if(o)d=common.bytesToHex(crypto.getPublicKey(o,!0));else throw new Error("No private key passed");const p=await f.load(),g=await crypto.encryptContent(p,{publicKey:d,wasString:f.wasString,cipherTextEncoding:a,privateKey:o});if(l=JSON.stringify(g),o){const{signature:b,publicKey:w}=await crypto.signECDSA({contents:g,privateKey:o});l=JSON.stringify({signature:b,publicKey:w,cipherText:g})}u="application/json"}h=async d=>(await uploadToGaiaHub({filename:e,contents:l,hubConfig:d,contentType:u})).publicURL}try{return await h(i)}catch(l){if(isRecoverableGaiaError(l))return console.error(l),console.error("Possible recoverable error during Gaia upload, retrying..."),await h(i);throw l}}function getTokenFileUrl(e){if(!e.hasOwnProperty("uri")||!Array.isArray(e.uri)||e.uri.length<1)return null;const r=e.uri[0];if(!r.hasOwnProperty("target"))return null;let t=r.target;return t.startsWith("https")||t.startsWith("http")||(t=`https://${t}`),t}function formatAccount(e,r){let t;return r.proof&&r.proof.url&&(t=r.proof.url),{"@type":"Account",service:e,identifier:r.username,proofType:"http",proofUrl:t}}function getPersonFromLegacyFormat(e){const r={"@type":"Person"};if(e){e.name&&e.name.formatted&&(r.name=e.name.formatted),e.bio&&(r.description=e.bio),e.location&&e.location.formatted&&(r.address={"@type":"PostalAddress",addressLocality:e.location.formatted});const t=[];e.avatar&&e.avatar.url&&t.push({"@type":"ImageObject",name:"avatar",contentUrl:e.avatar.url}),e.cover&&e.cover.url&&t.push({"@type":"ImageObject",name:"cover",contentUrl:e.cover.url}),t.length&&(r.image=t),e.website&&(r.website=[{"@type":"WebSite",url:e.website}]);const o=[];e.bitcoin&&e.bitcoin.address&&o.push({"@type":"Account",role:"payment",service:"bitcoin",identifier:e.bitcoin.address}),e.twitter&&e.twitter.username&&o.push(formatAccount("twitter",e.twitter)),e.facebook&&e.facebook.username&&o.push(formatAccount("facebook",e.facebook)),e.github&&e.github.username&&o.push(formatAccount("github",e.github)),e.auth&&e.auth.length>0&&e.auth[0]&&e.auth[0].publicKeychain&&o.push({"@type":"Account",role:"key",service:"bip32",identifier:e.auth[0].publicKeychain}),e.pgp&&e.pgp.url&&o.push({"@type":"Account",role:"key",service:"pgp",identifier:e.pgp.fingerprint,contentUrl:e.pgp.url}),r.account=o}return r}function verifyProfileToken(e,r){const t=crypto.decodeToken(e);if(!t)throw Error("no decoded token");const o=t.payload;if(typeof o=="string")throw new Error("Unexpected token payload type of string");if(o.hasOwnProperty("subject")&&o.subject){if(!o.subject.hasOwnProperty("publicKey"))throw new Error("Token doesn't have a subject public key")}else throw new Error("Token doesn't have a subject");if(o.hasOwnProperty("issuer")&&o.issuer){if(!o.issuer.hasOwnProperty("publicKey"))throw new Error("Token doesn't have an issuer public key")}else throw new Error("Token doesn't have an issuer");if(!o.hasOwnProperty("claim"))throw new Error("Token doesn't have a claim");const n=o.issuer.publicKey,s=crypto.publicKeyToStxAddress(n);if(r!==n){if(r!==s)throw new Error("Token issuer public key does not match the verifying value")}const i=new crypto.TokenVerifier(t.header.alg,n);if(!i)throw new Error("Invalid token verifier");if(!i.verify(e))throw new Error("Token verification failed");return t}function extractProfile(e,r){const t=r?verifyProfileToken(e,r):crypto.decodeToken(e);if(t&&t.hasOwnProperty("payload")){const o=t.payload;if(typeof o=="string")throw new Error("[micro-stacks] extractProfile: Unexpected token payload type of string");if(o.hasOwnProperty("claim"))return o.claim}return{}}async function resolveZoneFileToProfile(e,r){let t=zoneFile.parseZoneFile(e);if(t.hasOwnProperty("$origin")||(t=null),!(t&&Object.keys(t).length>0))return getPersonFromLegacyFormat(JSON.parse(e));const n=getTokenFileUrl(t);if(n)try{const i=await(await common.fetchPrivate(n)).json();return extractProfile(i[0].token,r)}catch(s){throw console.error(`[micro-stacks] resolveZoneFileToProfile: error fetching token file ${n}: ${s}`),s}return console.debug("[micro-stacks] Token file url not found. Resolving to blank profile."),{}}async function lookupProfile(e){const{username:r,zoneFileLookupURL:t=DEFAULT_ZONEFILE_LOOKUP_URL}=e;if(!r)return Promise.reject();const o=`${t.replace(/\/$/,"")}/${e.username}`,s=await(await common.fetchPrivate(o)).json();if(s.hasOwnProperty("zonefile")&&s.hasOwnProperty("address"))return await resolveZoneFileToProfile(s.zonefile,e.verify?s.address:void 0);throw new Error("Invalid zonefile lookup response: did not contain `address` or `zonefile` field")}async function getUserAppFileUrl(e,r,t,o){const n=await lookupProfile({username:r,zoneFileLookupURL:o});let s;if(!!n)return n.hasOwnProperty("apps")?n.apps.hasOwnProperty(t)&&(s=`${n.apps[t].replace(/\/?(\?|#|$)/,"/$1")}${e}`):n.hasOwnProperty("appsMeta")&&n.appsMeta.hasOwnProperty(t)&&(s=`${n.appsMeta[t].replace(/\/?(\?|#|$)/,"/$1")}${e}`),s}async function getFileUrl(e,r){let t;if(r.username?t=await getUserAppFileUrl(e,r.username,r.app,r.zoneFileLookupURL):t=await getFullReadUrl(e,r.gaiaHubConfig),t)return t;throw new Error("Missing readURL")}async function getGaiaAddress(e){const{app:r,username:t,zoneFileLookupURL:o,gaiaHubConfig:n}=e;let s;t?s=await getUserAppFileUrl("/",t,r,o):n&&(s=await getFullReadUrl("/",n));const i=/([13][a-km-zA-HJ-NP-Z0-9]{26,35})/.exec(s);if(!i)throw new Error("Failed to parse gaia address");return i[i.length-1]}async function getFileContents(e){const{path:r,forceText:t,app:o,username:n,zoneFileLookupURL:s,gaiaHubConfig:i}=e,a=await getFileUrl(r,{app:o,username:n,zoneFileLookupURL:s,gaiaHubConfig:i}),u=await common.fetchPrivate(a);if(!u.ok)throw await getBlockstackErrorFromResponse(u,`getFile ${r} failed.`,null);let c=u.headers.get("Content-Type");if(typeof c=="string"&&(c=c.toLowerCase()),t||c===null||c.startsWith("text")||c.startsWith("application/json"))return u.text();{const y=await u.arrayBuffer();return common.arrayBufferToUint8(y)}}async function getFileSignedUnencrypted(e,r){const{app:t,username:o,zoneFileLookupURL:n,gaiaHubConfig:s}=r,i=`${e}${SIGNATURE_FILE_SUFFIX}`;try{const[a,u,c]=await Promise.all([getFileContents({path:e,app:t,username:o,zoneFileLookupURL:n,forceText:!1,gaiaHubConfig:s}),getFileContents({path:i,app:t,username:o,zoneFileLookupURL:n,forceText:!0,gaiaHubConfig:s}),getGaiaAddress({app:t,username:o,zoneFileLookupURL:n,gaiaHubConfig:s})]);if(!a)return a;if(!c)throw new SignatureVerificationError(`Failed to get gaia address for verification of: ${e}`);if(!u||typeof u!="string")throw new SignatureVerificationError(`Failed to obtain signature for file: ${e} -- looked in ${e}${SIGNATURE_FILE_SUFFIX}`);let y,f;try{const p=JSON.parse(u);y=p.signature,f=p.publicKey}catch(p){throw p instanceof SyntaxError?new Error(`Failed to parse signature content JSON (path: ${e}${SIGNATURE_FILE_SUFFIX}) The content may be corrupted.`):p}const h=crypto.publicKeyToBase58Address(f),l=typeof a=="string"?common.utf8ToBytes(a):a,d=crypto.verifyECDSA({signature:y,contents:l,publicKey:f});if(c!==h)throw new SignatureVerificationError(`Signer pubkey address (${h}) doesn't match gaia address (${c})`);if(d)return a;throw new SignatureVerificationError(`Contents do not match ECDSA signature: path: ${e}, signature: ${e}${SIGNATURE_FILE_SUFFIX}`)}catch(a){throw a instanceof DoesNotExist&&a.message.indexOf(i)>=0?new SignatureVerificationError(`Failed to obtain signature for file: ${e} -- looked in ${e}${SIGNATURE_FILE_SUFFIX}`):a}}async function handleSignedEncryptedContents(e){const{path:r,storedContents:t,app:o,privateKey:n,username:s,zoneFileLookupURL:i,gaiaHubConfig:a}=e,u=n,c=u?crypto.getPublicKey(u,!0):null;let y=null;if(s||a?y=await getGaiaAddress({app:o,username:s,zoneFileLookupURL:i,gaiaHubConfig:a}):c&&(y=crypto.publicKeyToBase58Address(c)),!y)throw new SignatureVerificationError(`Failed to get gaia address for verification of: ${r}`);let f;try{f=JSON.parse(t)}catch(w){throw w instanceof SyntaxError?new Error("Failed to parse encrypted, signed content JSON. The content may not be encrypted. If using getFile, try passing { verify: false, decrypt: false }."):w}const h=f.signature,l=f.publicKey,d=f.cipherText,p=crypto.publicKeyToBase58Address(l);if(!l||!d||!h)throw new SignatureVerificationError(`Failed to get signature verification data from file: ${r}`);if(p!==y)throw new SignatureVerificationError(`Signer pubkey address (${p}) doesn't match gaia address (${y})`);if(!crypto.verifyECDSA({signature:h,contents:d,publicKey:l}))throw new SignatureVerificationError(`Contents do not match ECDSA signature in file: ${r}`);if(!n)throw Error("Private key needs to be passed in order to decrypt content");const b={privateKey:n};return crypto.decryptContent(d,b)}var __defProp=Object.defineProperty,__getOwnPropSymbols=Object.getOwnPropertySymbols,__hasOwnProp=Object.prototype.hasOwnProperty,__propIsEnum=Object.prototype.propertyIsEnumerable,__defNormalProp=(e,r,t)=>r in e?__defProp(e,r,{enumerable:!0,configurable:!0,writable:!0,value:t}):e[r]=t,__spreadValues=(e,r)=>{for(var t in r||(r={}))__hasOwnProp.call(r,t)&&__defNormalProp(e,t,r[t]);if(__getOwnPropSymbols)for(var t of __getOwnPropSymbols(r))__propIsEnum.call(r,t)&&__defNormalProp(e,t,r[t]);return e};async function getFile(e,r){const t=__spreadValues({decrypt:!0,verify:!1,app:common.getGlobalObject("location",{returnEmptyObject:!0}).origin,zoneFileLookupURL:DEFAULT_ZONEFILE_LOOKUP_URL},r);if(t.verify&&!t.decrypt)return getFileSignedUnencrypted(e,t);const o=await getFileContents({path:e,app:t.app,username:t.username,zoneFileLookupURL:t.zoneFileLookupURL,forceText:!!t.decrypt,gaiaHubConfig:t.gaiaHubConfig});if(o===null)return o;if(typeof o!="string")throw new Error("[micro-stacks/storage] Expected to get back a string for the cipherText");let n=!!t.verify,s=!!t.decrypt;const i=typeof t.decrypt=="string"?t.decrypt:t.privateKey;if(o.includes("signature")&&o.includes("publicKey")&&(n=!0),o.includes("cipherText")&&o.includes("ephemeralPK")&&(s=!0),!n&&!s)return o;const a=!o.includes("cipherText");if(s&&a)throw new Error(`[micro-stacks/storage] Expected to get back a string that includes cipherText, is it encrypted? got back: ${JSON.stringify(o)}`);if(!i)throw new Error("[micro-stacks/storage] No private key was passed to getFile, a private key needs to be passed if decrypt is set to true");if(!n)return crypto.decryptContent(o,{privateKey:i});if(s&&n)return handleSignedEncryptedContents({path:e,storedContents:o,app:t.app,privateKey:i,username:t.username,zoneFileLookupURL:t.zoneFileLookupURL,gaiaHubConfig:t.gaiaHubConfig});throw new Error("[micro-stacks/storage] Should be unreachable.")}async function deleteFromGaiaHub(e,r){const t=await common.fetchPrivate(`${r.server}/delete/${r.address}/${e}`,{method:"DELETE",headers:{Authorization:`bearer ${r.token}`}});if(!t.ok)throw await getBlockstackErrorFromResponse(t,"Error deleting file from Gaia hub.",r)}async function deleteFile(e,r){const{gaiaHubConfig:t,wasSigned:o}=r,n=[deleteFromGaiaHub(e,t)];o&&n.push(deleteFromGaiaHub(`${e}${SIGNATURE_FILE_SUFFIX}`,t)),await Promise.all(n)}exports.deleteFile=deleteFile,exports.deleteFromGaiaHub=deleteFromGaiaHub,exports.generateGaiaHubConfig=generateGaiaHubConfig,exports.getFile=getFile,exports.getFullReadUrl=getFullReadUrl,exports.lookupProfile=lookupProfile,exports.makeScopedGaiaAuthToken=makeScopedGaiaAuthToken,exports.putFile=putFile,exports.uploadToGaiaHub=uploadToGaiaHub;
