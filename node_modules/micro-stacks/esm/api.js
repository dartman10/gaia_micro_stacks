import{fetchPrivate as T}from"micro-stacks/common";import{hexToCV as X,createAddress as Y,cvToHex as Q,cvToTrueValue as tt}from"micro-stacks/clarity";import{StacksMainnet as nt,StacksTestnet as ct}from"micro-stacks/network";import{StacksNetworkVersion as P}from"micro-stacks/crypto";const F=t=>typeof t=="number";function A(t){return t.map(n=>{switch(n){case"contract_call":case"smart_contract":case"token_transfer":case"coinbase":case"poison_microblock":return n;default:throw new Error(`Unexpected tx type: ${JSON.stringify(n)}`)}})}const R=t=>{let n;if(Array.isArray(t))n=A(t);else if(typeof t=="string")n=A([t]);else{if(t)throw new Error(`Unexpected tx type query value: ${JSON.stringify(t)}`);n=[]}return n},C=(t,n)=>n?.length?`${n.map((c,e)=>`${e>0?encodeURIComponent(`${t}[]`):""}=${encodeURIComponent(c)}`).join("&")}`:"",o=(t,n)=>{try{const c=new URL(t);return Object.keys(n).forEach(e=>{const s=n[e];if(!!s){if(Array.isArray(s))return s.length===0?void 0:c.searchParams.set(`${e}[]`,C(e,s));if(typeof s=="boolean"||F(s))return c.searchParams.set(e,String(s));c.searchParams.set(e,s)}}),c.toString()}catch(c){return console.error("generateUrl"),console.error(c),t}};function h(t){return`${t}/v1`}function $(t){return`${t}/v2`}function u(t){return`${t}/extended/v1`}function v(t){return`${u(t)}/status`}function O(t){return`${u(t)}/search`}function M(t){return`${u(t)}/fee_rate`}function m(t){return`${u(t)}/burnchain`}function k(t){return`${u(t)}/block`}function B(t){return`${u(t)}/contract`}function x(t){return`${u(t)}/tokens`}function _(t){return`${$(t)}/contracts`}function H(t){return`${$(t)}/fees/transfers`}function g(t){return`${u(t)}/microblock`}function I(t){return`${u(t)}/faucets/stx`}function j(t){return`${u(t)}/faucets/btc`}function L(t){return`${u(t)}/stx_supply`}function U(t){return`${u(t)}/stx_supply/total/plain`}function J(t){return`${u(t)}/stx_supply/circulating/plain`}function q(t){return`${u(t)}/stx_supply/legacy_format`}function p(t){return`${u(t)}/address`}function l(t){return`${u(t)}/tx`}function G(t){return`${$(t)}/info`}function V(t){return`${$(t)}/pox`}function z(t){return`${u(t)}/info/network_block_times`}function D(t){return`${u(t)}/info/network_block_time`}function E(t){return`${l(t)}/mempool`}async function r(t){return await(await T(t)).json()}async function S(t,n={}){const c={"Content-Type":"application/json; charset=utf-8",Accept:"application/json"},e=n.body?JSON.stringify(n.body):void 0,s={...n,method:"POST",body:e,headers:c};return await(await T(t,s)).json()}async function N(t){return(await T(t,{method:"GET",headers:{Accept:"text/plain"}})).text()}function et(t){if(!t)return 0;const{limit:n,offset:c,total:e}=t,s=c+n,a=e-s,i=a===0||Math.sign(a)===-1;if(!(Math.abs(a)===s||i))return s}async function rt({url:t,principal:n}){const c=`${p(t)}/${n}/balances`;return r(c)}async function ot({url:t,principal:n}){const c=`${p(t)}/${n}/stx`;return r(c)}async function st({url:t,principal:n,limit:c,offset:e=0,height:s,unanchored:a}){const i=`${p(t)}/${n}/transactions`,f=o(i,{limit:c,offset:e,height:s,unanchored:a});return r(f)}async function at({url:t,principal:n,tx_id:c,limit:e,offset:s=0,height:a,unanchored:i}){const f=`${p(t)}/${n}/${c}/transactions_with_transfers`,d=o(f,{limit:e,offset:s,height:a,unanchored:i});return r(d)}async function it({url:t,principal:n,limit:c,offset:e=0,height:s,unanchored:a}){const i=`${p(t)}/${n}/transactions_with_transfers`,f=o(i,{limit:c,offset:e,height:s,unanchored:a});return r(f)}async function ut({url:t,principal:n}){const c=`${p(t)}/${n}/nonces`;return r(c)}async function ft({url:t,principal:n,limit:c,offset:e=0,unanchored:s}){const a=`${p(t)}/${n}/assets`,i=o(a,{limit:c,offset:e,unanchored:s});return r(i)}async function ht({url:t,principal:n}){const c=`${p(t)}/${n}/stx_inbound`;return r(c)}async function pt({url:t,principal:n}){const c=`${p(t)}/${n}/nft_events`;return r(c)}async function dt({url:t,principal:n}){const c=`${p(t)}/${n}`;return r(c)}async function yt({url:t,principal:n,limit:c,offset:e=0}){const s=`${E(t)}`;if(n?.includes(".")){const i=o(s,{limit:c,offset:e}),f=await r(i),d=await Promise.all(f.results.filter(w=>JSON.stringify(w).includes(n)).map(async w=>$t({url:t,txid:w.tx_id})));return{...f,results:d}}else{const i=o(s,{limit:c,offset:e,address:n});return r(i)}}async function $t({url:t,txid:n}){return r(`${l(t)}/${n}`)}async function lt({url:t,limit:n,offset:c}){const e=o(k(t),{limit:n,offset:c});return r(e)}async function mt({url:t,hash:n}){const c=o(`${k(t)}/${n}`,{});return r(c)}async function kt({url:t,height:n}){const c=o(`${k(t)}/by_height/${n}`,{});return r(c)}async function wt({url:t,burn_block_hash:n}){const c=o(`${k(t)}/by_burn_block_hash/${n}`,{});return r(c)}async function bt({url:t,burn_block_height:n}){const c=o(`${k(t)}/by_burn_block_height/${n}`,{});return r(c)}async function xt({url:t,limit:n,offset:c}){const e=o(`${m(t)}/reward_slot_holders`,{limit:n,offset:c});return r(e)}async function St({url:t,limit:n,offset:c,address:e}){const s=o(`${m(t)}/reward_slot_holders/${e}`,{limit:n,offset:c});return r(s)}async function Tt({url:t,limit:n,offset:c}){const e=o(`${m(t)}/rewards`,{limit:n,offset:c});return r(e)}async function gt({url:t,limit:n,offset:c,address:e}){const s=o(`${m(t)}/rewards/${e}`,{limit:n,offset:c});return r(s)}async function Et({url:t,address:n}){const c=o(`${m(t)}/rewards/${n}/total`,{});return r(c)}async function At({url:t,tld:n}){const c=o(`${$(t)}/prices/namespaces/${n}`,{});return r(c)}async function Bt({url:t,name:n}){const c=o(`${$(t)}/prices/names/${n}`,{});return r(c)}async function _t({url:t}){const n=o(`${h(t)}/namespaces`,{});return r(n)}async function Nt({url:t,tld:n}){const c=o(`${h(t)}/namespaces/${n}/names`,{});return r(c)}async function Pt({url:t,page:n}){const c=o(`${h(t)}/names?page=${n}`,{});return r(c)}async function Ft({url:t,name:n}){const c=o(`${h(t)}/names/${n}`,{});return r(c)}async function Rt({url:t,name:n}){const c=o(`${h(t)}/names/${n}/history`,{});return r(c)}async function Ct({url:t,name:n}){const c=o(`${h(t)}/names/${n}/zonefile`,{});return r(c)}async function vt({url:t,name:n,zoneFileHash:c}){const e=o(`${h(t)}/names/${n}/zonefile/${c}`,{});return r(e)}async function Ot({url:t,blockchain:n,address:c}){const e=o(`${h(t)}/addresses/${n}/${c}`,{});return r(e)}async function Mt({url:t,page:n}){const c=o(`${h(t)}/subdomains/`,{page:n});return r(c)}async function Ht({url:t,txid:n}){const c=o(`${h(t)}/subdomains/${n}`,{});return r(c)}async function It({url:t}){const n=o(H(t),{});return r(n)}async function jt({url:t,contract_id:n,unanchored:c}){const e=o(`${B(t)}/${n}`,{unanchored:c});return r(e)}async function Lt({url:t,contract_id:n,limit:c,offset:e,unanchored:s}){const a=o(`${B(t)}/${n}/events`,{limit:c,offset:e,unanchored:s});return r(a)}async function Ut({url:t,contract_address:n,contract_name:c,tip:e}){const s=o(`${_(t)}/interface/${n}/${c}`,{tip:e});return r(s)}async function Jt({url:t,contract_name:n,contract_address:c,map_name:e,proof:s,tip:a,lookup_key:i}){const f=i,d=o(`${$(t)}/map_entry/${c}/${n}/${e}`,{proof:s,tip:a});return S(d,{body:f})}async function qt({url:t,contract_address:n,contract_name:c,proof:e,tip:s}){const a=o(`${_(t)}/source/${n}/${c}`,{proof:e,tip:s});return r(a)}async function Gt({url:t,id:n}){const c=o(`${O(t)}/`+n,{});return r(c)}async function Vt({url:t}){const n=o(`${x(t)}/ft/metadata`,{});return r(n)}async function zt({url:t}){const n=o(`${x(t)}/nft/metadata`,{});return r(n)}async function Dt({url:t,contractId:n}){const c=o(`${x(t)}/${n}/nft/metadata`,{});return r(c)}async function Wt({url:t,contractId:n}){const c=o(`${x(t)}/${n}/ft/metadata`,{});return r(c)}async function Zt({limit:t,offset:n,type:c,url:e}){const s=o(l(e),{limit:t,offset:n,type:c?R(c):void 0});return r(s)}async function Kt({limit:t,offset:n,sender_address:c,recipient_address:e,address:s,url:a}){const i=o(E(a),{limit:t,offset:n,sender_address:c,recipient_address:e,address:s});return r(i)}async function Xt({limit:t,offset:n,url:c}){const e=o(E(c),{limit:t,offset:n});return r(e)}async function Yt({txid:t,event_offset:n,event_limit:c,url:e}){const s=o(`${l(e)}/${t}`,{event_offset:n,event_limit:c});return r(s)}async function Qt({txid:t,url:n}){const c=`${l(n)}/${t}/raw`;return r(c)}async function tn({block_hash:t,url:n,limit:c,offset:e}){const s=`${l(n)}/block/${t}`;return r(o(s,{limit:c,offset:e}))}async function nn({block_height:t,url:n,limit:c,offset:e}){const s=`${l(n)}/block_height/${t.toString(10)}`;return r(o(s,{limit:c,offset:e}))}async function cn({url:t}){const n=o(G(t),{});return r(n)}async function en({url:t}){const n=o(v(t),{});return r(n)}async function rn({url:t}){const n=o(z(t),{});return r(n)}async function on({url:t,network:n}){const c=o(`${D(t)}/${n}`,{});return r(c)}async function sn({url:t,height:n}){const c=o(L(t),{});return r(c)}async function an({url:t}){const n=o(U(t),{});return N(n)}async function un({url:t}){const n=o(J(t),{});return N(n)}async function fn({url:t,height:n}){const c=o(q(t),{});return r(c)}async function hn({url:t}){const n=o(V(t),{});return r(n)}async function pn({url:t,address:n,stacking:c=!1}){const e=o(I(t),{});return S(e,{body:{address:n,stacking:c}})}async function dn({url:t,address:n}){const c=o(j(t),{});return S(c,{body:{address:n}})}async function yn({url:t,transaction:n}){const c=o(M(t),{});return S(c,{body:{transaction:n}})}async function $n({url:t,limit:n,offset:c}){const e=o(g(t),{limit:n,offset:c});return r(e)}async function ln({url:t,hash:n}){const c=o(`${g(t)}/${n}`,{});return r(c)}async function mn({url:t}){const n=o(`${g(t)}/unanchored/txs`,{});return r(n)}function W(t){if(t.okay)return X(t.result);throw new Error(t.cause)}function Z(t){const{version:n}=Y(t);return n===P.mainnetP2SH||n===P.mainnetP2PKH}async function K(t){const{contractName:n,contractAddress:c,functionName:e,functionArgs:s,senderAddress:a=c,tip:i}=t;let f=t.network;if(!t.network)try{f=Z(c)?new nt:new ct}catch(y){throw console.error(y),new Error("[micro-stacks] callReadOnlyFunction -> Incorrect Stacks addressed passed to contractAddress")}if(!f)throw Error("[micro-stacks] callReadOnlyFunction -> no network defined");let d=f.getReadOnlyFunctionCallApiUrl(c,n,e);i&&(d+=`?tip=${i}`);const w=JSON.stringify({sender:a,arguments:s.map(y=>typeof y=="string"?y:Q(y))}),b=await T(d,{method:"POST",body:w,headers:{"Content-Type":"application/json"}});if(!b.ok){let y="";try{y=await b.text()}catch{}throw new Error(`Error calling read-only function. Response ${b.status}: ${b.statusText}. Attempted to fetch ${d} and failed with the message: "${y}"`)}return W(await b.json())}async function kn(t,n){const c=await K(t);return tt(c,n)}export{p as addressEndpoint,k as blockEndpoint,j as btcFaucetEndpoint,m as burnchainEndpoint,K as callReadOnlyFunction,B as contractEndpoint,_ as contractsEndpoint,u as extendedEndpoint,M as feeRateEndpoint,H as feesEndpoint,It as feesSearch,ft as fetchAccountAssets,rt as fetchAccountBalances,dt as fetchAccountInfo,yt as fetchAccountMempoolTransactions,pt as fetchAccountNftEvents,ut as fetchAccountNonces,ot as fetchAccountStxBalance,ht as fetchAccountStxInbound,at as fetchAccountTransactionWithTransfers,st as fetchAccountTransactions,it as fetchAccountTransactionsWithTransfers,Mt as fetchAllSubdomains,mt as fetchBlock,wt as fetchBlockByBurnBlockHash,bt as fetchBlockByBurnBlockHeight,kt as fetchBlockByHeight,lt as fetchBlocks,xt as fetchBurnchainRewardSlotHolders,St as fetchBurnchainRewardSlotHoldersByAddress,Tt as fetchBurnchainRewards,gt as fetchBurnchainRewardsByAddress,jt as fetchContractById,Jt as fetchContractDataMapEntry,Lt as fetchContractEventsById,Ut as fetchContractInterface,qt as fetchContractSource,cn as fetchCoreApiInfo,Xt as fetchDroppedMempoolTransactionsList,yn as fetchFeeRate,Wt as fetchFtMetadataForContractId,Vt as fetchFtMetadataList,dn as fetchGetBtcTokens,pn as fetchGetStxTokens,vt as fetchHistoricalZoneFile,r as fetchJson,S as fetchJsonPost,Kt as fetchMempoolTransactionsList,ln as fetchMicroblock,$n as fetchMicroblocks,mn as fetchMicroblocksUnanchoredTransactions,Ft as fetchName,Rt as fetchNameHistory,Bt as fetchNamePrice,Pt as fetchNames,Ot as fetchNamesByAddress,Nt as fetchNamesFromNamespaces,At as fetchNamespacePrice,_t as fetchNamespaces,on as fetchNetworkBlockTime,rn as fetchNetworkBlockTimes,Dt as fetchNftMetadataForContractId,zt as fetchNftMetadataList,hn as fetchPox,Qt as fetchRawTransaction,kn as fetchReadOnlyFunction,Gt as fetchSearch,en as fetchStatus,sn as fetchStxSupply,un as fetchStxSupplyCirculatingPlain,fn as fetchStxSupplyLegacyFormat,an as fetchStxSupplyPlain,Ht as fetchSubdomainAtTransaction,N as fetchText,Et as fetchTotalBurnchainRewardsByAddress,Yt as fetchTransaction,tn as fetchTransactionsByBlockHash,nn as fetchTransactionsByBlockHeight,Zt as fetchTransactionsList,Ct as fetchZoneFile,C as generateQueryStringFromArray,o as generateUrl,et as getNextPageParam,G as infoEndpoint,Z as isMainnetAddress,F as isNumber,g as microblockEndpoint,D as networkBlockTimeEndpoint,z as networkBlockTimesEndpoint,W as parseReadOnlyResponse,A as parseTxTypeStrings,V as poxEndpoint,O as searchEndpoint,v as statusEndpoint,I as stxFaucetEndpoint,J as stxSupplyCirculatingPlainEndpoint,L as stxSupplyEndpoint,q as stxSupplyLegacyFormatEndpoint,U as stxSupplyPlainEndpoint,x as tokensEndpoint,l as txEndpoint,E as txMempoolEndpoint,h as v1Endpoint,$ as v2Endpoint,R as validateTxTypes};
