import{validateMnemonic as C,mnemonicToEntropy as X,generateMnemonic as q,mnemonicToSeed as z,entropyToMnemonic as Q}from"@scure/bip39";import{HARDENED_OFFSET as Y,HDKey as d}from"@scure/bip32";import{wordlist as m}from"@scure/bip39/wordlists/english";import{bytesToHex as s,utf8ToBytes as w,concatByteArrays as T,hexToBytes as W}from"micro-stacks/common";import{hashSha256 as h}from"micro-stacks/crypto-sha";import{getRandomBytes as Z,StacksNetworkVersion as ee,privateKeyToStxAddress as te,publicKeyToBase58Address as ne,getPublicKey as _,encryptECIES as re,publicKeyToStxAddress as oe,TokenSigner as ie}from"micro-stacks/crypto";import{aes128CbcEncrypt as ce,aes128CbcDecrypt as ae}from"micro-stacks/crypto-aes";import{hmacSha256 as N}from"micro-stacks/crypto-hmac-sha";import{createPbkdf2 as I}from"micro-stacks/crypto-pbkdf2";import{generateGaiaHubConfig as se,getFile as pe,putFile as de}from"micro-stacks/storage";const D="m/888'/0'",ye="m/44/5757'/0'/1",ue="m/44'/5757'/0'/0",M="wallet-config.json",fe="https://hub.blockstack.org";function le(e){return e.length===32||e.length===33&&(e[0]===2||e[0]===3)}function v(e){return e+Y}const H=e=>{const t=e.derive(ye).privateKey;if(!t)throw new TypeError("Unable to derive config key for wallet identities");return s(t)},me=e=>{const r=d.fromExtendedKey(e).deriveChild(v(45)).privateKey;if(!r)throw new TypeError("Unable to derive config key for wallet identities");return s(r)};function O(e){const t=e.derive(D).publicKey;if(!t)throw new TypeError("Unable to derive public key from data derivation path");return s(h(w(s(t))))}function F(e){if(!e.privateKey)throw Error("no private key");const t=O(e),n=e.privateExtendedKey,r=H(e);return{salt:t,rootKey:n,configPrivateKey:r}}async function U(e,t,n=Z(16)){if(!C(e,m))throw new Error("Not a valid bip39 mnemonic");const r=await I(),i=X(e,m),o=await r.derive(t,n,1e5,48,"sha512"),c=o.slice(0,16),a=o.slice(16,32),p=o.slice(32,48),y=await ce(p,c,i),f=T([n,y]),l=N(a,f);return T([n,l,y])}function P(e,t,n){const r=e.derive(ue).deriveChild(t);if(!r.privateKey)throw Error("no private key");const o=e.derive(D).deriveChild(v(t));if(!o.privateKey)throw new Error("Must have private key to derive identities");const c=s(o.privateKey),a=o.deriveChild(v(0)).privateExtendedKey;return{stxPrivateKey:`${s(r.privateKey)}${le(r.privateKey)?"01":""}`,dataPrivateKey:c,appsKey:a,salt:n,index:t}}function B(e){return P(d.fromExtendedKey(e.rootKey),e.accounts.length,e.salt)}function L(e,t,n){const r=[],i=[...Array(t).keys()];for(const o of i){const a=(n||(e.accounts.length>0?e.accounts.length-1:0))+o;e.accounts[a]||r.push(P(d.fromExtendedKey(e.rootKey),a,e.salt))}return r}function he(e=256){if(e!==256&&e!==128)throw TypeError(`Incorrect entropy bits provided, expected 256 or 128 (24 or 12 word results), got: "${String(e)}".`);return q(m,e)}async function ve(e,t){const[n,r]=await Promise.all([z(e),U(e,t)]),i=s(r),o=F(d.fromMasterSeed(n));return R({...o,encryptedSecretKey:i,accounts:[]})}function R(e){return{...e,accounts:[...e.accounts,B(e)]}}function Ke(e,t=ee.mainnetP2PKH){const n=e.stxPrivateKey.endsWith("01");return te(e.stxPrivateKey.slice(0,64),t,n)}const ge={private:76066276,public:76067358};function xe(e){let t=0;if(e.length===0)return t;for(let n=0;n<e.length;n++){const r=e.charCodeAt(n);t=(t<<5)-t+r,t&=t}return t&2147483647}function we(e,t,n=!0){if(n)return ke(e,t);const r=h(w(`${t}${e.salt}`)),i=d.fromExtendedKey(e.appsKey);if(!i.privateKey)throw Error("no rootNode.privateKey");const o=new d({privateKey:i.privateKey,chainCode:r,versions:ge}).deriveChild(v(0));if(!o.privateKey)throw new Error("[micro-stacks/wallet-sdk] getAppPrivateKey: No private key found");return s(o.privateKey)}function ke(e,t){const n=s(h(w(`${t}${e.salt}`))),r=xe(n),i=d.fromExtendedKey(e.appsKey).deriveChild(v(r));if(!i.privateKey)throw new Error("[micro-stacks/wallet-sdk] getLegacyAppPrivateKey: No private key found");return s(i.privateKey)}function Ae(e){const t=e.stxPrivateKey.endsWith("01");return ne(_(e.dataPrivateKey,t))}async function Ee(e,t){const n=typeof e=="string"?W(e):e,r=n.slice(0,16),i=n.slice(16,48),o=n.slice(48),c=T([r,o]),p=await(await I()).derive(t,r,1e5,48,"sha512"),y=p.slice(0,16),f=p.slice(16,32),l=p.slice(32,48),K=await ae(l,y,o),A=N(f,c),g=h(i),x=h(A);if(s(g)!==s(x))throw new Error("Wrong password (HMAC mismatch)");let u;try{u=Q(K,m)}catch(E){throw console.error("Error thrown by `entropyToMnemonic`"),console.error(E),new Error("Wrong password (invalid plaintext)")}if(!C(u,m))throw new Error("Wrong password (invalid plaintext)");return u}function $(e){return`did:btc-addr:${e}`}function G(){return new Date(new Date().setMonth(new Date().getMonth()+1))}function V(){let e=new Date().getTime();return typeof performance!="undefined"&&typeof performance.now=="function"&&(e+=performance.now()),"xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx".replace(/[xy]/g,t=>{const n=(e+Math.random()*16)%16|0;return e=Math.floor(e/16),(t==="x"?n:n&3|8).toString(16)})}async function b(e,t){const n=await re({content:W(t),publicKey:e,cipherTextEncoding:"hex",wasString:!1}),r=JSON.stringify(n);return s(w(r))}async function Te(e){let{expiresAt:t}=e;const{privateKey:n,appPrivateKey:r,coreToken:i,transitPublicKey:o,metadata:c,hubUrl:a,blockstackAPIUrl:p,associationToken:y,username:f,profile:l}=e,K=s(_(n)),A=oe(K);t||(t=G().getTime());let g=r,x=i,u={};r!=null&&(o!=null&&(g=await b(o,r),i!=null&&(x=await b(o,i))),u={email:c?.email?c.email:null,profile_url:c?.profileUrl?c.profileUrl:null,hubUrl:a,blockstackAPIUrl:p,associationToken:y,version:"undefined"});const E={jti:V(),iat:Math.floor(new Date().getTime()/1e3),exp:Math.floor(t/1e3),iss:$(A),private_key:g??null,public_keys:[K],profile:l??null,username:f??null,core_token:x??null,...u};return new ie("ES256k",n).sign(E)}function S(e,t=fe){return se({gaiaHubUrl:t,privateKey:e})}async function J(e,t){try{let n=t?.gaiaHubConfig;n||(n=await S(e,t?.gaiaHubUrl));const r=await pe(M,{privateKey:e,gaiaHubConfig:n});if(typeof r!="string"){console.error("Wallet config response should be of type string");return}return JSON.parse(r)}catch{}}function j(e){return{accounts:e.accounts.map(t=>({username:t.username,apps:{}}))}}async function k({walletConfig:e,privateKey:t,gaiaHubConfig:n,gaiaHubUrl:r}){n||(n=await S(t,r)),await de(M,JSON.stringify(e),{gaiaHubConfig:n,privateKey:t,encrypt:!0,sign:!0})}async function Pe({wallet:e,gaiaHubConfig:t,gaiaHubUrl:n}){let r=await J(e.configPrivateKey,{gaiaHubConfig:t,gaiaHubUrl:n});return r||(r=j(e),await k({walletConfig:r,gaiaHubConfig:t,gaiaHubUrl:n,privateKey:e.configPrivateKey})),r}function be({wallet:e,walletConfig:t}){if(!t||t.accounts.length===0)return e;const n=t.accounts.length,r=L(e,n);return{...e,accounts:r}}function Se({wallet:e,walletConfig:t,app:n,account:r}){for(const i of e.accounts){let o=0;const c=t.accounts[o];if(c?(c.apps=c.apps||{},c.username=i?.username,t.accounts[o]=c):t.accounts.push({username:i?.username,apps:{}}),o===r.index){const a=t.accounts[o];a.apps=a.apps||{},a.apps[n.origin]=n,t.accounts[o]=a}o+=1}return t}const Ce=async({wallet:e,account:t,app:n,walletConfig:r,gaiaHubConfig:i})=>{const o=Se({wallet:e,walletConfig:r,app:n,account:t});return await k({walletConfig:o,gaiaHubConfig:i,privateKey:e.configPrivateKey}),r},We=async({wallet:e,walletConfig:t,gaiaHubConfig:n})=>{const r={...t,accounts:[...t.accounts,{apps:{}}]};return await k({walletConfig:r,gaiaHubConfig:n,privateKey:e.configPrivateKey}),t};export{We as addNewAccountToWalletConfig,S as createWalletConfigGaiaHubConfig,Ee as decryptMnemonic,P as deriveAccount,H as deriveConfigPrivateKey,me as deriveLegacyConfigPrivateKey,L as deriveManyAccountsForWallet,B as deriveNextAccountFromWallet,O as deriveSalt,F as deriveWalletKeys,U as encryptMnemonic,b as encryptPrivateKey,J as fetchWalletConfig,R as generateAndInsertNewAccount,he as generateSecretKey,ve as generateWallet,we as getAppPrivateKey,Ae as getGaiaAddress,Pe as getOrSetWalletConfig,Ke as getStxAddressFromAccount,Te as makeAuthResponse,$ as makeDIDFromAddress,V as makeUUID4,j as makeWalletConfig,G as nextMonth,be as restoreWalletAccountsFromWalletConfig,k as saveWalletConfig,Ce as updateWalletConfigWithApp};
