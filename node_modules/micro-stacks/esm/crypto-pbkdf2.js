import{getCryptoLib as p}from"micro-stacks/crypto-aes";import{utf8ToBytes as b,ensureUint8Array as f}from"micro-stacks/common";import{pbkdf2Async as d}from"@noble/hashes/pbkdf2";import{sha512 as y}from"@noble/hashes/sha512";class m{constructor(r){this.nodePbkdf2=r}async derive(r,o,s,n,e){if(e!=="sha512"&&e!=="sha256")throw new Error(`Unsupported digest "${e}" for Pbkdf2`);return new Promise((a,c)=>{this.nodePbkdf2(r,o,s,n,e,(i,h)=>{i&&c(i),a(h)})})}}class u{constructor(r){this.webCrypto=r}async derive(r,o,s,n,e){let a;if(e==="sha256")a="SHA-256";else if(e==="sha512")a="SHA-512";else throw new Error(`Unsupported Pbkdf2 digest algorithm "${e}"`);const c=await this.webCrypto.subtle.importKey("raw",b(r),"PBKDF2",!1,["deriveBits"]),i=await this.webCrypto.subtle.deriveBits({name:"PBKDF2",salt:o,iterations:s,hash:{name:a}},c,n*8);return new Uint8Array(i)}}async function w(){try{const t=await p();return t.name==="webCrypto"?new u(t.lib):new m(t.lib.pbkdf2)}catch{return{derive(r,o,s,n,e="sha512"){return d(y,f(b(r)),f(o),{c:s,dkLen:n})}}}}export{w as createPbkdf2};
