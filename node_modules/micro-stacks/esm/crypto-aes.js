import{concatByteArrays as y}from"micro-stacks/common";class h{constructor(e){this.webCrypto=e}async encrypt(e,r,n,o){let c,s;if(e==="aes-128-cbc")c="AES-CBC",s=128;else if(e==="aes-256-cbc")c="AES-CBC",s=256;else throw new Error(`Unsupported cipher algorithm "${e}"`);const p=await this.webCrypto.subtle.importKey("raw",r,{name:c,length:s},!1,["encrypt"]),a=await this.webCrypto.subtle.encrypt({name:c,iv:n},p,o);return new Uint8Array(a)}async decrypt(e,r,n,o){let c,s;if(e==="aes-128-cbc")c="AES-CBC",s=128;else if(e==="aes-256-cbc")c="AES-CBC",s=256;else throw new Error(`Unsupported cipher algorithm "${e}"`);const p=await this.webCrypto.subtle.importKey("raw",r,{name:c,length:s},!1,["decrypt"]),a=await this.webCrypto.subtle.decrypt({name:c,iv:n},p,o);return new Uint8Array(a)}}class C{constructor(e,r){this.createCipher=e,this.createDecipher=r}async encrypt(e,r,n,o){if(e!=="aes-128-cbc"&&e!=="aes-256-cbc")throw new Error(`Unsupported cipher algorithm "${e}"`);const c=this.createCipher(e,r,n),s=y([c.update(o),c.final()]);return Promise.resolve(s)}async decrypt(e,r,n,o){if(e!=="aes-128-cbc"&&e!=="aes-256-cbc")throw new Error(`Unsupported cipher algorithm "${e}"`);const c=this.createDecipher(e,r,n),s=y([c.update(o),c.final()]);return Promise.resolve(s)}}function u(){return typeof crypto!="undefined"&&typeof crypto.subtle!="undefined"}function f(t){try{if(!require.resolve("crypto"))return!1;const r=require("crypto");return r?t?t(r):!0:!1}catch{return!1}}const l='Crypto lib not found. Either the WebCrypto "crypto.subtle" or Node.js "crypto" module must be available.';async function b(){if(u())return{lib:crypto,name:"webCrypto"};try{return{lib:require("crypto"),name:"nodeCrypto"}}catch{throw new Error(l)}}async function i(){const t=await b();return t.name==="webCrypto"?new h(t.lib):new C(t.lib.createCipheriv,t.lib.createDecipheriv)}async function w(t,e,r){return(await i()).encrypt("aes-256-cbc",e,t,r)}async function d(t,e,r){return(await i()).decrypt("aes-256-cbc",e,t,r)}async function m(t,e,r){return(await i()).encrypt("aes-128-cbc",e,t,r)}async function E(t,e,r){return(await i()).decrypt("aes-128-cbc",e,t,r)}export{l as NO_CRYPTO_LIB,E as aes128CbcDecrypt,m as aes128CbcEncrypt,d as aes256CbcDecrypt,w as aes256CbcEncrypt,b as getCryptoLib,f as isNodeCryptoAvailable,u as isSubtleCryptoAvailable};
