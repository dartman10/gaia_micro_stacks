import{TransactionVersion as E,bytesToHex as w,hexToBytes as b,hexStringToInt as Oe,hexToBigInt as Pn,BufferArray as T,concatByteArrays as bn,intToHex as Tn,intToHexString as An,intToBigInt as S,writeUInt32BE as En,intToBytes as $,DeserializationError as k,utf8ToBytes as De,bytesToUtf8 as Ct,writeUInt16BE as mt,SigningError as I,cloneDeep as z,BufferReader as Ve,DEFAULT_CHAIN_ID as Pt,SerializationError as R,NotImplementedError as fe,fetchPrivate as G,omit as he}from"micro-stacks/common";import{hashSha512_256 as bt}from"micro-stacks/crypto-sha";import{hexToCV as Tt,StacksMessageType as a,COMPRESSED_PUBKEY_LENGTH_BYTES as At,UNCOMPRESSED_PUBKEY_LENGTH_BYTES as Et,principalCV as kt,createAddress as ge,createLPString as L,serializeCV as _e,COINBASE_BUFFER_LENGTH_BYTES as We,deserializeLPString as H,deserializeAddress as ee,deserializeCV as qe,serializeLPString as ye,serializeAddress as Ge,PostConditionPrincipalID as ne,exceedsMaxLengthBytes as Bt,MEMO_MAX_LENGTH_BYTES as we,RECOVERABLE_ECDSA_SIG_LENGTH_BYTES as Se,ClarityAbiTypeId as d,stringUtf8CV as It,stringAsciiCV as Ht,bufferCV as Nt,noneCV as Kt,contractPrincipalCV as Xe,standardPrincipalCV as kn,falseCV as Bn,trueCV as In,intCV as Hn,uintCV as Nn,getCVTypeString as $t,bufferCVFromString as zt,ClarityType as P}from"micro-stacks/clarity";import{Signature as Kn,Point as $n,getPublicKey as Ut,utils as xt,sign as Mt}from"@noble/secp256k1";import{StacksNetworkVersion as A,hashP2WSH as Ft,hashP2SH as vt,hashP2WPKH as Lt,hashP2PKH as Ot,publicKeyToStxAddress as zn,c32address as Un}from"micro-stacks/crypto";import{StacksMainnet as U,StacksTestnet as Dt}from"micro-stacks/network";export{callReadOnlyFunction}from"micro-stacks/api";const Vt=16,_t="https://stacks-node-api.mainnet.stacks.co";var X;(function(e){e[e.OnChainOnly=1]="OnChainOnly",e[e.OffChainOnly=2]="OffChainOnly",e[e.Any=3]="Any"})(X||(X={}));const Wt=E.Mainnet;var x;(function(e){e[e.Allow=1]="Allow",e[e.Deny=2]="Deny"})(x||(x={}));var C;(function(e){e[e.STX=0]="STX",e[e.Fungible=1]="Fungible",e[e.NonFungible=2]="NonFungible"})(C||(C={}));var f;(function(e){e[e.Standard=4]="Standard",e[e.Sponsored=5]="Sponsored"})(f||(f={}));var p;(function(e){e[e.SerializeP2PKH=0]="SerializeP2PKH",e[e.SerializeP2SH=1]="SerializeP2SH",e[e.SerializeP2WPKH=2]="SerializeP2WPKH",e[e.SerializeP2WSH=3]="SerializeP2WSH"})(p||(p={}));var Je;(function(e){e[e.MainnetSingleSig=22]="MainnetSingleSig",e[e.MainnetMultiSig=20]="MainnetMultiSig",e[e.TestnetSingleSig=26]="TestnetSingleSig",e[e.TestnetMultiSig=21]="TestnetMultiSig"})(Je||(Je={}));var h;(function(e){e[e.Compressed=0]="Compressed",e[e.Uncompressed=1]="Uncompressed"})(h||(h={}));var te;(function(e){e[e.Equal=1]="Equal",e[e.Greater=2]="Greater",e[e.GreaterEqual=3]="GreaterEqual",e[e.Less=4]="Less",e[e.LessEqual=5]="LessEqual"})(te||(te={}));var Ce;(function(e){e[e.DoesNotOwn=16]="DoesNotOwn",e[e.Owns=17]="Owns"})(Ce||(Ce={}));var Ye;(function(e){e[e.STX=0]="STX",e[e.Fungible=1]="Fungible",e[e.NonFungible=2]="NonFungible"})(Ye||(Ye={}));var Ze;(function(e){e.Serialization="Serialization",e.Deserialization="Deserialization",e.SignatureValidation="SignatureValidation",e.FeeTooLow="FeeTooLow",e.BadNonce="BadNonce",e.NotEnoughFunds="NotEnoughFunds",e.NoSuchContract="NoSuchContract",e.NoSuchPublicFunction="NoSuchPublicFunction",e.BadFunctionArgument="BadFunctionArgument",e.ContractAlreadyExists="ContractAlreadyExists",e.PoisonMicroblocksDoNotConflict="PoisonMicroblocksDoNotConflict",e.PoisonMicroblockHasUnknownPubKeyHash="PoisonMicroblockHasUnknownPubKeyHash",e.PoisonMicroblockIsInvalid="PoisonMicroblockIsInvalid",e.BadAddressVersionByte="BadAddressVersionByte",e.NoCoinbaseViaMempool="NoCoinbaseViaMempool",e.ServerFailureNoSuchChainTip="ServerFailureNoSuchChainTip",e.ServerFailureDatabase="ServerFailureDatabase",e.ServerFailureOther="ServerFailureOther"})(Ze||(Ze={}));const xn=e=>e.length%2==0?e:`0${e}`,Qe=(e,n)=>e.padStart(n,"0"),Mn=(e,n)=>e.padEnd(n,"0"),me=e=>{const n=bt(e);return w(n)};function qt(e){if(e.okay)return Tt(e.result);throw new Error(e.cause)}function O(e){return{type:a.PublicKey,data:b(e)}}function Fn(e,n,t=h.Compressed){const r=On(n.data),i=new Kn(Pn(r.r),Pn(r.s)),s=$n.fromSignature(e,i,r.recoveryParam),o=t===h.Compressed;return s.toHex(o)}function Pe(e){return{type:a.PublicKey,data:e}}function M(e){return w(e.data)}function D(e){return!M(e).startsWith("04")}function je(e){const n=typeof e=="string"?b(e):e;let t=!1;if(n.length===33){if(n[n.length-1]!==1)throw new Error("Improperly formatted private-key. 33 byte length usually indicates compressed key, but last byte must be == 0x01");t=!0}return t}function J(e){const n=new T;return n.push(e.data),n.concatBuffer()}function re(e){const n=N(e),t=je(e),r=Ut(n.data.slice(0,32),t||n.compressed);return O(w(r))}function vn(e){const n=typeof e=="string"?e:w(e),t=$n.fromHex(n).toHex(!0);return O(t)}function ie(e){const n=e.readUInt8(),t=n!==4?At:Et;return Pe(bn([Uint8Array.from([n]),e.readBuffer(t)]))}function N(e){const n=typeof e=="string"?b(e):e;let t;if(n.length===33){if(n[n.length-1]!==1)throw new Error("Improperly formatted private-key. 33 byte length usually indicates compressed key, but last byte must be == 0x01");t=!0}else if(n.length===32)t=!1;else throw new Error(`Improperly formatted private-key hex string: length should be 32 or 33 bytes, provided with length ${n.length}`);return{data:n,compressed:t}}function Gt(){return N(xt.randomPrivateKey())}async function Ln(e,n){const[t,r]=await Mt(n,e.data.slice(0,32),{canonical:!0,recovered:!0}),i=Kn.fromHex(t),s=32,o=Qe(Tn(i.r),s*2),c=Qe(Tn(i.s),s*2);if(r==null)throw new Error('"signature.recoveryParam" is not set');const l=An(r,1)+o+c;return ke(l)}function Xt(e){const n=32;if(e.length<n*2*2+1)throw new Error("Invalid signature");const t=e.substr(0,2);return Oe(t)}function On(e){const n=32;if(e.length<n*2*2+1)throw new Error("Invalid signature");const t=e.substr(0,2),r=e.substr(2,n*2),i=e.substr(2+n*2,n*2);return{recoveryParam:Oe(t),r,s:i}}function se(e){return re(e.data)}function Jt(e){return w(e.data)}var y;(function(e){e[e.TokenTransfer=0]="TokenTransfer",e[e.SmartContract=1]="SmartContract",e[e.ContractCall=2]="ContractCall",e[e.PoisonMicroblock=3]="PoisonMicroblock",e[e.Coinbase=4]="Coinbase"})(y||(y={}));function Dn(e,n,t){return typeof e=="string"&&(e=kt(e)),typeof t=="string"&&(t=on(t)),{type:a.Payload,payloadType:0,recipient:e,amount:S(n,!1),memo:t??on("")}}function Vn(e,n,t,r){return typeof e=="string"&&(e=ge(e)),typeof n=="string"&&(n=L(n)),typeof t=="string"&&(t=L(t)),{type:a.Payload,payloadType:2,contractAddress:e,contractName:n,functionName:t,functionArgs:r}}function _n(e,n){return typeof e=="string"&&(e=L(e)),typeof n=="string"&&(n=Yn(n)),{type:a.Payload,payloadType:1,contractName:e,codeBody:n}}function Yt(){return{type:a.Payload,payloadType:3}}function Zt(e){if(e.byteLength!=We)throw Error(`Coinbase buffer size must be ${We} bytes`);return{type:a.Payload,payloadType:4,coinbaseBuffer:e}}function Wn(e){const n=new T;switch(n.appendByte(e.payloadType),e.payloadType){case 0:n.push(_e(e.recipient)),n.push($(e.amount,!1,8)),n.push(F(e.memo));break;case 2:n.push(F(e.contractAddress)),n.push(F(e.contractName)),n.push(F(e.functionName));const t=new Uint8Array(4);En(t,e.functionArgs.length,0),n.push(t),e.functionArgs.forEach(r=>{n.push(_e(r))});break;case 1:n.push(F(e.contractName)),n.push(F(e.codeBody));break;case 3:break;case 4:n.push(e.coinbaseBuffer);break}return n.concatBuffer()}function qn(e){switch(e.readUInt8Enum(y,t=>{throw new Error(`Cannot recognize PayloadType: ${t}`)})){case 0:const t=qe(e),r=S(e.readBuffer(8),!1),i=Te(e);return Dn(t,r,i);case 2:const s=ee(e),o=H(e),c=H(e),u=[],l=e.readUInt32BE();for(let pe=0;pe<l;pe++){const Le=qe(e);u.push(Le)}return Vn(s,o,c,u);case 1:const g=H(e),m=H(e,4,1e5);return _n(g,m);case 3:return Yt();case 4:const B=e.readBuffer(We);return Zt(B)}}function Re(e,n,t){return typeof e=="string"&&(e=be(e)),{type:a.PostCondition,conditionType:C.STX,principal:e,conditionCode:n,amount:S(t,!1)}}function en(e,n,t,r){return typeof e=="string"&&(e=be(e)),typeof r=="string"&&(r=an(r)),{type:a.PostCondition,conditionType:C.Fungible,principal:e,conditionCode:n,amount:S(t,!1),assetInfo:r}}function nn(e,n,t,r){return typeof e=="string"&&(e=be(e)),typeof t=="string"&&(t=an(t)),{type:a.PostCondition,conditionType:C.NonFungible,principal:e,conditionCode:n,assetInfo:t,assetName:r}}function Gn(e){const n=new T;return n.appendByte(e.conditionType),n.push(rn(e.principal)),(e.conditionType===C.Fungible||e.conditionType===C.NonFungible)&&n.push(cn(e.assetInfo)),e.conditionType===C.NonFungible&&n.push(_e(e.assetName)),n.appendByte(e.conditionCode),(e.conditionType===C.STX||e.conditionType===C.Fungible)&&n.push($(e.amount,!1,8)),n.concatBuffer()}function tn(e){const n=e.readUInt8Enum(C,o=>{throw new k(`Could not read ${o} as PostConditionType`)}),t=sn(e);let r,i,s;switch(n){case C.STX:return r=e.readUInt8Enum(te,c=>{throw new k(`Could not read ${c} as FungibleConditionCode`)}),s=BigInt("0x"+w(e.readBuffer(8))),{type:a.PostCondition,conditionType:C.STX,principal:t,conditionCode:r,amount:s};case C.Fungible:return i=ue(e),r=e.readUInt8Enum(te,c=>{throw new k(`Could not read ${c} as FungibleConditionCode`)}),s=BigInt("0x"+w(e.readBuffer(8))),{type:a.PostCondition,conditionType:C.Fungible,principal:t,conditionCode:r,amount:s,assetInfo:i};case C.NonFungible:i=ue(e);const o=qe(e);return r=e.readUInt8Enum(Ce,c=>{throw new k(`Could not read ${c} as FungibleConditionCode`)}),{type:a.PostCondition,conditionType:C.NonFungible,principal:t,conditionCode:r,assetInfo:i,assetName:o}}}function F(e){switch(e.type){case a.Address:return Ge(e);case a.Principal:return rn(e);case a.LengthPrefixedString:return ye(e);case a.MemoString:return Zn(e);case a.AssetInfo:return cn(e);case a.PostCondition:return Gn(e);case a.PublicKey:return J(e);case a.LengthPrefixedList:return Ae(e);case a.Payload:return Wn(e);case a.TransactionAuthField:return jn(e);case a.MessageSignature:return Ie(e)}}function Qt(e,n,t){switch(n){case a.Address:return ee(e);case a.Principal:return sn(e);case a.LengthPrefixedString:return H(e);case a.MemoString:return Te(e);case a.AssetInfo:return ue(e);case a.PostCondition:return tn(e);case a.PublicKey:return ie(e);case a.Payload:return qn(e);case a.LengthPrefixedList:if(!t)throw new k("No List Type specified");return Ee(e,t);case a.MessageSignature:return le(e);default:throw new Error("Could not recognize StacksMessageType")}}function Xn(){return{type:a.Address,version:A.mainnetP2PKH,hash160:"0".repeat(40)}}function Y(e,n){return{type:a.Address,version:e,hash160:n}}function Jn(e,n){switch(e){case p.SerializeP2PKH:switch(n){case E.Mainnet:return A.mainnetP2PKH;case E.Testnet:return A.testnetP2PKH;default:throw new Error(`Unexpected txVersion ${JSON.stringify(n)} for hashMode ${e}`)}case p.SerializeP2SH:case p.SerializeP2WPKH:case p.SerializeP2WSH:switch(n){case E.Mainnet:return A.mainnetP2SH;case E.Testnet:return A.testnetP2SH;default:throw new Error(`Unexpected txVersion ${JSON.stringify(n)} for hashMode ${e}`)}default:throw new Error(`Unexpected hashMode ${JSON.stringify(e)}`)}}function jt(e,n,t){const r=Jn(e,n);return Y(r,t)}function oe(e,n,t,r){if(r.length===0)throw Error("Invalid number of public keys");if((n===p.SerializeP2PKH||n===p.SerializeP2WPKH)&&(r.length!==1||t!==1))throw Error("Invalid number of public keys or signatures");if(n===p.SerializeP2WPKH||n===p.SerializeP2WSH){for(let i=0;i<r.length;i++)if(!D(r[i]))throw Error("Public keys must be compressed for segwit")}switch(n){case p.SerializeP2PKH:return Y(e,Ot(r[0].data));case p.SerializeP2WPKH:return Y(e,Lt(r[0].data));case p.SerializeP2SH:return Y(e,vt(t,r.map(J)));case p.SerializeP2WSH:return Y(e,Ft(t,r.map(J)))}}function be(e){if(e.includes(".")){const[n,t]=e.split(".");return ce(n,t)}else return ae(e)}function ae(e){return{type:a.Principal,prefix:ne.Standard,address:ge(e)}}function ce(e,n){return{type:a.Principal,prefix:ne.Contract,contractName:L(n),address:ge(e)}}function rn(e){const n=new T;return n.push(Uint8Array.from([e.prefix])),n.push(Ge(e.address)),e.prefix===ne.Contract&&n.push(ye(e.contractName)),n.concatBuffer()}function sn(e){const n=e.readUInt8Enum(ne,i=>{throw new k("Unexpected Principal payload type: ${n}")}),t=ee(e);if(n===ne.Standard)return{type:a.Principal,prefix:n,address:t};const r=H(e);return{type:a.Principal,prefix:n,address:t,contractName:r}}function Yn(e){return L(e,4,1e5)}function on(e){if(e&&Bt(e,we))throw new Error(`Memo exceeds maximum length of ${we.toString()} bytes`);return{type:a.MemoString,content:e}}function Zn(e){const n=new T,t=De(e.content),r=Mn(w(t),we*2);return n.push(b(r)),n.concatBuffer()}function Te(e){const n=e.readBuffer(we),t=n.indexOf(0),r=Ct(n.slice(0,t));return{type:a.MemoString,content:r}}function an(e){const[n,t,r]=e.split(/\.|::/);return Qn(n,t,r)}function Qn(e,n,t){return{type:a.AssetInfo,address:ge(e),contractName:L(n),assetName:L(t)}}function cn(e){const n=new T;return n.push(Ge(e.address)),n.push(ye(e.contractName)),n.push(ye(e.assetName)),n.concatBuffer()}function ue(e){return{type:a.AssetInfo,address:ee(e),contractName:H(e),assetName:H(e)}}function V(e,n){return{type:a.LengthPrefixedList,lengthPrefixBytes:n||4,values:e}}function Ae(e){const n=e.values,t=new T;t.appendHexString(An(n.length,e.lengthPrefixBytes));for(let r=0;r<n.length;r++)t.push(F(n[r]));return t.concatBuffer()}function Ee(e,n,t){const r=Oe(w(e.readBuffer(t||4))),i=[];for(let s=0;s<r;s++)switch(n){case a.Address:i.push(ee(e));break;case a.LengthPrefixedString:i.push(H(e));break;case a.MemoString:i.push(Te(e));break;case a.AssetInfo:i.push(ue(e));break;case a.PostCondition:i.push(tn(e));break;case a.PublicKey:i.push(ie(e));break;case a.TransactionAuthField:i.push(Rn(e));break}return V(i,t)}class Rt{static deserialize(n){const t=new this;return t.deserialize(n),t}}function ke(e){if(b(e).byteLength!=Se)throw Error("Invalid signature");return{type:a.MessageSignature,data:e}}function Be(){return{type:a.MessageSignature,data:w(new Uint8Array(Se).fill(0))}}function Ie(e){const n=new T;return n.appendHexString(e.data),n.concatBuffer()}function le(e){return ke(w(e.readBuffer(Se)))}var un;(function(e){e[e.PublicKeyCompressed=0]="PublicKeyCompressed",e[e.PublicKeyUncompressed=1]="PublicKeyUncompressed",e[e.SignatureCompressed=2]="SignatureCompressed",e[e.SignatureUncompressed=3]="SignatureUncompressed"})(un||(un={}));function _(e,n){return{pubKeyEncoding:e,type:a.TransactionAuthField,contents:n}}function jn(e){const n=new T;switch(e.contents.type){case a.PublicKey:e.pubKeyEncoding==h.Compressed?(n.appendByte(0),n.push(J(e.contents))):(n.appendByte(1),n.push(J(vn(e.contents.data))));break;case a.MessageSignature:e.pubKeyEncoding==h.Compressed?n.appendByte(2):n.appendByte(3),n.push(Ie(e.contents));break}return n.concatBuffer()}function Rn(e){const n=e.readUInt8Enum(un,t=>{throw new k(`Could not read ${t} as AuthFieldType`)});switch(n){case 0:return _(h.Compressed,ie(e));case 1:return _(h.Uncompressed,ie(e));case 2:return _(h.Compressed,le(e));case 3:return _(h.Uncompressed,le(e));default:throw new Error(`Unknown auth field type: ${JSON.stringify(n)}`)}}function W(e,n,t,r){const i=oe(0,e,1,[O(n)]).hash160,s=D(O(n))?h.Compressed:h.Uncompressed;return{hashMode:e,signer:i,nonce:S(t,!1),fee:S(r,!1),keyEncoding:s,signature:Be()}}function ln(e,n,t,r,i){const s=t.map(O),o=oe(0,e,n,s).hash160;return{hashMode:e,signer:o,nonce:S(r,!1),fee:S(i,!1),fields:[],signaturesRequired:n}}function v(e){return"signature"in e}function et(e){const n=z(e);return n.nonce=0,n.fee=0,v(n)?n.signature=Be():n.fields=[],{...n,nonce:BigInt(0),fee:BigInt(0)}}function nt(e){const n=new T;return n.appendByte(e.hashMode),n.appendHexString(e.signer),n.push($(e.nonce,!1,8)),n.push($(e.fee,!1,8)),n.appendByte(e.keyEncoding),n.push(Ie(e.signature)),n.concatBuffer()}function tt(e){const n=new T;n.appendByte(e.hashMode),n.appendHexString(e.signer),n.push($(e.nonce,!1,8)),n.push($(e.fee,!1,8));const t=V(e.fields);n.push(Ae(t));const r=new Uint8Array(2);return mt(r,e.signaturesRequired,0),n.push(r),n.concatBuffer()}function rt(e,n){const t=w(n.readBuffer(20)),r=BigInt("0x"+w(n.readBuffer(8))),i=BigInt("0x"+w(n.readBuffer(8))),s=n.readUInt8Enum(h,c=>{throw new k(`Could not parse ${c} as PubKeyEncoding`)});if(e===p.SerializeP2WPKH&&s!=h.Compressed)throw new k("Failed to parse singlesig spending condition: incomaptible hash mode and key encoding");const o=le(n);return{hashMode:e,signer:t,nonce:r,fee:i,keyEncoding:s,signature:o}}function it(e,n){const t=w(n.readBuffer(20)),r=BigInt("0x"+w(n.readBuffer(8))),i=BigInt("0x"+w(n.readBuffer(8))),s=Ee(n,a.TransactionAuthField).values;let o=!1,c=0;for(const l of s)switch(l.contents.type){case a.PublicKey:D(l.contents)||(o=!0);break;case a.MessageSignature:if(l.pubKeyEncoding===h.Uncompressed&&(o=!0),c+=1,c===65536)throw new TypeError("Failed to parse multisig spending condition: too many signatures");break}const u=n.readUInt16BE();if(c!==u)throw new TypeError("Incorrect number of signatures");if(o&&e===p.SerializeP2SH)throw new TypeError("Uncompressed keys are not allowed in this hash mode");return{hashMode:e,signer:t,nonce:r,fee:i,fields:s,signaturesRequired:u}}function He(e){return v(e)?nt(e):tt(e)}function Ne(e){const n=e.readUInt8Enum(p,t=>{throw new k(`Could not parse ${t} as AddressHashMode`)});return n===p.SerializeP2PKH||n===p.SerializeP2WPKH?rt(n,e):it(n,e)}function dn(e,n,t,r){const i=32+1+8+8,s=[b(e),Uint8Array.from([n]),$(t,!1,8),$(r,!1,8)],o=bn(s);if(o.byteLength!==i)throw Error("Invalid signature hash length");return me(o)}function st(e,n,t){const r=32+1+Se,i=D(n)?h.Compressed:h.Uncompressed,s=e+xn(i.toString(16))+t.data,o=b(s);if(o.byteLength>r)throw Error("Invalid signature hash length");return me(o)}async function ot(e,n,t,r,i){const s=dn(e,n,t,r),o=await Ln(i,s),c=se(i),u=st(s,c,o);return{nextSig:o,nextSigHash:u}}function Ke(e,n,t,r,i,s){const o=dn(e,n,t,r),c=O(Fn(o,s,i)),u=st(o,c,s);return{pubKey:c,nextSigHash:u}}function er(){const e=W(p.SerializeP2PKH,"",0,0);return e.signer=Xn().hash160,e.keyEncoding=h.Compressed,e.signature=Be(),e}function at(e,n,t){return v(e)?nr(e,n,t):tr(e,n,t)}function nr(e,n,t){const{nextSigHash:r,pubKey:i}=Ke(n,t,e.fee,e.nonce,e.keyEncoding,e.signature),s=oe(0,e.hashMode,1,[i]).hash160;if(s!==e.signer)throw new TypeError(`Signer hash does not equal hash of public key(s): ${s} != ${e.signer}`);return r}function tr(e,n,t){const r=[];let i=n,s=!1,o=0;for(const u of e.fields){let l;switch(u.contents.type){case a.PublicKey:D(u.contents)||(s=!0),l=u.contents;break;case a.MessageSignature:u.pubKeyEncoding===h.Uncompressed&&(s=!0);const{pubKey:g,nextSigHash:m}=Ke(i,t,e.fee,e.nonce,u.pubKeyEncoding,u.contents);if(i=m,l=g,o+=1,o===65536)throw new TypeError("Too many signatures");break}r.push(l)}if(o!==e.signaturesRequired)throw new TypeError("Incorrect number of signatures");if(s&&e.hashMode===p.SerializeP2SH)throw new TypeError("Uncompressed keys are not allowed in this hash mode");const c=oe(0,e.hashMode,e.signaturesRequired,r).hash160;if(c!==e.signer)throw new TypeError(`Signer hash does not equal hash of public key(s): ${c} != ${e.signer}`);return i}function Z(e){return{authType:f.Standard,spendingCondition:e}}function Q(e,n){return{authType:f.Sponsored,spendingCondition:e,sponsorSpendingCondition:n||W(p.SerializeP2PKH,"0".repeat(66),0,0)}}function pn(e){if(e.spendingCondition)switch(e.authType){case f.Standard:return Z(et(e.spendingCondition));case f.Sponsored:return Q(et(e.spendingCondition),er());default:throw new I("Unexpected authorization type for signing")}throw new Error("Authorization missing SpendingCondition")}function ct(e,n){switch(e.authType){case f.Standard:return at(e.spendingCondition,n,f.Standard);case f.Sponsored:return at(e.spendingCondition,n,f.Standard);default:throw new I("Invalid origin auth type")}}function ut(e,n){switch(e.authType){case f.Standard:const t={...e.spendingCondition,fee:S(n,!1)};return{...e,spendingCondition:t};case f.Sponsored:const r={...e.sponsorSpendingCondition,fee:S(n,!1)};return{...e,sponsorSpendingCondition:r}}}function rr(e){switch(e.authType){case f.Standard:return e.spendingCondition.fee;case f.Sponsored:return e.sponsorSpendingCondition.fee}}function lt(e,n){const t={...e.spendingCondition,nonce:S(n,!1)};return{...e,spendingCondition:t}}function dt(e,n){const t={...e.sponsorSpendingCondition,nonce:S(n,!1)};return{...e,sponsorSpendingCondition:t}}function pt(e,n){const t={...n,nonce:S(n.nonce,!1),fee:S(n.fee,!1)};return{...e,sponsorSpendingCondition:t}}function ft(e){const n=new T;switch(n.appendByte(e.authType),e.authType){case f.Standard:n.push(He(e.spendingCondition));break;case f.Sponsored:n.push(He(e.spendingCondition)),n.push(He(e.sponsorSpendingCondition));break}return n.concatBuffer()}function ht(e){const n=e.readUInt8Enum(f,r=>{throw new k(`Could not parse ${r} as AuthType`)});let t;switch(n){case f.Standard:return t=Ne(e),Z(t);case f.Sponsored:t=Ne(e);const r=Ne(e);return Q(t,r)}}class $e{constructor(n,t,r,i,s,o,c){if(this.version=n,this.auth=t,"amount"in r?this.payload={...r,amount:S(r.amount,!1)}:this.payload=r,this.chainId=c??Pt,this.postConditionMode=s??x.Deny,this.postConditions=i??V([]),o)this.anchorMode=o;else switch(r.payloadType){case y.Coinbase:case y.PoisonMicroblock:{this.anchorMode=X.OnChainOnly;break}case y.ContractCall:case y.SmartContract:case y.TokenTransfer:{this.anchorMode=X.Any;break}}}signBegin(){const n=z(this);return n.auth=pn(n.auth),n.txid()}verifyBegin(){const n=z(this);return n.auth=pn(n.auth),n.txid()}createTxWithSignature(n){const t=typeof n=="string"?n:w(n),r=z(this);if(!r.auth.spendingCondition)throw new Error("Cannot set signature on transaction without spending condition");return r.auth.spendingCondition.signature=ke(t),r}verifyOrigin(){return ct(this.auth,this.verifyBegin())}async signNextOrigin(n,t){if(this.auth.spendingCondition===void 0)throw new Error('"auth.spendingCondition" is undefined');if(this.auth.authType===void 0)throw new Error('"auth.authType" is undefined');return this.signAndAppend(this.auth.spendingCondition,n,f.Standard,t)}async signNextSponsor(n,t){if(this.auth.authType===f.Sponsored)return await this.signAndAppend(this.auth.sponsorSpendingCondition,n,f.Sponsored,t);throw new Error('"auth.sponsorSpendingCondition" is undefined')}appendPubkey(n){const t=this.auth.spendingCondition;if(t&&!v(t)){const r=D(n);t.fields.push(_(r?h.Compressed:h.Uncompressed,n))}else throw new Error("Can't append public key to a singlesig condition")}async signAndAppend(n,t,r,i){const{nextSig:s,nextSigHash:o}=await ot(t,r,n.fee,n.nonce,i);if(v(n))n.signature=s;else{const c=i.compressed||je(i.data);n.fields.push(_(c?h.Compressed:h.Uncompressed,s))}return o}txid(){const n=this.serialize();return me(n)}setSponsor(n){if(this.auth.authType!=f.Sponsored)throw new I("Cannot sponsor sign a non-sponsored transaction");this.auth=pt(this.auth,n)}setFee(n){this.auth=ut(this.auth,n)}setNonce(n){this.auth=lt(this.auth,n)}setSponsorNonce(n){if(this.auth.authType!=f.Sponsored)throw new I("Cannot sponsor sign a non-sponsored transaction");this.auth=dt(this.auth,n)}serialize(){if(this.version===void 0)throw new R('"version" is undefined');if(this.chainId===void 0)throw new R('"chainId" is undefined');if(this.auth===void 0)throw new R('"auth" is undefined');if(this.anchorMode===void 0)throw new R('"anchorMode" is undefined');if(this.payload===void 0)throw new R('"payload" is undefined');const n=new T;n.appendByte(this.version);const t=new Uint8Array(4);return En(t,this.chainId,0),n.push(t),n.push(ft(this.auth)),n.appendByte(this.anchorMode),n.appendByte(this.postConditionMode),n.push(Ae(this.postConditions)),n.push(Wn(this.payload)),n.concatBuffer()}}function ir(e){let n;typeof e=="string"?e.slice(0,2).toLowerCase()==="0x"?n=new Ve(b(e.slice(2))):n=new Ve(b(e)):e instanceof Uint8Array?n=new Ve(e):n=e;const t=n.readUInt8Enum(E,l=>{throw new Error(`Could not parse ${l} as TransactionVersion`)}),r=n.readUInt32BE(),i=ht(n),s=n.readUInt8Enum(X,l=>{throw new Error(`Could not parse ${l} as AnchorMode`)}),o=n.readUInt8Enum(x,l=>{throw new Error(`Could not parse ${l} as PostConditionMode`)}),c=Ee(n,a.PostCondition),u=qn(n);return new $e(t,i,u,c,o,s,r)}const ze=e=>typeof e=="string",Ue=e=>e.buffer!==void 0,fn=e=>e["string-ascii"]!==void 0,hn=e=>e["string-utf8"]!==void 0,xe=e=>e.response!==void 0,Me=e=>e.optional!==void 0,Fe=e=>e.tuple!==void 0,ve=e=>e.list!==void 0;function gn(e){if(ze(e)){if(e==="uint128")return{id:d.ClarityAbiTypeUInt128,type:e};if(e==="int128")return{id:d.ClarityAbiTypeInt128,type:e};if(e==="bool")return{id:d.ClarityAbiTypeBool,type:e};if(e==="principal")return{id:d.ClarityAbiTypePrincipal,type:e};if(e==="trait_reference")return{id:d.ClarityAbiTypeTraitReference,type:e};if(e==="none")return{id:d.ClarityAbiTypeNone,type:e};throw new Error(`Unexpected Clarity ABI type primitive: ${JSON.stringify(e)}`)}else{if(Ue(e))return{id:d.ClarityAbiTypeBuffer,type:e};if(xe(e))return{id:d.ClarityAbiTypeResponse,type:e};if(Me(e))return{id:d.ClarityAbiTypeOptional,type:e};if(Fe(e))return{id:d.ClarityAbiTypeTuple,type:e};if(ve(e))return{id:d.ClarityAbiTypeList,type:e};if(fn(e))return{id:d.ClarityAbiTypeStringAscii,type:e};if(hn(e))return{id:d.ClarityAbiTypeStringUtf8,type:e};throw new Error(`Unexpected Clarity ABI type: ${JSON.stringify(e)}`)}}function sr(e,n){let t;switch(e.id!==void 0?t=e:t=gn(e),t.id){case d.ClarityAbiTypeUInt128:return Nn(n);case d.ClarityAbiTypeInt128:return Hn(n);case d.ClarityAbiTypeBool:if(n==="false"||n==="0")return Bn();if(n==="true"||n==="1")return In();throw new Error(`Unexpected Clarity bool value: ${JSON.stringify(n)}`);case d.ClarityAbiTypePrincipal:if(n.includes(".")){const[s,o]=n.split(".");return Xe(s,o)}else return kn(n);case d.ClarityAbiTypeTraitReference:const[r,i]=n.split(".");return Xe(r,i);case d.ClarityAbiTypeNone:return Kt();case d.ClarityAbiTypeBuffer:return Nt(De(n));case d.ClarityAbiTypeStringAscii:return Ht(n);case d.ClarityAbiTypeStringUtf8:return It(n);case d.ClarityAbiTypeResponse:throw new fe(`Unsupported encoding for Clarity type: ${t.id}`);case d.ClarityAbiTypeOptional:throw new fe(`Unsupported encoding for Clarity type: ${t.id}`);case d.ClarityAbiTypeTuple:throw new fe(`Unsupported encoding for Clarity type: ${t.id}`);case d.ClarityAbiTypeList:throw new fe(`Unsupported encoding for Clarity type: ${t.id}`);default:throw new Error(`Unexpected Clarity type ID: ${JSON.stringify(t)}`)}}function K(e){if(ze(e))return e==="int128"?"int":e==="uint128"?"uint":e;if(Ue(e))return`(buff ${e.buffer.length})`;if(fn(e))return`(string-ascii ${e["string-ascii"].length})`;if(hn(e))return`(string-utf8 ${e["string-utf8"].length})`;if(xe(e))return`(response ${K(e.response.ok)} ${K(e.response.error)})`;if(Me(e))return`(optional ${K(e.optional)})`;if(Fe(e))return`(tuple ${e.tuple.map(n=>`(${n.name} ${K(n.type)})`).join(" ")})`;if(ve(e))return`(list ${e.list.length} ${K(e.list.type)})`;throw new Error(`Type string unsupported for Clarity type: ${JSON.stringify(e)}`)}function or(e){return`(define-${e.access==="read_only"?"read-only":e.access} (${e.name} ${e.args.map(t=>`(${t.name} ${K(t.type)})`).join(" ")}))`}function j(e,n){const t=gn(n);switch(e.type){case P.BoolTrue:case P.BoolFalse:return t.id===d.ClarityAbiTypeBool;case P.Int:return t.id===d.ClarityAbiTypeInt128;case P.UInt:return t.id===d.ClarityAbiTypeUInt128;case P.Buffer:return t.id===d.ClarityAbiTypeBuffer&&t.type.buffer.length>=e.buffer.length;case P.StringASCII:return t.id===d.ClarityAbiTypeStringAscii&&t.type["string-ascii"].length>=e.data.length;case P.StringUTF8:return t.id===d.ClarityAbiTypeStringUtf8&&t.type["string-utf8"].length>=e.data.length;case P.OptionalNone:return t.id===d.ClarityAbiTypeNone||t.id===d.ClarityAbiTypeOptional;case P.OptionalSome:return t.id===d.ClarityAbiTypeOptional&&j(e.value,t.type.optional);case P.ResponseErr:return t.id===d.ClarityAbiTypeResponse&&j(e.value,t.type.response.error);case P.ResponseOk:return t.id===d.ClarityAbiTypeResponse&&j(e.value,t.type.response.ok);case P.PrincipalContract:return t.id===d.ClarityAbiTypePrincipal||t.id===d.ClarityAbiTypeTraitReference;case P.PrincipalStandard:return t.id===d.ClarityAbiTypePrincipal;case P.List:return t.id==d.ClarityAbiTypeList&&t.type.list.length>=e.list.length&&e.list.every(r=>j(r,t.type.list.type));case P.Tuple:if(t.id==d.ClarityAbiTypeTuple){const r=z(e.data);for(let i=0;i<t.type.tuple.length;i++){const s=t.type.tuple[i],o=s.name,c=r[o];if(c){if(!j(c,s.type))return!1;delete r[o]}else return!1}return!0}else return!1;default:return!1}}function gt(e,n){const t=n.functions.filter(r=>r.name===e.functionName.content);if(t.length===1){const i=t[0].args;if(e.functionArgs.length!==i.length)throw new Error(`Clarity function expects ${i.length} argument(s) but received ${e.functionArgs.length}`);for(let s=0;s<e.functionArgs.length;s++){const o=e.functionArgs[s],c=i[s];if(!j(o,c.type)){const u=s+1;throw new Error(`Clarity function \`${e.functionName.content}\` expects argument ${u} to be of type ${K(c.type)}, not ${$t(o)}`)}}return!0}else throw t.length===0?new Error(`ABI doesn't contain a function with the name ${e.functionName.content}`):new Error(`Malformed ABI. Contains multiple functions with the name ${e.functionName.content}`)}function ar(e,n){const t=K(n);if(ze(n)){if(n==="uint128")return Nn(e);if(n==="int128")return Hn(e);if(n==="bool"){if(e.toLowerCase()==="true")return In();if(e.toLowerCase()==="false")return Bn();throw new Error(`Invalid bool value: ${e}`)}else if(n==="principal")if(e.includes(".")){const[r,i]=e.split(".");return Xe(r,i)}else return kn(e);else throw new Error(`Contract function contains unsupported Clarity ABI type: ${t}`)}else if(Ue(n)){if(De(e).byteLength>n.buffer.length)throw new Error(`Input exceeds specified buffer length limit of ${n.buffer.length}`);return zt(e)}else throw xe(n)?new Error(`Contract function contains unsupported Clarity ABI type: ${t}`):Me(n)?new Error(`Contract function contains unsupported Clarity ABI type: ${t}`):Fe(n)?new Error(`Contract function contains unsupported Clarity ABI type: ${t}`):ve(n)?new Error(`Contract function contains unsupported Clarity ABI type: ${t}`):new Error(`Contract function contains unsupported Clarity ABI type: ${t}`)}class q{constructor(n){this.transaction=n,this.sigHash=n.signBegin(),this.originDone=!1,this.checkOversign=!0,this.checkOverlap=!0;const t=n.auth.spendingCondition;if(t&&!v(t)){if(t.fields.filter(r=>r.contents.type===a.MessageSignature).length>=t.signaturesRequired)throw new Error("SpendingCondition has more signatures than are expected");t.fields.forEach(r=>{if(r.contents.type===a.MessageSignature){const i=r.contents,s=Ke(this.sigHash,n.auth.authType,t.fee,t.nonce,h.Compressed,i);this.sigHash=s.nextSigHash}})}}static createSponsorSigner(n,t){if(n.auth.authType!=f.Sponsored)throw new I("Cannot add sponsor to non-sponsored transaction");const r=z(n);r.setSponsor(t);const i=r.verifyOrigin(),s=new this(r);return s.originDone=!0,s.sigHash=i,s.checkOversign=!0,s.checkOverlap=!0,s}async signOrigin(n){if(this.checkOverlap&&this.originDone)throw new I("Cannot sign origin after sponsor key");if(this.transaction.auth===void 0)throw new I('"transaction.auth" is undefined');if(this.transaction.auth.spendingCondition===void 0)throw new I('"transaction.auth.spendingCondition" is undefined');if(!v(this.transaction.auth.spendingCondition)){const t=this.transaction.auth.spendingCondition;if(this.checkOversign&&t.fields.filter(r=>r.contents.type===a.MessageSignature).length>=t.signaturesRequired)throw new Error("Origin would have too many signatures")}this.sigHash=await this.transaction.signNextOrigin(this.sigHash,n)}appendOrigin(n){if(this.checkOverlap&&this.originDone)throw Error("Cannot append public key to origin after sponsor key");if(this.transaction.auth===void 0)throw new Error('"transaction.auth" is undefined');if(this.transaction.auth.spendingCondition===void 0)throw new Error('"transaction.auth.spendingCondition" is undefined');this.transaction.appendPubkey(n)}async signSponsor(n){if(this.transaction.auth===void 0)throw new I('"transaction.auth" is undefined');if(this.transaction.auth.authType!==f.Sponsored)throw new I('"transaction.auth.authType" is not AuthType.Sponsored');this.sigHash=await this.transaction.signNextSponsor(this.sigHash,n),this.originDone=!0}getTxInComplete(){return z(this.transaction)}resume(n){this.transaction=z(n),this.sigHash=n.signBegin()}}async function de(e,n){const t=new U,r=n?n.getAccountApiUrl(e):t.getAccountApiUrl(e),i=await G(r);if(!i.ok){let c="";try{c=await i.text()}catch{}throw new Error(`Error fetching nonce. Response ${i.status}: ${i.statusText}. Attempted to fetch ${r} and failed with the message: "${c}"`)}const s=await i.text(),o=JSON.parse(s);return BigInt(o.nonce)}async function yn(e,n){if(e.payload.payloadType!==y.TokenTransfer)throw new Error(`Transaction fee estimation only possible with ${y[y.TokenTransfer]} transactions. Invoked with: ${y[e.payload.payloadType]}`);const r={method:"GET",headers:{Accept:"application/text"}},i=new U,s=n?n.getTransferFeeEstimateApiUrl():i.getTransferFeeEstimateApiUrl(),o=await G(s,r);if(!o.ok){let g="";try{g=await o.text()}catch{}throw new Error(`Error estimating transaction fee. Response ${o.status}: ${o.statusText}. Attempted to fetch ${s} and failed with the message: "${g}"`)}const c=await o.text(),u=BigInt(e.serialize().byteLength);return BigInt(c)*u}async function wn(e,n){if(e.payload.payloadType!==y.ContractCall)throw new Error(`Contract call fee estimation only possible with ${y[y.ContractCall]} transactions. Invoked with: ${y[e.payload.payloadType]}`);const r={method:"GET",headers:{Accept:"application/text"}},i=new U,s=n?n.getTransferFeeEstimateApiUrl():i.getTransferFeeEstimateApiUrl(),o=await G(s,r);if(!o.ok){let g="";try{g=await o.text()}catch{}throw new Error(`Error estimating contract call fee. Response ${o.status}: ${o.statusText}. Attempted to fetch ${s} and failed with the message: "${g}"`)}const c=await o.text(),u=S(e.serialize().byteLength,!1);return S(c,!1)*u}async function Sn(e,n){if(e.payload.payloadType!==y.SmartContract)throw new Error(`Contract deploy fee estimation only possible with ${y[y.SmartContract]} transactions. Invoked with: ${y[e.payload.payloadType]}`);const r={method:"GET",headers:{Accept:"application/text"}},i=new U,s=n?n.getTransferFeeEstimateApiUrl():i.getTransferFeeEstimateApiUrl(),o=await G(s,r);if(!o.ok){let g="";try{g=await o.text()}catch{}throw new Error(`Error estimating contract deploy fee. Response ${o.status}: ${o.statusText}. Attempted to fetch ${s} and failed with the message: "${g}"`)}const c=await o.text(),u=S(e.serialize().byteLength,!1);return S(c,!1)*u}async function cr(e){const n={fee:0,sponsorNonce:0,sponsorAddressHashmode:p.SerializeP2PKH},t=Object.assign(n,e),r=e.network??(t.transaction.version===E.Mainnet?new U:new Dt),i=re(t.sponsorPrivateKey);if(e.fee===void 0||e.fee===null){let u=BigInt(0);switch(t.transaction.payload.payloadType){case y.TokenTransfer:u=await yn(t.transaction,r);break;case y.SmartContract:u=await Sn(t.transaction,r);break;case y.ContractCall:u=await wn(t.transaction,r);break;default:throw new Error(`Sponsored transactions not supported for transaction type ${y[t.transaction.payload.payloadType]}`)}t.transaction.setFee(u),t.fee=u}if(e.sponsorNonce===void 0||e.sponsorNonce===null){const u=r.version===E.Mainnet?A.mainnetP2PKH:A.testnetP2PKH,l=zn(M(i),u),g=await de(l,r);t.sponsorNonce=g}const s=W(t.sponsorAddressHashmode,M(i),t.sponsorNonce,t.fee);t.transaction.setSponsor(s);const o=N(t.sponsorPrivateKey),c=q.createSponsorSigner(t.transaction,s);return await c.signSponsor(o),c.transaction}function ur(e,n,t){return Re(ae(e),n,t)}function lr(e,n,t,r){return Re(ce(e,n),t,r)}function dr(e,n,t,r){return en(ae(e),n,t,r)}function pr(e,n,t,r,i){return en(ce(e,n),t,r,i)}function fr(e,n,t,r){return nn(ae(e),n,t,r)}function hr(e,n,t,r,i){return nn(ce(e,n),t,r,i)}async function yt(e,n,t){const r={method:"GET"},i=t.getAbiApiUrl(e,n),s=await G(i,r);if(!s.ok){let o="";try{o=await s.text()}catch{}throw new Error(`Error fetching contract ABI for contract "${n}" at address ${e}. Response ${s.status}: ${s.statusText}. Attempted to fetch ${i} and failed with the message: "${o}"`)}return JSON.parse(await s.text())}async function Cn(e){const n={fee:BigInt(0),nonce:BigInt(0),network:new U,postConditionMode:x.Deny,sponsored:!1},t=Object.assign(n,e),r=Vn(t.contractAddress,t.contractName,t.functionName,t.functionArgs);if(t?.validateWithAbi){let l;if(typeof t.validateWithAbi=="boolean")if(t?.network)l=await yt(t.contractAddress,t.contractName,t.network);else throw new Error("Network option must be provided in order to validate with ABI");else l=t.validateWithAbi;gt(r,l)}let i=null,s=null;"publicKey"in t?i=W(p.SerializeP2PKH,t.publicKey,t.nonce,t.fee):i=ln(p.SerializeP2SH,t.numSignatures,t.publicKeys,t.nonce,t.fee),t.sponsored?s=Q(i):s=Z(i);const o=[];t.postConditions&&t.postConditions.length>0&&t.postConditions.forEach(l=>{o.push(l)});const c=V(o),u=new $e(t.network.version,s,r,c,t.postConditionMode,t.anchorMode,t.network.chainId);if(e.fee===void 0||e.fee===null){const l=await wn(u,t.network);u.setFee(l)}if(e.nonce===void 0||e.nonce===null){const l=t.network.version===E.Mainnet?A.mainnetP2PKH:A.testnetP2PKH,g=Un(l,b(u.auth.spendingCondition.signer)),m=await de(g,t.network);u.setNonce(m)}return u}async function gr(e){if("senderKey"in e){const n=N(e.senderKey),t=M(se(n)),r=he(e,"senderKey"),i=await Cn({publicKey:t,...r});return await new q(i).signOrigin(n),i}else{const n=he(e,"signerKeys"),t=await Cn(n),r=new q(t);let i=e.publicKeys;for(const s of e.signerKeys){const o=re(s);i=i.filter(c=>c!==w(o.data)),await r.signOrigin(N(s))}for(const s of i)r.appendOrigin(Pe(b(s)));return t}}async function yr(e){const n={fee:BigInt(0),nonce:BigInt(0),network:new U,postConditionMode:x.Deny,sponsored:!1},t=Object.assign(n,e),r=_n(t.contractName,t.codeBody),i=p.SerializeP2PKH,s=N(t.senderKey),o=se(s);let c=null;const u=W(i,M(o),t.nonce,t.fee);t.sponsored?c=Q(u):c=Z(u);const l=[];t.postConditions&&t.postConditions.length>0&&t.postConditions.forEach(B=>{l.push(B)});const g=V(l),m=new $e(t.network.version,c,r,g,t.postConditionMode,t.anchorMode,t.network.chainId);if(e.fee===void 0||e.fee===null){const B=await Sn(m,t.network);m.setFee(B)}if(e.nonce===void 0||e.nonce===null){const B=t.network.version===E.Mainnet?A.mainnetP2PKH:A.testnetP2PKH,pe=zn(M(o),B),Le=await de(pe,t.network);m.setNonce(Le)}return t.senderKey&&await new q(m).signOrigin(s),m}async function mn(e,n){const t={fee:BigInt(0),nonce:BigInt(0),network:new U,postConditionMode:x.Deny,memo:"",sponsored:!1},r=Object.assign(t,e),i=Dn(r.recipient,r.amount,r.memo);let s=null,o=null;"publicKey"in r?o=W(p.SerializeP2PKH,r.publicKey,r.nonce,r.fee):o=ln(p.SerializeP2SH,r.numSignatures,r.publicKeys,r.nonce,r.fee),r.sponsored?s=Q(o):s=Z(o);const c=[];r.postConditions&&r.postConditions.length>0&&r.postConditions.forEach(g=>{c.push(g)});const u=V(c),l=new $e(r.network.version,s,i,u,r.postConditionMode,r.anchorMode,r.network.chainId);if(n)l.setFee(0),l.setNonce(0);else{if(e.fee===void 0||e.fee===null){const g=await yn(l,r.network);l.setFee(g)}if(e.nonce===void 0||e.nonce===null){const g=r.network.version===E.Mainnet?A.mainnetP2PKH:A.testnetP2PKH,m=Un(g,b(l.auth.spendingCondition.signer)),B=await de(m,r.network);l.setNonce(B)}}return l}async function wr(e){if("senderKey"in e){const n=N(e.senderKey),t=M(se(n)),r=he(e,"senderKey"),i=await mn({publicKey:t,...r});return await new q(i).signOrigin(n),i}else{const n=he(e,"signerKeys"),t=await mn(n),r=new q(t);let i=e.publicKeys;for(const s of e.signerKeys){const o=re(s);i=i.filter(c=>c!==w(o.data)),await r.signOrigin(N(s))}for(const s of i)r.appendOrigin(Pe(b(s)));return t}}function wt(e){return e.startsWith("0x")?e:`0x${e}`}const Sr=e=>{if(e==="success")return!0;const n=wt(e).toLowerCase();return n.length!==66?!1:wt(BigInt(n).toString(16).padStart(64,"0"))===n};async function Cr(e,n,t){return St(e.serialize(),n.getBroadcastApiUrl(),t)}async function St(e,n,t){const r={method:"POST",headers:{"Content-Type":t?"application/json":"application/octet-stream"},body:t?JSON.stringify({tx:w(e),attachment:w(t)}):e},i=await G(n,r);if(!i.ok)try{return await i.json()}catch(c){throw Error(`Failed to broadcast transaction: ${c.message}`)}const s=await i.text(),o=s.replace(/["]+/g,"");if(Sr(o))return{txid:o};throw new Error(s)}export{p as AddressHashMode,Je as AddressVersion,X as AnchorMode,Ye as AssetType,f as AuthType,Vt as CLARITY_INT_BYTE_SIZE,_t as DEFAULT_CORE_NODE_API_URL,Wt as DEFAULT_TRANSACTION_VERSION,Rt as Deserializable,te as FungibleConditionCode,Ce as NonFungibleConditionCode,x as PostConditionMode,C as PostConditionType,h as PubKeyEncoding,q as TransactionSigner,Ze as TxRejectedReason,or as abiFunctionToString,jt as addressFromHashMode,oe as addressFromPublicKeys,Y as addressFromVersionHash,Jn as addressHashModeToVersion,St as broadcastRawTransaction,Cr as broadcastTransaction,Yn as codeBodyString,vn as compressPublicKey,Qn as createAssetInfo,ce as createContractPrincipal,Xn as createEmptyAddress,en as createFungiblePostCondition,V as createLPList,on as createMemoString,ke as createMessageSignature,ln as createMultiSigSpendingCondition,nn as createNonFungiblePostCondition,Re as createSTXPostCondition,W as createSingleSigSpendingCondition,Q as createSponsoredAuth,N as createStacksPrivateKey,O as createStacksPublicKey,Z as createStandardAuth,ae as createStandardPrincipal,_ as createTransactionAuthField,ue as deserializeAssetInfo,ht as deserializeAuthorization,Ee as deserializeLPList,Te as deserializeMemoString,le as deserializeMessageSignature,it as deserializeMultiSigSpendingCondition,tn as deserializePostCondition,sn as deserializePrincipal,ie as deserializePublicKey,rt as deserializeSingleSigSpendingCondition,Ne as deserializeSpendingCondition,Qt as deserializeStacksMessage,ir as deserializeTransaction,Rn as deserializeTransactionAuthField,Be as emptyMessageSignature,sr as encodeClarityValue,Sn as estimateContractDeploy,wn as estimateContractFunctionCall,yn as estimateTransfer,yt as getAbi,rr as getFee,de as getNonce,se as getPublicKeyFromStacksPrivateKey,Xt as getSignatureRecoveryParam,K as getTypeString,gn as getTypeUnion,pn as intoInitialSighashAuth,Ue as isClarityAbiBuffer,ve as isClarityAbiList,Me as isClarityAbiOptional,ze as isClarityAbiPrimitive,xe as isClarityAbiResponse,fn as isClarityAbiStringAscii,hn as isClarityAbiStringUtf8,Fe as isClarityAbiTuple,D as isCompressed,je as isPrivateKeyCompressed,v as isSingleSig,xn as leftPadHex,Qe as leftPadHexToLength,gr as makeContractCall,yr as makeContractDeploy,pr as makeContractFungiblePostCondition,hr as makeContractNonFungiblePostCondition,lr as makeContractSTXPostCondition,Gt as makeRandomPrivKey,wr as makeSTXTokenTransfer,dn as makeSigHashPreSign,dr as makeStandardFungiblePostCondition,fr as makeStandardNonFungiblePostCondition,ur as makeStandardSTXPostCondition,Cn as makeUnsignedContractCall,mn as makeUnsignedSTXTokenTransfer,ot as nextSignature,Ke as nextVerification,an as parseAssetInfoString,be as parsePrincipalString,qt as parseReadOnlyResponse,On as parseRecoverableSignature,ar as parseToCV,Jt as privateKeyToString,re as pubKeyfromPrivKey,Pe as publicKeyFromBuffer,Fn as publicKeyFromSignature,M as publicKeyToString,Mn as rightPadHexToLength,cn as serializeAssetInfo,ft as serializeAuthorization,Ae as serializeLPList,Zn as serializeMemoString,Ie as serializeMessageSignature,tt as serializeMultiSigSpendingCondition,Gn as serializePostCondition,rn as serializePrincipal,J as serializePublicKey,nt as serializeSingleSigSpendingCondition,He as serializeSpendingCondition,F as serializeStacksMessage,jn as serializeTransactionAuthField,ut as setFee,lt as setNonce,pt as setSponsor,dt as setSponsorNonce,Ln as signWithKey,cr as sponsorTransaction,me as txidFromData,gt as validateContractCall,ct as verifyOrigin};
