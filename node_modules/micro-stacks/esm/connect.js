import{getGlobalObject as p,bytesToHex as a,cleanHex as D,hexToJSON as E}from"micro-stacks/common";import{TokenSigner as m,getPublicKey as c,decodeToken as _,decryptECIES as R,getRandomBytes as I}from"micro-stacks/crypto";import{cvToHex as x}from"micro-stacks/clarity";import{serializePostCondition as A}from"micro-stacks/transactions";const u=typeof document!="undefined";var l;(function(t){t.SessionStorageKey="stacks-session",t.NetworkStorageKey="stacks-network"})(l||(l={}));const d=p("localStorage",{returnEmptyObject:!0}),g={setItem:(t,e)=>{if(u)return d?.setItem(t,e)},getItem:t=>{if(u){const e=d?.getItem(t);if(e===null)throw new Error("defaultStorageAdapter: no value stored");return e}},removeItem:t=>{if(u)return d?.removeItem(t)}};function q(t){return t?.map(e=>typeof e!="string"?a(A(e)):e)}const y=async(t,e)=>new m("ES256k",e).sign({...t,postConditions:q(t.postConditions)});var i;(function(t){t.ContractCall="contract_call",t.ContractDeploy="smart_contract",t.STXTransfer="token_transfer"})(i||(i={}));async function K({functionArgs:t,privateKey:e,...n}){const r=a(c(e,!0)),o={...n,functionArgs:t.map(s=>D(typeof s=="string"?s:x(s))),txType:i.ContractCall,publicKey:r};return y(o,e)}async function O({privateKey:t,...e}){const n={...e,publicKey:a(c(t,!0)),txType:i.ContractDeploy};return y(n,t)}async function j({privateKey:t,...e}){const n={...e,amount:typeof e.amount=="bigint"?Number(e.amount).toString(10):e.amount,publicKey:a(c(t,!0)),txType:i.STXTransfer};return y(n,t)}function h(t){const e=t.split(":");if(e.length!==3)throw new TypeError("Decentralized IDs must have 3 parts");if(e[0].toLowerCase()!=="did")throw new TypeError('Decentralized IDs must start with "did"');return e[1].toLowerCase()}function k(t){return t&&h(t)==="btc-addr"?t.split(":")[2]:void 0}async function S(t,e){const o=_(t)?.payload,{private_key:s}=o,P=E(s),C=await R({privateKey:e,cipherObject:P});return{addresses:o.profile.stxAddress,appPrivateKey:C,associationToken:o.associationToken,hubUrl:o.hubUrl,public_keys:o.public_keys,profile:o.profile,profile_url:o.profile_url,username:o.username,version:o.version,decentralizedID:o.iss,identityAddress:k(o.iss)}}function f(){return p("StacksProvider",{returnEmptyObject:!1,usageDesc:"authenticate",throwIfUnavailable:!0})}async function F(t,e=g,n=JSON.stringify){if(!t.appDetails)throw Error("[micro-stacks] authenticate error: `authOptions.appDetails` are required for authentication");try{const r=a(I()),o=await v(t,r),s=await S(o,r);return t?.onFinish?.(s),e.setItem(l.SessionStorageKey,n(s)),s}catch(r){t?.onCancel?.(r.message)}}function w(t,e){if(!t.appDetails)throw Error("[micro-stacks] authenticate error: `authOptions.appDetails` are required for authentication");const n=t.scopes||[],r=p("location",{returnEmptyObject:!0}).origin;return{scopes:[...new Set(["store_write",...n])],redirect_uri:r,public_keys:[e],domain_name:r,appDetails:t.appDetails}}async function T(t,e){return new m("ES256k",e).sign(t)}async function b(t,e){const n=a(c(e)),r=w(t,n);return T(r,e)}async function v(t,e){const n=f();if(!n)throw Error("This function can only be called on the client, and with the presence of StacksProvider");const r=await b(t,e);return n.authenticationRequest(r)}async function U(t){const{token:e,onFinish:n,onCancel:r}=t;try{const s=await f().transactionRequest(e);n?.(s)}catch(o){console.error(o),r?.(o?.message)}}async function N(t){const{token:e,onFinish:n,onCancel:r}=t;try{const o=f();o||console.error("no stacks provider");const s=await o.profileUpdateRequest(e);n?.(s)}catch(o){console.error(o),r?.(o?.message)}}export{u as IS_BROWSER,l as PersistedDataKeys,i as TransactionTypes,F as authenticate,S as decodeAuthResponse,g as defaultStorageAdapter,w as generateAuthRequestPayload,b as generateSignedAuthRequest,k as getAddressFromDID,h as getDIDType,v as handleAuthResponse,K as makeContractCallToken,O as makeContractDeployToken,j as makeStxTransferToken,N as openProfileUpdatePopup,U as openTransactionPopup,T as signAuthRequest};
