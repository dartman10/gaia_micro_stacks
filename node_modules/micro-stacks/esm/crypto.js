import{ripemd160 as q}from"@noble/hashes/ripemd160";import{ensureUint8Array as He,bytesToHex as d,bytesToBigInt as J,intToBytes as Be,encodeB58 as ve,decodeB58 as Ce,concatByteArrays as B,hexToBytes as P,ensureHexBytes as Z,BufferArray as v,arrayBufferToUint8 as z,utf8ToBytes as S,bytesToBase64 as T,base64ToBytes as w,copy as C,MissingParametersError as Le}from"micro-stacks/common";import{hashSha512 as Ae,hashSha256 as u}from"micro-stacks/crypto-sha";import{utils as F,Point as Q,CURVE as L,getPublicKey as b,sign as X,verify as _,getSharedSecret as Y}from"@noble/secp256k1";export{getPublicKey}from"@noble/secp256k1";import{aes256CbcEncrypt as Oe,aes256CbcDecrypt as Ie}from"micro-stacks/crypto-aes";import{hmacSha256 as ee}from"micro-stacks/crypto-hmac-sha";function te(e){return(Math.floor(e/16)+1)*16}function ne(e){return Math.ceil(e/3)*4}function re(e){const t={iv:"",ephemeralPK:"",mac:"",cipherText:"",wasString:!!e.wasString};e.cipherTextEncoding==="base64"&&(t.cipherTextEncoding="base64");const n=32,r=66,s=64;return{payloadValuesLength:n+r+s,payloadShell:JSON.stringify(t)}}function se(e){const t={signature:"",publicKey:"",cipherText:e};return{signedPayloadValuesLength:144+66,signedPayloadShell:JSON.stringify(t)}}function ke(e){const{payloadShell:t,payloadValuesLength:n}=re(e),r=te(e.contentLength);let s;if(!e.cipherTextEncoding||e.cipherTextEncoding==="hex")s=r*2;else if(e.cipherTextEncoding==="base64")s=ne(r);else throw new Error(`Unexpected cipherTextEncoding "${e.cipherTextEncoding}"`);if(e.sign){const{signedPayloadShell:c,signedPayloadValuesLength:i}=se(t);return c.length+i+n+s}else return t.length+n+s}function ce(e){return typeof e=="string"?q(e):q.create().update(He(e)).digest()}class oe{digest(t){return ce(t)}}function ie(){return new oe}function A(e){return ie().digest(e)}function N(e){const t=Ae(e);return{encryptionKey:t.slice(0,32),hmacKey:t.slice(32)}}function ae(e=32){return F.randomBytes(e)}const he=e=>{const t=e[0];return e.length===32||e.length===33&&(t===2||t===3)},De=(e,t)=>{const n=Q.fromHex(d(e));return new Q(L.Gx,L.Gy).multiply(J(t)).add(n).toRawBytes(he(e))};function Je(e,t=L.P){const n=e%t;return n>=0?n:t+n}const _e=(e,t)=>Be(Je(J(t)+J(e),L.n),!1,32);function O(e,t){const n=new Uint8Array([t]),r=new Uint8Array(25),s=new Uint8Array(21);s[0]=t,s.set(e,1);const c=u(s),o=u(c).slice(0,4);return r.set(n,0),r.set(e,1),r.set(o,e.length+1),ve(r)}function fe(e){const t=Ce(e),n=t.slice(-4),r=u(t.slice(0,-4)),s=u(r);for(let o=0;o<4;o++)if(s[o]!==n[o])throw new Error("base58 address has invalid checksum");const c=t[0];return{hash:t.slice(1,-4),version:c}}var p;(function(e){e[e.mainnetP2PKH=0]="mainnetP2PKH",e[e.mainnetP2SH=5]="mainnetP2SH",e[e.testnetP2PKH=111]="testnetP2PKH",e[e.testnetP2SH=196]="testnetP2SH"})(p||(p={}));const Ne={messagePrefix:`Bitcoin Signed Message:
`,bech32:"bc",bip32:{public:76067358,private:76066276},pubKeyHash:0,scriptHash:5,wif:128},Ue={messagePrefix:`Bitcoin Signed Message:
`,bech32:"tb",bip32:{public:70617039,private:70615956},pubKeyHash:111,scriptHash:196,wif:239},de={bitcoin:Ne,testnet:Ue};var K;(function(e){e[e.mainnetP2PKH=22]="mainnetP2PKH",e[e.mainnetP2SH=20]="mainnetP2SH",e[e.testnetP2PKH=26]="testnetP2PKH",e[e.testnetP2SH=21]="testnetP2SH"})(K||(K={}));const U={[p.mainnetP2PKH]:22,[p.mainnetP2SH]:20,[p.testnetP2PKH]:26,[p.testnetP2SH]:21},j={[22]:p.mainnetP2PKH,[20]:p.mainnetP2SH,[26]:p.testnetP2PKH,[21]:p.testnetP2SH},x="0123456789ABCDEFGHJKMNPQRSTVWXYZ",R=new Map;[...x].forEach((e,t)=>R.set(e,t));const I="0123456789abcdef",M=new Map;[...I].forEach((e,t)=>M.set(e,t));function W(e,t){const n=ue(e,t),r=Me(B([t,n]));return`S${x[e]}${r}`}function je(e){const t=fe(e),n=t.hash,r=t.version;let s=r;return U[r]!==void 0&&(s=U[r]),W(s,n)}function Re(e){const t=$(e),n=t[0],r=t[1];let s=n;return j[n]!==void 0&&(s=j[n]),O(r,s)}function Me(e){const t=d(e);let n=[],r=0;for(let o=t.length-1;o>=0;o--)if(r<4){const h=M.get(t[o])>>r;let a=0;o!==0&&(a=M.get(t[o-1]));const f=1+r,l=a%(1<<f)<<5-f,m=x[h+l];r=f,n.unshift(m)}else r=0;let s=0;for(let o=0;o<n.length&&n[o]==="0";o++)s++;n=n.slice(s);const c=/^\u0000*/.exec(new TextDecoder().decode(e)),i=c?c[0].length:0;for(let o=0;o<i;o++)n.unshift(x[0]);return n.join("")}function ue(e,t){const n=u(B([Uint8Array.of(e),t]));return u(n).slice(0,4)}function $(e){if(e.length<=5)throw new Error("Invalid c32 address: invalid length");if(e[0]!=="S")throw new Error('Invalid c32 address: must start with "S"');return le(e.slice(1))}function le(e){e=V(e);const t=pe(e.slice(1)),n=e[0],r=R.get(n),s=t.slice(-4),c=ue(r,t.slice(0,-4));for(let i=0;i<s.length;i++)if(s[i]!==c[i])throw new Error("Invalid c32check string: checksum mismatch");return[r,t.slice(0,-4)]}function V(e){return e.toUpperCase().replace(/O/g,"0").replace(/L|I/g,"1")}function pe(e){if(e=V(e),!RegExp(`^[${x}]*$`).exec(e))throw new Error("Not a c32-encoded string");const t=RegExp(`^${x[0]}*`).exec(e),n=t?t[0].length:0;let r=[],s=0,c=0;for(let h=e.length-1;h>=0;h--){c===4&&(r.unshift(I[s]),c=0,s=0);const f=(R.get(e[h])<<c)+s,l=I[f%16];if(c+=1,s=f>>4,s>1<<c)throw new Error("Panic error in decoding.");r.unshift(l)}r.unshift(I[s]),r.length%2==1&&r.unshift("0");let i=0;for(let h=0;h<r.length&&r[h]==="0";h++)i++;r=r.slice(i-i%2);let o=r.join("");for(let h=0;h<n;h++)o=`00${o}`;return P(o)}function We(e){try{return $(e),!0}catch{return!1}}function $e(e,t=K.mainnetP2PKH,n){return ge(d(b(Z(e),n)),t)}function ge(e,t=K.mainnetP2PKH){return W(t,E(Z(e)))}function Ve(e){const t=b(e,!0),n=u(t),r=A(n);return O(r,de.bitcoin.pubKeyHash)}function Ge(e){const t=typeof e=="string"?e:d(e),n=u(P(t)),r=A(n);return O(r,de.bitcoin.pubKeyHash)}function E(e){const t=u(e);return A(t)}const qe=e=>d(E(e)),Ze=e=>{const t=E(e),n=new v;n.appendByte(0),n.appendByte(t.length),n.push(t);const r=n.concatBuffer(),s=E(r);return d(s)},ze=(e,t)=>{if(e>15||t.length>15)throw Error("P2WSH multisig address can only contain up to 15 public keys");const n=new v;n.appendByte(80+e),t.forEach(h=>{n.appendByte(h.length),n.push(h)}),n.appendByte(80+t.length),n.appendByte(174);const r=n.concatBuffer(),s=u(r),c=new v;c.appendByte(0),c.appendByte(s.length),c.push(s);const i=c.concatBuffer(),o=E(i);return d(o)},Fe=(e,t)=>{if(e>15||t.length>15)throw Error("P2SH multisig address can only contain up to 15 public keys");const n=new v;n.appendByte(80+e),t.forEach(c=>{n.appendByte(c.length),n.push(c)}),n.appendByte(80+t.length),n.appendByte(174);const r=n.concatBuffer(),s=E(r);return d(s)};async function ye(e){const{contents:t,privateKey:n}=e,r=t instanceof ArrayBuffer?z(t):typeof t=="string"?S(t):t,s=d(b(n,!0)),c=u(r),i=await X(c,n,{canonical:!1});return{signature:d(i),publicKey:s}}function Qe(e,t=!1){const{contents:n,publicKey:r,signature:s}=e,c=n instanceof ArrayBuffer?z(n):typeof n=="string"?S(n):n,i=u(c);return _(s,i,r,{strict:t})}async function me(e){const{publicKey:t,content:n,cipherTextEncoding:r="hex",wasString:s}=e,c=F.randomPrivateKey(),i=b(c,!0);let o=Y(c,t,!0);o=o.slice(1);const h=N(o),a=ae(16),f=await Oe(a,h.encryptionKey,n),l=B([a,i,f]),m=ee(h.hmacKey,l);let g;if(!r||r==="hex")g=d(f);else if(r==="base64")g=T(f);else throw new Error(`Unexpected cipherTextEncoding "${r}"`);const H={iv:d(a),ephemeralPK:d(i),cipherText:g,mac:d(m),wasString:s};return r&&r!=="hex"&&(H.cipherTextEncoding=r),H}function Pe(e,t){if(e.length!==t.length)return!1;let n=0;for(let r=0;r<e.length;r++)n|=e[r]^t[r];return n===0}async function Se(e){const{privateKey:t,cipherObject:n}=e;if(!n.ephemeralPK)throw Error("No ephemeralPK found in cipher object");const r=n.ephemeralPK;let s=Y(t,r,!0);s=s.slice(1);const c=N(s),i=P(n.iv);let o;if(!n.cipherTextEncoding||n.cipherTextEncoding==="hex")o=P(n.cipherText);else if(n.cipherTextEncoding==="base64")o=w(n.cipherText);else throw new Error(`Unexpected cipherTextEncoding "${n.cipherText}"`);const h=B([i,P(r),o]),a=ee(c.hmacKey,h),f=P(n.mac);if(!Pe(f,a))throw new Error("Decryption failed: failure in MAC check");const l=await Ie(i,c.encryptionKey,o);return n.wasString?new TextDecoder().decode(l):l}function Xe(e,t){if(!t.privateKey)throw new Error("Private key is required for decryption.");try{const n=JSON.parse(e);return Se({privateKey:t.privateKey,cipherObject:n})}catch(n){throw n instanceof SyntaxError?new Error("Failed to parse encrypted content JSON. The content may not be encrypted. If using getFile, try passing { decrypt: false }."):n}}async function Ye(e,t){let{publicKey:n,privateKey:r,wasString:s}=t;const{cipherTextEncoding:c,sign:i}=t;if(!r&&!n)throw new Error("Either public key or private key must be supplied for encryption.");if(!n&&r&&(n=d(b(r,!0))),typeof s!="boolean"&&(s=typeof e=="string"),!n)throw new Error("micro-stacks/crypto - no public key found to encrypt content");const o=typeof e=="string"?S(e):e,h=await me({publicKey:n,content:o,wasString:s,cipherTextEncoding:c});if(!i)return JSON.stringify(h);if(typeof i=="string"&&(r=i),!r)throw new Error("micro-stacks/crypto - need private key to sign contents");const a=await ye({contents:JSON.stringify(h),privateKey:r});return JSON.stringify({...a,cipherText:JSON.stringify(h)})}function et(e){const t=4,n=e.length,r=n%t;if(!r)return e;const s=t-r,c=n+s;return e.padEnd(c,"=")}function tt(e){return e instanceof Uint8Array?xe(T(e)):xe(T(new TextEncoder().encode(e)))}function nt(e){const t=w(rt(e));return new TextDecoder().decode(t)}function rt(e){let t;return e instanceof Uint8Array?t=new TextDecoder().decode(e):t=e,et(t).replace(/\-/g,"+").replace(/_/g,"/")}function xe(e){return e.replace(/=/g,"").replace(/\+/g,"-").replace(/\//g,"_")}var y={encode:tt,decode:nt};const k=128,Ee=0,st=32,ct=16,ot=2,Te=ct|st|Ee<<6,D=ot|Ee<<6;function we(e){return typeof e=="string"?w(e):e}function it(e){const t=we(e),n=32,r=n+1,s=t.length;let c=0;if(t[c++]!==Te)throw new Error('Could not find expected "seq"');let i=t[c++];if(i===(k|1)&&(i=t[c++]),s-c<i)throw new Error('"seq" specified length of "'+i+'", only "'+(s-c)+'" remaining');if(t[c++]!==D)throw new Error('Could not find expected "int" for "r"');const o=t[c++];if(s-c-2<o)throw new Error('"r" specified length of "'+o+'", only "'+(s-c-2)+'" available');if(r<o)throw new Error('"r" specified length of "'+o+'", max of "'+r+'" is acceptable');const h=c;if(c+=o,t[c++]!==D)throw new Error('Could not find expected "int" for "s"');const a=t[c++];if(s-c!==a)throw new Error('"s" specified length of "'+a+'", expected "'+(s-c)+'"');if(r<a)throw new Error('"s" specified length of "'+a+'", max of "'+r+'" is acceptable');const f=c;if(c+=a,c!==s)throw new Error('Expected to consume entire buffer, but "'+(s-c)+'" bytes remain');const l=n-o,m=n-a,g=new Uint8Array(l+o+m+a);for(c=0;c<l;++c)g[c]=0;g.set(t.slice(h+Math.max(-l,0),h+o),c),c=n;for(let H=c;c<H+m;++c)g[c]=0;return g.set(t.slice(f+Math.max(-m,0),f+a),c),T(g).replace(/=/g,"")}function be(e,t,n){let r=0;for(;t+r<n&&e[t+r]===0;)++r;return e[t+r]>=k&&--r,r}function Ke(e){const t=we(e),n=32,r=be(t,0,n),s=be(t,n,t.length),c=n-r,i=n-s,o=1+1+c+1+1+i,h=o<k,a=new Uint8Array((h?2:3)+o);let f=0;return a[f++]=Te,h?a[f++]=o:(a[f++]=k|1,a[f++]=o&255),a[f++]=D,a[f++]=c,r<0?(a[f++]=0,f+=C(t,a,f,0,n)):f+=C(t,a,f,r,n),a[f++]=D,a[f++]=i,s<0?(a[f++]=0,C(t,a,f,n)):C(t,a,f,n+s),T(a).replace(/=/g,"")}function G(e,t){const n=[],r=y.encode(JSON.stringify(t));n.push(r);const s=y.encode(JSON.stringify(e));return n.push(s),n.join(".")}class at{constructor(t="ES256K",n){if(!n)throw new Le("TokenSigner: rawPrivateKey is required to sign a token");this.tokenType="JWT",this.rawPrivateKey=n}header(t={}){return{...{typ:this.tokenType,alg:"ES256K"},...t}}async sign(t,n=!1,r={}){const s=this.header(r),c=G(t,s),i=u(S(c));return this.createWithSignedHash(t,n,s,c,i)}async createWithSignedHash(t,n,r,s,c){const i=await X(c,this.rawPrivateKey,{canonical:!1}),o=it(i);return n?{header:[y.encode(JSON.stringify(r))],payload:JSON.stringify(t),signature:[o]}:[s,o].join(".")}}class ht{constructor(t,n){this.tokenType="JWT",this.rawPublicKey=n}verify(t,n=!1){return typeof t=="string"?this.verifyCompact(t,n):typeof t=="object"?this.verifyExpanded(t,n):!1}verifyCompact(t,n){const r=t.split("."),s=r[0]+"."+r[1],c=o=>{const h=r[2],a=Ke(h);return _(d(w(a)),d(o),this.rawPublicKey,{strict:n})},i=u(S(s));return c(i)}verifyExpanded(t,n){const r=[t.header.join("."),y.encode(t.payload)].join(".");let s=!0;const c=o=>(t.signature.map(h=>{const a=Ke(h);_(d(w(a)),d(o),this.rawPublicKey,{strict:n})||(s=!1)}),s),i=u(S(r));return c(i)}}function ft(e){if(typeof e=="string"){const t=e.split("."),n=JSON.parse(y.decode(t[0])),r=JSON.parse(y.decode(t[1])),s=t[2];return{header:n,payload:r,signature:s}}else if(typeof e=="object"){if(typeof e.payload!="string")throw new Error("Expected token payload to be a base64 or json string");let t=e.payload;e.payload[0]!=="{"&&(t=y.decode(t));const n=[];return e.header.map(r=>{const s=JSON.parse(y.decode(r));n.push(s)}),{header:n,payload:JSON.parse(t),signature:e.signature}}}function dt(e){return G(e,{typ:"JWT",alg:"none"})+"."}export{U as BITCOIN_TO_STACKS_NETWORK_VERSION,oe as Ripemd160PolyfillDigest,j as STACKS_TO_BITCOIN_NETWORK_VERSION,K as StacksNetworkVersion,at as TokenSigner,ht as TokenVerifier,je as b58ToC32,fe as base58checkDecode,O as base58checkEncode,Re as c32ToB58,W as c32address,$ as c32addressDecode,le as c32checkDecode,pe as c32decode,V as c32normalize,ie as createHashRipemd160,G as createSigningInput,dt as createUnsecuredToken,ft as decodeToken,Xe as decryptContent,Se as decryptECIES,_e as derivePrivateKey,De as derivePublicKey,ke as eciesGetJsonStringLength,Ye as encryptContent,me as encryptECIES,Pe as equalConstTime,te as getAesCbcOutputLength,ne as getBase64OutputLength,re as getCipherObjectWrapper,ae as getRandomBytes,se as getSignedCipherObjectWrapper,qe as hashP2PKH,Fe as hashP2SH,Ze as hashP2WPKH,ze as hashP2WSH,A as hashRipemd160,he as isCompressedPublicKey,Ve as privateKeyToBase58Address,$e as privateKeyToStxAddress,Ge as publicKeyToBase58Address,ge as publicKeyToStxAddress,ce as ripemd160,N as sharedSecretToKeys,ye as signECDSA,We as validateStacksAddress,Qe as verifyECDSA};
