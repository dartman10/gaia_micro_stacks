import{getPublicKey as k,getRandomBytes as W,TokenSigner as Z,privateKeyToBase58Address as X,eciesGetJsonStringLength as Y,signECDSA as F,encryptContent as q,decodeToken as N,publicKeyToStxAddress as Q,TokenVerifier as ee,publicKeyToBase58Address as T,verifyECDSA as C,decryptContent as I}from"micro-stacks/crypto";import{bytesToHex as v,fetchPrivate as m,arrayBufferToUint8 as te,utf8ToBytes as re,getGlobalObject as ne}from"micro-stacks/common";import{parseZoneFile as oe}from"micro-stacks/zone-file";function se(e){return e?.map(r=>({...r,domain:r.path}))??null}async function D(e){const{hubInfo:r,privateKey:t,gaiaHubUrl:n,associationToken:o=null,scopes:s}=e,{challenge_text:i}=r,a=v(k(t,!0)),u=W(16).toString(),c={gaiaChallenge:i,hubUrl:n,iss:a,salt:u,associationToken:o,scopes:se(s)};return`v1:${await new Z("ES256K",t).sign(c)}`}async function ie(e){const{gaiaHubUrl:r,privateKey:t,associationToken:n,scopes:o}=e,i=await(await m(`${r}/hub_info`)).json(),{read_url_prefix:a,max_file_upload_size_megabytes:u}=i,c=await D({hubInfo:i,privateKey:t,gaiaHubUrl:r,associationToken:n,scopes:o});return{address:X(t),url_prefix:a,token:c,server:r,max_file_upload_size_megabytes:u}}const g={MISSING_PARAMETER:"missing_parameter",REMOTE_SERVICE_ERROR:"remote_service_error",INVALID_STATE:"invalid_state",NO_SESSION_DATA:"no_session_data",DOES_NOT_EXIST:"does_not_exist",FAILED_DECRYPTION_ERROR:"failed_decryption_error",INVALID_DID_ERROR:"invalid_did_error",NOT_ENOUGH_FUNDS_ERROR:"not_enough_error",INVALID_AMOUNT_ERROR:"invalid_amount_error",LOGIN_FAILED_ERROR:"login_failed",SIGNATURE_VERIFICATION_ERROR:"signature_verification_failure",CONFLICT_ERROR:"conflict_error",NOT_ENOUGH_PROOF_ERROR:"not_enough_proof_error",BAD_PATH_ERROR:"bad_path_error",VALIDATION_ERROR:"validation_error",PAYLOAD_TOO_LARGE_ERROR:"payload_too_large_error",PRECONDITION_FAILED_ERROR:"precondition_failed_error",UNKNOWN:"unknown"};Object.freeze(g);class B extends Error{constructor(r){super();let t=r.message,n=`Error Code: ${r.code}`,o=this.stack;if(o)n+=`Stack Trace:
${o}`;else try{throw new Error}catch(s){o=s.stack}t+=`
If you believe this exception is caused by a bug in blockstack.js,
      please file a bug report: https://github.com/blockstack/blockstack.js/issues

${n}`,this.message=t,this.code=r.code,this.parameter=r.parameter?r.parameter:void 0}toString(){return`${super.toString()}
    code: ${this.code} param: ${this.parameter?this.parameter:"n/a"}`}}class w extends B{constructor(r){const t=`Failed to verify signature: ${r}`;super({code:g.SIGNATURE_VERIFICATION_ERROR,message:t});this.message=t,this.name="SignatureVerificationError"}}class b extends B{constructor(r,t){super(r);t&&(this.hubError={statusCode:t.status,statusText:t.statusText},typeof t.body=="string"?this.hubError.message=t.body:typeof t.body=="object"&&Object.assign(this.hubError,t.body))}}class z extends b{constructor(r,t){super({message:r,code:g.DOES_NOT_EXIST},t);this.name="DoesNotExist"}}class ae extends b{constructor(r,t){super({message:r,code:g.CONFLICT_ERROR},t);this.name="ConflictError"}}class ce extends b{constructor(r,t){super({message:r,code:g.NOT_ENOUGH_PROOF_ERROR},t);this.name="NotEnoughProofError"}}class ue extends b{constructor(r,t){super({message:r,code:g.BAD_PATH_ERROR},t);this.name="BadPathError"}}class le extends b{constructor(r,t){super({message:r,code:g.VALIDATION_ERROR},t);this.name="ValidationError"}}class $ extends b{constructor(r,t,n){super({message:r,code:g.PAYLOAD_TOO_LARGE_ERROR},t);this.name="PayloadTooLargeError",this.maxUploadByteSize=n}}class fe extends b{constructor(r,t){super({message:r,code:g.PRECONDITION_FAILED_ERROR},t);this.name="PreconditionFailedError"}}async function de(e){let r="",t;try{r=await e.text();try{t=JSON.parse(r)}catch{}}catch(i){console.debug(`Error getting bad http response text: ${i}`)}const n=e.status,o=e.statusText;return{status:n,statusText:o,body:t||r}}function K(e){return Number.isFinite(e)?Math.floor(e*1024*1024):0}async function A(e,r,t){if(e.ok)throw new Error("Cannot get a Stacks from a valid response.");const n=await de(e);if(n.status===401)throw new le(r,n);if(n.status===402)throw new ce(r,n);if(n.status===403)throw new ue(r,n);if(n.status===404)throw new z(r,n);if(n.status===409)throw new ae(r,n);if(n.status===412)throw new fe(r,n);if(n.status===413){const o=t&&t.max_file_upload_size_megabytes?K(t.max_file_upload_size_megabytes):0;throw new $(r,n,o)}else throw new Error(r)}function pe(e){if(!e||!e.hubError||!e.hubError.statusCode)return!1;const r=e.hubError.statusCode;return r===401||r===409||r>=500&&r<=599}async function O(e){const{filename:r,contents:t,hubConfig:n,contentType:o="application/octet-stream"}=e,s={"Content-Type":o,Authorization:`bearer ${n.token}`},i=await m(`${n.server}/store/${n.address}/${r}`,{method:"POST",headers:s,body:t});if(!i.ok)throw await A(i,"Error when uploading to Gaia hub.",n);const a=await i.text();return JSON.parse(a)}function x(e,r){return Promise.resolve(`${r.url_prefix}${r.address}/${e}`)}const E=".sig",j="https://stacks-node-api.stacks.co/v1/names",G=class{constructor(e,r){this.wasString=typeof e=="string",this.content=G.normalizeContentDataType(e,r),this.contentType=r||this.detectContentType(),this.contentByteLength=this.detectContentLength()}static normalizeContentDataType(e,r){try{if(typeof e=="string"){const t=(r||"").toLowerCase().replace("-","");if(t.includes("charset")&&!t.includes("charset=utf8")&&!t.includes("charset=ascii"))throw new Error(`Unable to determine byte length with charset: ${r}`);return new TextEncoder().encode(e)}else{if(e instanceof Uint8Array)return e;if(ArrayBuffer.isView(e))return new Uint8Array(e.buffer,e.byteOffset,e.byteLength);if(typeof Blob!="undefined"&&e instanceof Blob)return e;if(e instanceof ArrayBuffer)return new Uint8Array(e);if(Array.isArray(e)){if(e.length>0&&(!Number.isInteger(e[0])||e[0]<0||e[0]>255))throw new Error(`Unexpected array values provided as file data: value "${e[0]}" at index 0 is not an octet number. ${this.supportedTypesMsg}`);return new Uint8Array(e)}else{const t=Object.prototype.toString.call(e);throw new Error(`Unexpected type provided as file data: ${t}. ${this.supportedTypesMsg}`)}}}catch(t){throw console.error(t),new Error(`Error processing data: ${t}`)}}detectContentType(){return this.wasString?"text/plain; charset=utf-8":typeof Blob!="undefined"&&this.content instanceof Blob&&this.content.type?this.content.type:"application/octet-stream"}detectContentLength(){if(ArrayBuffer.isView(this.content)||this.content instanceof Uint8Array)return this.content.byteLength;if(typeof Blob!="undefined"&&this.content instanceof Blob)return this.content.size;const e=Object.prototype.toString.call(this.content),r=new Error(`Unexpected type "${e}" while detecting content length`);throw console.error(r),r}async loadContent(){try{if(this.content instanceof Uint8Array)return this.content;if(ArrayBuffer.isView(this.content))return new Uint8Array(this.content.buffer,this.content.byteOffset,this.content.byteLength);if(typeof Blob!="undefined"&&this.content instanceof Blob){const e=new FileReader;return await new Promise((n,o)=>{e.onerror=s=>{o(s)},e.onload=()=>{const s=e.result;n(new Uint8Array(s))},e.readAsArrayBuffer(this.content)})}else{const e=Object.prototype.toString.call(this.content);throw new Error(`Unexpected type ${e}`)}}catch(e){console.error(e);const r=new Error(`Error loading content: ${e}`);throw console.error(r),r}}load(){return this.loadedData===void 0&&(this.loadedData=this.loadContent()),this.loadedData}};let H=G;H.supportedTypesMsg="Supported types are: `string` (to be UTF8 encoded), `Uint8Array`, `Blob`, `File`, `ArrayBuffer`, `UInt8Array` or any other typed array buffer. ";async function ye(e,r,t){let{privateKey:n}=t;const{encrypt:o,sign:s,gaiaHubConfig:i,cipherTextEncoding:a}=t;let{contentType:u=""}=t;const c=K(i.max_file_upload_size_megabytes),y=c>0,f=new H(r,u);if(u=f.contentType,!o&&y&&f.contentByteLength>c){const l=`The max file upload size for this hub is ${c} bytes, the given content is ${f.contentByteLength} bytes`,d=new $(l,null,c);throw console.error(d),d}if(o&&y&&a){const l=Y({contentLength:f.contentByteLength,wasString:f.wasString,sign:!!s,cipherTextEncoding:a});if(l>c){const d=`The max file upload size for this hub is ${c} bytes, the given content is ${l} bytes after encryption`,p=new $(d,null,c);throw console.error(p),p}}let h;if(!o&&s){const l=await f.load();if(typeof s=="string")n=s;else if(!n)throw Error("Need to pass private key");const d=await F({contents:l,privateKey:n});h=async p=>(await Promise.all([O({filename:e,contents:l,hubConfig:p,contentType:u}),O({filename:`${e}${E}`,contents:JSON.stringify(d),hubConfig:p,contentType:"application/json"})]))[0].publicURL}else{let l;if(!o&&!s)l=f.content;else{let d;if(typeof o=="string")d=o;else if(typeof s=="string")d=v(k(s,!0));else if(n)d=v(k(n,!0));else throw new Error("No private key passed");const p=await f.load(),R=await q(p,{publicKey:d,wasString:f.wasString,cipherTextEncoding:a,privateKey:n});if(l=JSON.stringify(R),n){const{signature:P,publicKey:_}=await F({contents:R,privateKey:n});l=JSON.stringify({signature:P,publicKey:_,cipherText:R})}u="application/json"}h=async d=>(await O({filename:e,contents:l,hubConfig:d,contentType:u})).publicURL}try{return await h(i)}catch(l){if(pe(l))return console.error(l),console.error("Possible recoverable error during Gaia upload, retrying..."),await h(i);throw l}}function he(e){if(!e.hasOwnProperty("uri")||!Array.isArray(e.uri)||e.uri.length<1)return null;const r=e.uri[0];if(!r.hasOwnProperty("target"))return null;let t=r.target;return t.startsWith("https")||t.startsWith("http")||(t=`https://${t}`),t}function U(e,r){let t;return r.proof&&r.proof.url&&(t=r.proof.url),{"@type":"Account",service:e,identifier:r.username,proofType:"http",proofUrl:t}}function ge(e){const r={"@type":"Person"};if(e){e.name&&e.name.formatted&&(r.name=e.name.formatted),e.bio&&(r.description=e.bio),e.location&&e.location.formatted&&(r.address={"@type":"PostalAddress",addressLocality:e.location.formatted});const t=[];e.avatar&&e.avatar.url&&t.push({"@type":"ImageObject",name:"avatar",contentUrl:e.avatar.url}),e.cover&&e.cover.url&&t.push({"@type":"ImageObject",name:"cover",contentUrl:e.cover.url}),t.length&&(r.image=t),e.website&&(r.website=[{"@type":"WebSite",url:e.website}]);const n=[];e.bitcoin&&e.bitcoin.address&&n.push({"@type":"Account",role:"payment",service:"bitcoin",identifier:e.bitcoin.address}),e.twitter&&e.twitter.username&&n.push(U("twitter",e.twitter)),e.facebook&&e.facebook.username&&n.push(U("facebook",e.facebook)),e.github&&e.github.username&&n.push(U("github",e.github)),e.auth&&e.auth.length>0&&e.auth[0]&&e.auth[0].publicKeychain&&n.push({"@type":"Account",role:"key",service:"bip32",identifier:e.auth[0].publicKeychain}),e.pgp&&e.pgp.url&&n.push({"@type":"Account",role:"key",service:"pgp",identifier:e.pgp.fingerprint,contentUrl:e.pgp.url}),r.account=n}return r}function we(e,r){const t=N(e);if(!t)throw Error("no decoded token");const n=t.payload;if(typeof n=="string")throw new Error("Unexpected token payload type of string");if(n.hasOwnProperty("subject")&&n.subject){if(!n.subject.hasOwnProperty("publicKey"))throw new Error("Token doesn't have a subject public key")}else throw new Error("Token doesn't have a subject");if(n.hasOwnProperty("issuer")&&n.issuer){if(!n.issuer.hasOwnProperty("publicKey"))throw new Error("Token doesn't have an issuer public key")}else throw new Error("Token doesn't have an issuer");if(!n.hasOwnProperty("claim"))throw new Error("Token doesn't have a claim");const o=n.issuer.publicKey,s=Q(o);if(r!==o){if(r!==s)throw new Error("Token issuer public key does not match the verifying value")}const i=new ee(t.header.alg,o);if(!i)throw new Error("Invalid token verifier");if(!i.verify(e))throw new Error("Token verification failed");return t}function be(e,r){const t=r?we(e,r):N(e);if(t&&t.hasOwnProperty("payload")){const n=t.payload;if(typeof n=="string")throw new Error("[micro-stacks] extractProfile: Unexpected token payload type of string");if(n.hasOwnProperty("claim"))return n.claim}return{}}async function Ee(e,r){let t=oe(e);if(t.hasOwnProperty("$origin")||(t=null),!(t&&Object.keys(t).length>0))return ge(JSON.parse(e));const o=he(t);if(o)try{const i=await(await m(o)).json();return be(i[0].token,r)}catch(s){throw console.error(`[micro-stacks] resolveZoneFileToProfile: error fetching token file ${o}: ${s}`),s}return console.debug("[micro-stacks] Token file url not found. Resolving to blank profile."),{}}async function V(e){const{username:r,zoneFileLookupURL:t=j}=e;if(!r)return Promise.reject();const n=`${t.replace(/\/$/,"")}/${e.username}`,s=await(await m(n)).json();if(s.hasOwnProperty("zonefile")&&s.hasOwnProperty("address"))return await Ee(s.zonefile,e.verify?s.address:void 0);throw new Error("Invalid zonefile lookup response: did not contain `address` or `zonefile` field")}async function J(e,r,t,n){const o=await V({username:r,zoneFileLookupURL:n});let s;if(!!o)return o.hasOwnProperty("apps")?o.apps.hasOwnProperty(t)&&(s=`${o.apps[t].replace(/\/?(\?|#|$)/,"/$1")}${e}`):o.hasOwnProperty("appsMeta")&&o.appsMeta.hasOwnProperty(t)&&(s=`${o.appsMeta[t].replace(/\/?(\?|#|$)/,"/$1")}${e}`),s}async function me(e,r){let t;if(r.username?t=await J(e,r.username,r.app,r.zoneFileLookupURL):t=await x(e,r.gaiaHubConfig),t)return t;throw new Error("Missing readURL")}async function M(e){const{app:r,username:t,zoneFileLookupURL:n,gaiaHubConfig:o}=e;let s;t?s=await J("/",t,r,n):o&&(s=await x("/",o));const i=/([13][a-km-zA-HJ-NP-Z0-9]{26,35})/.exec(s);if(!i)throw new Error("Failed to parse gaia address");return i[i.length-1]}async function S(e){const{path:r,forceText:t,app:n,username:o,zoneFileLookupURL:s,gaiaHubConfig:i}=e,a=await me(r,{app:n,username:o,zoneFileLookupURL:s,gaiaHubConfig:i}),u=await m(a);if(!u.ok)throw await A(u,`getFile ${r} failed.`,null);let c=u.headers.get("Content-Type");if(typeof c=="string"&&(c=c.toLowerCase()),t||c===null||c.startsWith("text")||c.startsWith("application/json"))return u.text();{const y=await u.arrayBuffer();return te(y)}}async function Re(e,r){const{app:t,username:n,zoneFileLookupURL:o,gaiaHubConfig:s}=r,i=`${e}${E}`;try{const[a,u,c]=await Promise.all([S({path:e,app:t,username:n,zoneFileLookupURL:o,forceText:!1,gaiaHubConfig:s}),S({path:i,app:t,username:n,zoneFileLookupURL:o,forceText:!0,gaiaHubConfig:s}),M({app:t,username:n,zoneFileLookupURL:o,gaiaHubConfig:s})]);if(!a)return a;if(!c)throw new w(`Failed to get gaia address for verification of: ${e}`);if(!u||typeof u!="string")throw new w(`Failed to obtain signature for file: ${e} -- looked in ${e}${E}`);let y,f;try{const p=JSON.parse(u);y=p.signature,f=p.publicKey}catch(p){throw p instanceof SyntaxError?new Error(`Failed to parse signature content JSON (path: ${e}${E}) The content may be corrupted.`):p}const h=T(f),l=typeof a=="string"?re(a):a,d=C({signature:y,contents:l,publicKey:f});if(c!==h)throw new w(`Signer pubkey address (${h}) doesn't match gaia address (${c})`);if(d)return a;throw new w(`Contents do not match ECDSA signature: path: ${e}, signature: ${e}${E}`)}catch(a){throw a instanceof z&&a.message.indexOf(i)>=0?new w(`Failed to obtain signature for file: ${e} -- looked in ${e}${E}`):a}}async function _e(e){const{path:r,storedContents:t,app:n,privateKey:o,username:s,zoneFileLookupURL:i,gaiaHubConfig:a}=e,u=o,c=u?k(u,!0):null;let y=null;if(s||a?y=await M({app:n,username:s,zoneFileLookupURL:i,gaiaHubConfig:a}):c&&(y=T(c)),!y)throw new w(`Failed to get gaia address for verification of: ${r}`);let f;try{f=JSON.parse(t)}catch(_){throw _ instanceof SyntaxError?new Error("Failed to parse encrypted, signed content JSON. The content may not be encrypted. If using getFile, try passing { verify: false, decrypt: false }."):_}const h=f.signature,l=f.publicKey,d=f.cipherText,p=T(l);if(!l||!d||!h)throw new w(`Failed to get signature verification data from file: ${r}`);if(p!==y)throw new w(`Signer pubkey address (${p}) doesn't match gaia address (${y})`);if(!C({signature:h,contents:d,publicKey:l}))throw new w(`Contents do not match ECDSA signature in file: ${r}`);if(!o)throw Error("Private key needs to be passed in order to decrypt content");return I(d,{privateKey:o})}async function ke(e,r){const t={decrypt:!0,verify:!1,app:ne("location",{returnEmptyObject:!0}).origin,zoneFileLookupURL:j,...r};if(t.verify&&!t.decrypt)return Re(e,t);const n=await S({path:e,app:t.app,username:t.username,zoneFileLookupURL:t.zoneFileLookupURL,forceText:!!t.decrypt,gaiaHubConfig:t.gaiaHubConfig});if(n===null)return n;if(typeof n!="string")throw new Error("[micro-stacks/storage] Expected to get back a string for the cipherText");let o=!!t.verify,s=!!t.decrypt;const i=typeof t.decrypt=="string"?t.decrypt:t.privateKey;if(n.includes("signature")&&n.includes("publicKey")&&(o=!0),n.includes("cipherText")&&n.includes("ephemeralPK")&&(s=!0),!o&&!s)return n;const a=!n.includes("cipherText");if(s&&a)throw new Error(`[micro-stacks/storage] Expected to get back a string that includes cipherText, is it encrypted? got back: ${JSON.stringify(n)}`);if(!i)throw new Error("[micro-stacks/storage] No private key was passed to getFile, a private key needs to be passed if decrypt is set to true");if(!o)return I(n,{privateKey:i});if(s&&o)return _e({path:e,storedContents:n,app:t.app,privateKey:i,username:t.username,zoneFileLookupURL:t.zoneFileLookupURL,gaiaHubConfig:t.gaiaHubConfig});throw new Error("[micro-stacks/storage] Should be unreachable.")}async function L(e,r){const t=await m(`${r.server}/delete/${r.address}/${e}`,{method:"DELETE",headers:{Authorization:`bearer ${r.token}`}});if(!t.ok)throw await A(t,"Error deleting file from Gaia hub.",r)}async function Oe(e,r){const{gaiaHubConfig:t,wasSigned:n}=r,o=[L(e,t)];n&&o.push(L(`${e}${E}`,t)),await Promise.all(o)}export{Oe as deleteFile,L as deleteFromGaiaHub,ie as generateGaiaHubConfig,ke as getFile,x as getFullReadUrl,V as lookupProfile,D as makeScopedGaiaAuthToken,ye as putFile,O as uploadToGaiaHub};
