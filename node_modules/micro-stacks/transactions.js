"use strict";Object.defineProperty(exports,"__esModule",{value:!0});var common=require("micro-stacks/common"),cryptoSha=require("micro-stacks/crypto-sha"),clarity=require("micro-stacks/clarity"),secp256k1=require("@noble/secp256k1"),crypto=require("micro-stacks/crypto"),network=require("micro-stacks/network"),api=require("micro-stacks/api");const CLARITY_INT_BYTE_SIZE=16,DEFAULT_CORE_NODE_API_URL="https://stacks-node-api.mainnet.stacks.co";exports.AnchorMode=void 0,function(e){e[e.OnChainOnly=1]="OnChainOnly",e[e.OffChainOnly=2]="OffChainOnly",e[e.Any=3]="Any"}(exports.AnchorMode||(exports.AnchorMode={}));const DEFAULT_TRANSACTION_VERSION=common.TransactionVersion.Mainnet;exports.PostConditionMode=void 0,function(e){e[e.Allow=1]="Allow",e[e.Deny=2]="Deny"}(exports.PostConditionMode||(exports.PostConditionMode={})),exports.PostConditionType=void 0,function(e){e[e.STX=0]="STX",e[e.Fungible=1]="Fungible",e[e.NonFungible=2]="NonFungible"}(exports.PostConditionType||(exports.PostConditionType={})),exports.AuthType=void 0,function(e){e[e.Standard=4]="Standard",e[e.Sponsored=5]="Sponsored"}(exports.AuthType||(exports.AuthType={})),exports.AddressHashMode=void 0,function(e){e[e.SerializeP2PKH=0]="SerializeP2PKH",e[e.SerializeP2SH=1]="SerializeP2SH",e[e.SerializeP2WPKH=2]="SerializeP2WPKH",e[e.SerializeP2WSH=3]="SerializeP2WSH"}(exports.AddressHashMode||(exports.AddressHashMode={})),exports.AddressVersion=void 0,function(e){e[e.MainnetSingleSig=22]="MainnetSingleSig",e[e.MainnetMultiSig=20]="MainnetMultiSig",e[e.TestnetSingleSig=26]="TestnetSingleSig",e[e.TestnetMultiSig=21]="TestnetMultiSig"}(exports.AddressVersion||(exports.AddressVersion={})),exports.PubKeyEncoding=void 0,function(e){e[e.Compressed=0]="Compressed",e[e.Uncompressed=1]="Uncompressed"}(exports.PubKeyEncoding||(exports.PubKeyEncoding={})),exports.FungibleConditionCode=void 0,function(e){e[e.Equal=1]="Equal",e[e.Greater=2]="Greater",e[e.GreaterEqual=3]="GreaterEqual",e[e.Less=4]="Less",e[e.LessEqual=5]="LessEqual"}(exports.FungibleConditionCode||(exports.FungibleConditionCode={})),exports.NonFungibleConditionCode=void 0,function(e){e[e.DoesNotOwn=16]="DoesNotOwn",e[e.Owns=17]="Owns"}(exports.NonFungibleConditionCode||(exports.NonFungibleConditionCode={})),exports.AssetType=void 0,function(e){e[e.STX=0]="STX",e[e.Fungible=1]="Fungible",e[e.NonFungible=2]="NonFungible"}(exports.AssetType||(exports.AssetType={})),exports.TxRejectedReason=void 0,function(e){e.Serialization="Serialization",e.Deserialization="Deserialization",e.SignatureValidation="SignatureValidation",e.FeeTooLow="FeeTooLow",e.BadNonce="BadNonce",e.NotEnoughFunds="NotEnoughFunds",e.NoSuchContract="NoSuchContract",e.NoSuchPublicFunction="NoSuchPublicFunction",e.BadFunctionArgument="BadFunctionArgument",e.ContractAlreadyExists="ContractAlreadyExists",e.PoisonMicroblocksDoNotConflict="PoisonMicroblocksDoNotConflict",e.PoisonMicroblockHasUnknownPubKeyHash="PoisonMicroblockHasUnknownPubKeyHash",e.PoisonMicroblockIsInvalid="PoisonMicroblockIsInvalid",e.BadAddressVersionByte="BadAddressVersionByte",e.NoCoinbaseViaMempool="NoCoinbaseViaMempool",e.ServerFailureNoSuchChainTip="ServerFailureNoSuchChainTip",e.ServerFailureDatabase="ServerFailureDatabase",e.ServerFailureOther="ServerFailureOther"}(exports.TxRejectedReason||(exports.TxRejectedReason={}));const leftPadHex=e=>e.length%2==0?e:`0${e}`,leftPadHexToLength=(e,t)=>e.padStart(t,"0"),rightPadHexToLength=(e,t)=>e.padEnd(t,"0"),txidFromData=e=>{const t=cryptoSha.hashSha512_256(e);return common.bytesToHex(t)};function parseReadOnlyResponse(e){if(e.okay)return clarity.hexToCV(e.result);throw new Error(e.cause)}function createStacksPublicKey(e){return{type:clarity.StacksMessageType.PublicKey,data:common.hexToBytes(e)}}function publicKeyFromSignature(e,t,n=exports.PubKeyEncoding.Compressed){const r=parseRecoverableSignature(t.data),s=new secp256k1.Signature(common.hexToBigInt(r.r),common.hexToBigInt(r.s)),i=secp256k1.Point.fromSignature(e,s,r.recoveryParam),o=n===exports.PubKeyEncoding.Compressed;return i.toHex(o)}function publicKeyFromBuffer(e){return{type:clarity.StacksMessageType.PublicKey,data:e}}function publicKeyToString(e){return common.bytesToHex(e.data)}function isCompressed(e){return!publicKeyToString(e).startsWith("04")}function isPrivateKeyCompressed(e){const t=typeof e=="string"?common.hexToBytes(e):e;let n=!1;if(t.length===33){if(t[t.length-1]!==1)throw new Error("Improperly formatted private-key. 33 byte length usually indicates compressed key, but last byte must be == 0x01");n=!0}return n}function serializePublicKey(e){const t=new common.BufferArray;return t.push(e.data),t.concatBuffer()}function pubKeyfromPrivKey(e){const t=createStacksPrivateKey(e),n=isPrivateKeyCompressed(e),r=secp256k1.getPublicKey(t.data.slice(0,32),n||t.compressed);return createStacksPublicKey(common.bytesToHex(r))}function compressPublicKey(e){const t=typeof e=="string"?e:common.bytesToHex(e),n=secp256k1.Point.fromHex(t).toHex(!0);return createStacksPublicKey(n)}function deserializePublicKey(e){const t=e.readUInt8(),n=t!==4?clarity.COMPRESSED_PUBKEY_LENGTH_BYTES:clarity.UNCOMPRESSED_PUBKEY_LENGTH_BYTES;return publicKeyFromBuffer(common.concatByteArrays([Uint8Array.from([t]),e.readBuffer(n)]))}function createStacksPrivateKey(e){const t=typeof e=="string"?common.hexToBytes(e):e;let n;if(t.length===33){if(t[t.length-1]!==1)throw new Error("Improperly formatted private-key. 33 byte length usually indicates compressed key, but last byte must be == 0x01");n=!0}else if(t.length===32)n=!1;else throw new Error(`Improperly formatted private-key hex string: length should be 32 or 33 bytes, provided with length ${t.length}`);return{data:t,compressed:n}}function makeRandomPrivKey(){return createStacksPrivateKey(secp256k1.utils.randomPrivateKey())}async function signWithKey(e,t){const[n,r]=await secp256k1.sign(t,e.data.slice(0,32),{canonical:!0,recovered:!0}),s=secp256k1.Signature.fromHex(n),i=32,o=leftPadHexToLength(common.intToHex(s.r),i*2),a=leftPadHexToLength(common.intToHex(s.s),i*2);if(r==null)throw new Error('"signature.recoveryParam" is not set');const c=common.intToHexString(r,1)+o+a;return createMessageSignature(c)}function getSignatureRecoveryParam(e){const t=32;if(e.length<t*2*2+1)throw new Error("Invalid signature");const n=e.substr(0,2);return common.hexStringToInt(n)}function parseRecoverableSignature(e){const t=32;if(e.length<t*2*2+1)throw new Error("Invalid signature");const n=e.substr(0,2),r=e.substr(2,t*2),s=e.substr(2+t*2,t*2);return{recoveryParam:common.hexStringToInt(n),r,s}}function getPublicKeyFromStacksPrivateKey(e){return pubKeyfromPrivKey(e.data)}function privateKeyToString(e){return common.bytesToHex(e.data)}var PayloadType;(function(e){e[e.TokenTransfer=0]="TokenTransfer",e[e.SmartContract=1]="SmartContract",e[e.ContractCall=2]="ContractCall",e[e.PoisonMicroblock=3]="PoisonMicroblock",e[e.Coinbase=4]="Coinbase"})(PayloadType||(PayloadType={}));function createTokenTransferPayload(e,t,n){return typeof e=="string"&&(e=clarity.principalCV(e)),typeof n=="string"&&(n=createMemoString(n)),{type:clarity.StacksMessageType.Payload,payloadType:0,recipient:e,amount:common.intToBigInt(t,!1),memo:n!=null?n:createMemoString("")}}function createContractCallPayload(e,t,n,r){return typeof e=="string"&&(e=clarity.createAddress(e)),typeof t=="string"&&(t=clarity.createLPString(t)),typeof n=="string"&&(n=clarity.createLPString(n)),{type:clarity.StacksMessageType.Payload,payloadType:2,contractAddress:e,contractName:t,functionName:n,functionArgs:r}}function createSmartContractPayload(e,t){return typeof e=="string"&&(e=clarity.createLPString(e)),typeof t=="string"&&(t=codeBodyString(t)),{type:clarity.StacksMessageType.Payload,payloadType:1,contractName:e,codeBody:t}}function createPoisonPayload(){return{type:clarity.StacksMessageType.Payload,payloadType:3}}function createCoinbasePayload(e){if(e.byteLength!=clarity.COINBASE_BUFFER_LENGTH_BYTES)throw Error(`Coinbase buffer size must be ${clarity.COINBASE_BUFFER_LENGTH_BYTES} bytes`);return{type:clarity.StacksMessageType.Payload,payloadType:4,coinbaseBuffer:e}}function serializePayload(e){const t=new common.BufferArray;switch(t.appendByte(e.payloadType),e.payloadType){case 0:t.push(clarity.serializeCV(e.recipient)),t.push(common.intToBytes(e.amount,!1,8)),t.push(serializeStacksMessage(e.memo));break;case 2:t.push(serializeStacksMessage(e.contractAddress)),t.push(serializeStacksMessage(e.contractName)),t.push(serializeStacksMessage(e.functionName));const n=new Uint8Array(4);common.writeUInt32BE(n,e.functionArgs.length,0),t.push(n),e.functionArgs.forEach(r=>{t.push(clarity.serializeCV(r))});break;case 1:t.push(serializeStacksMessage(e.contractName)),t.push(serializeStacksMessage(e.codeBody));break;case 3:break;case 4:t.push(e.coinbaseBuffer);break}return t.concatBuffer()}function deserializePayload(e){switch(e.readUInt8Enum(PayloadType,n=>{throw new Error(`Cannot recognize PayloadType: ${n}`)})){case 0:const n=clarity.deserializeCV(e),r=common.intToBigInt(e.readBuffer(8),!1),s=deserializeMemoString(e);return createTokenTransferPayload(n,r,s);case 2:const i=clarity.deserializeAddress(e),o=clarity.deserializeLPString(e),a=clarity.deserializeLPString(e),p=[],c=e.readUInt32BE();for(let y=0;y<c;y++){const g=clarity.deserializeCV(e);p.push(g)}return createContractCallPayload(i,o,a,p);case 1:const d=clarity.deserializeLPString(e),u=clarity.deserializeLPString(e,4,1e5);return createSmartContractPayload(d,u);case 3:return createPoisonPayload();case 4:const l=e.readBuffer(clarity.COINBASE_BUFFER_LENGTH_BYTES);return createCoinbasePayload(l)}}function createSTXPostCondition(e,t,n){return typeof e=="string"&&(e=parsePrincipalString(e)),{type:clarity.StacksMessageType.PostCondition,conditionType:exports.PostConditionType.STX,principal:e,conditionCode:t,amount:common.intToBigInt(n,!1)}}function createFungiblePostCondition(e,t,n,r){return typeof e=="string"&&(e=parsePrincipalString(e)),typeof r=="string"&&(r=parseAssetInfoString(r)),{type:clarity.StacksMessageType.PostCondition,conditionType:exports.PostConditionType.Fungible,principal:e,conditionCode:t,amount:common.intToBigInt(n,!1),assetInfo:r}}function createNonFungiblePostCondition(e,t,n,r){return typeof e=="string"&&(e=parsePrincipalString(e)),typeof n=="string"&&(n=parseAssetInfoString(n)),{type:clarity.StacksMessageType.PostCondition,conditionType:exports.PostConditionType.NonFungible,principal:e,conditionCode:t,assetInfo:n,assetName:r}}function serializePostCondition(e){const t=new common.BufferArray;return t.appendByte(e.conditionType),t.push(serializePrincipal(e.principal)),(e.conditionType===exports.PostConditionType.Fungible||e.conditionType===exports.PostConditionType.NonFungible)&&t.push(serializeAssetInfo(e.assetInfo)),e.conditionType===exports.PostConditionType.NonFungible&&t.push(clarity.serializeCV(e.assetName)),t.appendByte(e.conditionCode),(e.conditionType===exports.PostConditionType.STX||e.conditionType===exports.PostConditionType.Fungible)&&t.push(common.intToBytes(e.amount,!1,8)),t.concatBuffer()}function deserializePostCondition(e){const t=e.readUInt8Enum(exports.PostConditionType,o=>{throw new common.DeserializationError(`Could not read ${o} as PostConditionType`)}),n=deserializePrincipal(e);let r,s,i;switch(t){case exports.PostConditionType.STX:return r=e.readUInt8Enum(exports.FungibleConditionCode,a=>{throw new common.DeserializationError(`Could not read ${a} as FungibleConditionCode`)}),i=BigInt("0x"+common.bytesToHex(e.readBuffer(8))),{type:clarity.StacksMessageType.PostCondition,conditionType:exports.PostConditionType.STX,principal:n,conditionCode:r,amount:i};case exports.PostConditionType.Fungible:return s=deserializeAssetInfo(e),r=e.readUInt8Enum(exports.FungibleConditionCode,a=>{throw new common.DeserializationError(`Could not read ${a} as FungibleConditionCode`)}),i=BigInt("0x"+common.bytesToHex(e.readBuffer(8))),{type:clarity.StacksMessageType.PostCondition,conditionType:exports.PostConditionType.Fungible,principal:n,conditionCode:r,amount:i,assetInfo:s};case exports.PostConditionType.NonFungible:s=deserializeAssetInfo(e);const o=clarity.deserializeCV(e);return r=e.readUInt8Enum(exports.NonFungibleConditionCode,a=>{throw new common.DeserializationError(`Could not read ${a} as FungibleConditionCode`)}),{type:clarity.StacksMessageType.PostCondition,conditionType:exports.PostConditionType.NonFungible,principal:n,conditionCode:r,assetInfo:s,assetName:o}}}function serializeStacksMessage(e){switch(e.type){case clarity.StacksMessageType.Address:return clarity.serializeAddress(e);case clarity.StacksMessageType.Principal:return serializePrincipal(e);case clarity.StacksMessageType.LengthPrefixedString:return clarity.serializeLPString(e);case clarity.StacksMessageType.MemoString:return serializeMemoString(e);case clarity.StacksMessageType.AssetInfo:return serializeAssetInfo(e);case clarity.StacksMessageType.PostCondition:return serializePostCondition(e);case clarity.StacksMessageType.PublicKey:return serializePublicKey(e);case clarity.StacksMessageType.LengthPrefixedList:return serializeLPList(e);case clarity.StacksMessageType.Payload:return serializePayload(e);case clarity.StacksMessageType.TransactionAuthField:return serializeTransactionAuthField(e);case clarity.StacksMessageType.MessageSignature:return serializeMessageSignature(e)}}function deserializeStacksMessage(e,t,n){switch(t){case clarity.StacksMessageType.Address:return clarity.deserializeAddress(e);case clarity.StacksMessageType.Principal:return deserializePrincipal(e);case clarity.StacksMessageType.LengthPrefixedString:return clarity.deserializeLPString(e);case clarity.StacksMessageType.MemoString:return deserializeMemoString(e);case clarity.StacksMessageType.AssetInfo:return deserializeAssetInfo(e);case clarity.StacksMessageType.PostCondition:return deserializePostCondition(e);case clarity.StacksMessageType.PublicKey:return deserializePublicKey(e);case clarity.StacksMessageType.Payload:return deserializePayload(e);case clarity.StacksMessageType.LengthPrefixedList:if(!n)throw new common.DeserializationError("No List Type specified");return deserializeLPList(e,n);case clarity.StacksMessageType.MessageSignature:return deserializeMessageSignature(e);default:throw new Error("Could not recognize StacksMessageType")}}function createEmptyAddress(){return{type:clarity.StacksMessageType.Address,version:crypto.StacksNetworkVersion.mainnetP2PKH,hash160:"0".repeat(40)}}function addressFromVersionHash(e,t){return{type:clarity.StacksMessageType.Address,version:e,hash160:t}}function addressHashModeToVersion(e,t){switch(e){case exports.AddressHashMode.SerializeP2PKH:switch(t){case common.TransactionVersion.Mainnet:return crypto.StacksNetworkVersion.mainnetP2PKH;case common.TransactionVersion.Testnet:return crypto.StacksNetworkVersion.testnetP2PKH;default:throw new Error(`Unexpected txVersion ${JSON.stringify(t)} for hashMode ${e}`)}case exports.AddressHashMode.SerializeP2SH:case exports.AddressHashMode.SerializeP2WPKH:case exports.AddressHashMode.SerializeP2WSH:switch(t){case common.TransactionVersion.Mainnet:return crypto.StacksNetworkVersion.mainnetP2SH;case common.TransactionVersion.Testnet:return crypto.StacksNetworkVersion.testnetP2SH;default:throw new Error(`Unexpected txVersion ${JSON.stringify(t)} for hashMode ${e}`)}default:throw new Error(`Unexpected hashMode ${JSON.stringify(e)}`)}}function addressFromHashMode(e,t,n){const r=addressHashModeToVersion(e,t);return addressFromVersionHash(r,n)}function addressFromPublicKeys(e,t,n,r){if(r.length===0)throw Error("Invalid number of public keys");if((t===exports.AddressHashMode.SerializeP2PKH||t===exports.AddressHashMode.SerializeP2WPKH)&&(r.length!==1||n!==1))throw Error("Invalid number of public keys or signatures");if(t===exports.AddressHashMode.SerializeP2WPKH||t===exports.AddressHashMode.SerializeP2WSH){for(let s=0;s<r.length;s++)if(!isCompressed(r[s]))throw Error("Public keys must be compressed for segwit")}switch(t){case exports.AddressHashMode.SerializeP2PKH:return addressFromVersionHash(e,crypto.hashP2PKH(r[0].data));case exports.AddressHashMode.SerializeP2WPKH:return addressFromVersionHash(e,crypto.hashP2WPKH(r[0].data));case exports.AddressHashMode.SerializeP2SH:return addressFromVersionHash(e,crypto.hashP2SH(n,r.map(serializePublicKey)));case exports.AddressHashMode.SerializeP2WSH:return addressFromVersionHash(e,crypto.hashP2WSH(n,r.map(serializePublicKey)))}}function parsePrincipalString(e){if(e.includes(".")){const[t,n]=e.split(".");return createContractPrincipal(t,n)}else return createStandardPrincipal(e)}function createStandardPrincipal(e){return{type:clarity.StacksMessageType.Principal,prefix:clarity.PostConditionPrincipalID.Standard,address:clarity.createAddress(e)}}function createContractPrincipal(e,t){return{type:clarity.StacksMessageType.Principal,prefix:clarity.PostConditionPrincipalID.Contract,contractName:clarity.createLPString(t),address:clarity.createAddress(e)}}function serializePrincipal(e){const t=new common.BufferArray;return t.push(Uint8Array.from([e.prefix])),t.push(clarity.serializeAddress(e.address)),e.prefix===clarity.PostConditionPrincipalID.Contract&&t.push(clarity.serializeLPString(e.contractName)),t.concatBuffer()}function deserializePrincipal(e){const t=e.readUInt8Enum(clarity.PostConditionPrincipalID,s=>{throw new common.DeserializationError("Unexpected Principal payload type: ${n}")}),n=clarity.deserializeAddress(e);if(t===clarity.PostConditionPrincipalID.Standard)return{type:clarity.StacksMessageType.Principal,prefix:t,address:n};const r=clarity.deserializeLPString(e);return{type:clarity.StacksMessageType.Principal,prefix:t,address:n,contractName:r}}function codeBodyString(e){return clarity.createLPString(e,4,1e5)}function createMemoString(e){if(e&&clarity.exceedsMaxLengthBytes(e,clarity.MEMO_MAX_LENGTH_BYTES))throw new Error(`Memo exceeds maximum length of ${clarity.MEMO_MAX_LENGTH_BYTES.toString()} bytes`);return{type:clarity.StacksMessageType.MemoString,content:e}}function serializeMemoString(e){const t=new common.BufferArray,n=common.utf8ToBytes(e.content),r=rightPadHexToLength(common.bytesToHex(n),clarity.MEMO_MAX_LENGTH_BYTES*2);return t.push(common.hexToBytes(r)),t.concatBuffer()}function deserializeMemoString(e){const t=e.readBuffer(clarity.MEMO_MAX_LENGTH_BYTES),n=t.indexOf(0),r=common.bytesToUtf8(t.slice(0,n));return{type:clarity.StacksMessageType.MemoString,content:r}}function parseAssetInfoString(e){const[t,n,r]=e.split(/\.|::/);return createAssetInfo(t,n,r)}function createAssetInfo(e,t,n){return{type:clarity.StacksMessageType.AssetInfo,address:clarity.createAddress(e),contractName:clarity.createLPString(t),assetName:clarity.createLPString(n)}}function serializeAssetInfo(e){const t=new common.BufferArray;return t.push(clarity.serializeAddress(e.address)),t.push(clarity.serializeLPString(e.contractName)),t.push(clarity.serializeLPString(e.assetName)),t.concatBuffer()}function deserializeAssetInfo(e){return{type:clarity.StacksMessageType.AssetInfo,address:clarity.deserializeAddress(e),contractName:clarity.deserializeLPString(e),assetName:clarity.deserializeLPString(e)}}function createLPList(e,t){return{type:clarity.StacksMessageType.LengthPrefixedList,lengthPrefixBytes:t||4,values:e}}function serializeLPList(e){const t=e.values,n=new common.BufferArray;n.appendHexString(common.intToHexString(t.length,e.lengthPrefixBytes));for(let r=0;r<t.length;r++)n.push(serializeStacksMessage(t[r]));return n.concatBuffer()}function deserializeLPList(e,t,n){const r=common.hexStringToInt(common.bytesToHex(e.readBuffer(n||4))),s=[];for(let i=0;i<r;i++)switch(t){case clarity.StacksMessageType.Address:s.push(clarity.deserializeAddress(e));break;case clarity.StacksMessageType.LengthPrefixedString:s.push(clarity.deserializeLPString(e));break;case clarity.StacksMessageType.MemoString:s.push(deserializeMemoString(e));break;case clarity.StacksMessageType.AssetInfo:s.push(deserializeAssetInfo(e));break;case clarity.StacksMessageType.PostCondition:s.push(deserializePostCondition(e));break;case clarity.StacksMessageType.PublicKey:s.push(deserializePublicKey(e));break;case clarity.StacksMessageType.TransactionAuthField:s.push(deserializeTransactionAuthField(e));break}return createLPList(s,n)}var __defProp$3=Object.defineProperty,__defProps$1=Object.defineProperties,__getOwnPropDescs$1=Object.getOwnPropertyDescriptors,__getOwnPropSymbols$3=Object.getOwnPropertySymbols,__hasOwnProp$3=Object.prototype.hasOwnProperty,__propIsEnum$3=Object.prototype.propertyIsEnumerable,__defNormalProp$3=(e,t,n)=>t in e?__defProp$3(e,t,{enumerable:!0,configurable:!0,writable:!0,value:n}):e[t]=n,__spreadValues$3=(e,t)=>{for(var n in t||(t={}))__hasOwnProp$3.call(t,n)&&__defNormalProp$3(e,n,t[n]);if(__getOwnPropSymbols$3)for(var n of __getOwnPropSymbols$3(t))__propIsEnum$3.call(t,n)&&__defNormalProp$3(e,n,t[n]);return e},__spreadProps$1=(e,t)=>__defProps$1(e,__getOwnPropDescs$1(t));class Deserializable{static deserialize(t){const n=new this;return n.deserialize(t),n}}function createMessageSignature(e){if(common.hexToBytes(e).byteLength!=clarity.RECOVERABLE_ECDSA_SIG_LENGTH_BYTES)throw Error("Invalid signature");return{type:clarity.StacksMessageType.MessageSignature,data:e}}function emptyMessageSignature(){return{type:clarity.StacksMessageType.MessageSignature,data:common.bytesToHex(new Uint8Array(clarity.RECOVERABLE_ECDSA_SIG_LENGTH_BYTES).fill(0))}}function serializeMessageSignature(e){const t=new common.BufferArray;return t.appendHexString(e.data),t.concatBuffer()}function deserializeMessageSignature(e){return createMessageSignature(common.bytesToHex(e.readBuffer(clarity.RECOVERABLE_ECDSA_SIG_LENGTH_BYTES)))}var AuthFieldType;(function(e){e[e.PublicKeyCompressed=0]="PublicKeyCompressed",e[e.PublicKeyUncompressed=1]="PublicKeyUncompressed",e[e.SignatureCompressed=2]="SignatureCompressed",e[e.SignatureUncompressed=3]="SignatureUncompressed"})(AuthFieldType||(AuthFieldType={}));function createTransactionAuthField(e,t){return{pubKeyEncoding:e,type:clarity.StacksMessageType.TransactionAuthField,contents:t}}function serializeTransactionAuthField(e){const t=new common.BufferArray;switch(e.contents.type){case clarity.StacksMessageType.PublicKey:e.pubKeyEncoding==exports.PubKeyEncoding.Compressed?(t.appendByte(0),t.push(serializePublicKey(e.contents))):(t.appendByte(1),t.push(serializePublicKey(compressPublicKey(e.contents.data))));break;case clarity.StacksMessageType.MessageSignature:e.pubKeyEncoding==exports.PubKeyEncoding.Compressed?t.appendByte(2):t.appendByte(3),t.push(serializeMessageSignature(e.contents));break}return t.concatBuffer()}function deserializeTransactionAuthField(e){const t=e.readUInt8Enum(AuthFieldType,n=>{throw new common.DeserializationError(`Could not read ${n} as AuthFieldType`)});switch(t){case 0:return createTransactionAuthField(exports.PubKeyEncoding.Compressed,deserializePublicKey(e));case 1:return createTransactionAuthField(exports.PubKeyEncoding.Uncompressed,deserializePublicKey(e));case 2:return createTransactionAuthField(exports.PubKeyEncoding.Compressed,deserializeMessageSignature(e));case 3:return createTransactionAuthField(exports.PubKeyEncoding.Uncompressed,deserializeMessageSignature(e));default:throw new Error(`Unknown auth field type: ${JSON.stringify(t)}`)}}function createSingleSigSpendingCondition(e,t,n,r){const s=addressFromPublicKeys(0,e,1,[createStacksPublicKey(t)]).hash160,i=isCompressed(createStacksPublicKey(t))?exports.PubKeyEncoding.Compressed:exports.PubKeyEncoding.Uncompressed;return{hashMode:e,signer:s,nonce:common.intToBigInt(n,!1),fee:common.intToBigInt(r,!1),keyEncoding:i,signature:emptyMessageSignature()}}function createMultiSigSpendingCondition(e,t,n,r,s){const i=n.map(createStacksPublicKey),o=addressFromPublicKeys(0,e,t,i).hash160;return{hashMode:e,signer:o,nonce:common.intToBigInt(r,!1),fee:common.intToBigInt(s,!1),fields:[],signaturesRequired:t}}function isSingleSig(e){return"signature"in e}function clearCondition(e){const t=common.cloneDeep(e);return t.nonce=0,t.fee=0,isSingleSig(t)?t.signature=emptyMessageSignature():t.fields=[],__spreadProps$1(__spreadValues$3({},t),{nonce:BigInt(0),fee:BigInt(0)})}function serializeSingleSigSpendingCondition(e){const t=new common.BufferArray;return t.appendByte(e.hashMode),t.appendHexString(e.signer),t.push(common.intToBytes(e.nonce,!1,8)),t.push(common.intToBytes(e.fee,!1,8)),t.appendByte(e.keyEncoding),t.push(serializeMessageSignature(e.signature)),t.concatBuffer()}function serializeMultiSigSpendingCondition(e){const t=new common.BufferArray;t.appendByte(e.hashMode),t.appendHexString(e.signer),t.push(common.intToBytes(e.nonce,!1,8)),t.push(common.intToBytes(e.fee,!1,8));const n=createLPList(e.fields);t.push(serializeLPList(n));const r=new Uint8Array(2);return common.writeUInt16BE(r,e.signaturesRequired,0),t.push(r),t.concatBuffer()}function deserializeSingleSigSpendingCondition(e,t){const n=common.bytesToHex(t.readBuffer(20)),r=BigInt("0x"+common.bytesToHex(t.readBuffer(8))),s=BigInt("0x"+common.bytesToHex(t.readBuffer(8))),i=t.readUInt8Enum(exports.PubKeyEncoding,a=>{throw new common.DeserializationError(`Could not parse ${a} as PubKeyEncoding`)});if(e===exports.AddressHashMode.SerializeP2WPKH&&i!=exports.PubKeyEncoding.Compressed)throw new common.DeserializationError("Failed to parse singlesig spending condition: incomaptible hash mode and key encoding");const o=deserializeMessageSignature(t);return{hashMode:e,signer:n,nonce:r,fee:s,keyEncoding:i,signature:o}}function deserializeMultiSigSpendingCondition(e,t){const n=common.bytesToHex(t.readBuffer(20)),r=BigInt("0x"+common.bytesToHex(t.readBuffer(8))),s=BigInt("0x"+common.bytesToHex(t.readBuffer(8))),i=deserializeLPList(t,clarity.StacksMessageType.TransactionAuthField).values;let o=!1,a=0;for(const c of i)switch(c.contents.type){case clarity.StacksMessageType.PublicKey:isCompressed(c.contents)||(o=!0);break;case clarity.StacksMessageType.MessageSignature:if(c.pubKeyEncoding===exports.PubKeyEncoding.Uncompressed&&(o=!0),a+=1,a===65536)throw new TypeError("Failed to parse multisig spending condition: too many signatures");break}const p=t.readUInt16BE();if(a!==p)throw new TypeError("Incorrect number of signatures");if(o&&e===exports.AddressHashMode.SerializeP2SH)throw new TypeError("Uncompressed keys are not allowed in this hash mode");return{hashMode:e,signer:n,nonce:r,fee:s,fields:i,signaturesRequired:p}}function serializeSpendingCondition(e){return isSingleSig(e)?serializeSingleSigSpendingCondition(e):serializeMultiSigSpendingCondition(e)}function deserializeSpendingCondition(e){const t=e.readUInt8Enum(exports.AddressHashMode,n=>{throw new common.DeserializationError(`Could not parse ${n} as AddressHashMode`)});return t===exports.AddressHashMode.SerializeP2PKH||t===exports.AddressHashMode.SerializeP2WPKH?deserializeSingleSigSpendingCondition(t,e):deserializeMultiSigSpendingCondition(t,e)}function makeSigHashPreSign(e,t,n,r){const s=32+1+8+8,i=[common.hexToBytes(e),Uint8Array.from([t]),common.intToBytes(n,!1,8),common.intToBytes(r,!1,8)],o=common.concatByteArrays(i);if(o.byteLength!==s)throw Error("Invalid signature hash length");return txidFromData(o)}function makeSigHashPostSign(e,t,n){const r=32+1+clarity.RECOVERABLE_ECDSA_SIG_LENGTH_BYTES,s=isCompressed(t)?exports.PubKeyEncoding.Compressed:exports.PubKeyEncoding.Uncompressed,i=e+leftPadHex(s.toString(16))+n.data,o=common.hexToBytes(i);if(o.byteLength>r)throw Error("Invalid signature hash length");return txidFromData(o)}async function nextSignature(e,t,n,r,s){const i=makeSigHashPreSign(e,t,n,r),o=await signWithKey(s,i),a=getPublicKeyFromStacksPrivateKey(s),p=makeSigHashPostSign(i,a,o);return{nextSig:o,nextSigHash:p}}function nextVerification(e,t,n,r,s,i){const o=makeSigHashPreSign(e,t,n,r),a=createStacksPublicKey(publicKeyFromSignature(o,i,s)),p=makeSigHashPostSign(o,a,i);return{pubKey:a,nextSigHash:p}}function newInitialSigHash(){const e=createSingleSigSpendingCondition(exports.AddressHashMode.SerializeP2PKH,"",0,0);return e.signer=createEmptyAddress().hash160,e.keyEncoding=exports.PubKeyEncoding.Compressed,e.signature=emptyMessageSignature(),e}function verify(e,t,n){return isSingleSig(e)?verifySingleSig(e,t,n):verifyMultiSig(e,t,n)}function verifySingleSig(e,t,n){const{nextSigHash:r,pubKey:s}=nextVerification(t,n,e.fee,e.nonce,e.keyEncoding,e.signature),i=addressFromPublicKeys(0,e.hashMode,1,[s]).hash160;if(i!==e.signer)throw new TypeError(`Signer hash does not equal hash of public key(s): ${i} != ${e.signer}`);return r}function verifyMultiSig(e,t,n){const r=[];let s=t,i=!1,o=0;for(const p of e.fields){let c;switch(p.contents.type){case clarity.StacksMessageType.PublicKey:isCompressed(p.contents)||(i=!0),c=p.contents;break;case clarity.StacksMessageType.MessageSignature:p.pubKeyEncoding===exports.PubKeyEncoding.Uncompressed&&(i=!0);const{pubKey:d,nextSigHash:u}=nextVerification(s,n,e.fee,e.nonce,p.pubKeyEncoding,p.contents);if(s=u,c=d,o+=1,o===65536)throw new TypeError("Too many signatures");break}r.push(c)}if(o!==e.signaturesRequired)throw new TypeError("Incorrect number of signatures");if(i&&e.hashMode===exports.AddressHashMode.SerializeP2SH)throw new TypeError("Uncompressed keys are not allowed in this hash mode");const a=addressFromPublicKeys(0,e.hashMode,e.signaturesRequired,r).hash160;if(a!==e.signer)throw new TypeError(`Signer hash does not equal hash of public key(s): ${a} != ${e.signer}`);return s}function createStandardAuth(e){return{authType:exports.AuthType.Standard,spendingCondition:e}}function createSponsoredAuth(e,t){return{authType:exports.AuthType.Sponsored,spendingCondition:e,sponsorSpendingCondition:t||createSingleSigSpendingCondition(exports.AddressHashMode.SerializeP2PKH,"0".repeat(66),0,0)}}function intoInitialSighashAuth(e){if(e.spendingCondition)switch(e.authType){case exports.AuthType.Standard:return createStandardAuth(clearCondition(e.spendingCondition));case exports.AuthType.Sponsored:return createSponsoredAuth(clearCondition(e.spendingCondition),newInitialSigHash());default:throw new common.SigningError("Unexpected authorization type for signing")}throw new Error("Authorization missing SpendingCondition")}function verifyOrigin(e,t){switch(e.authType){case exports.AuthType.Standard:return verify(e.spendingCondition,t,exports.AuthType.Standard);case exports.AuthType.Sponsored:return verify(e.spendingCondition,t,exports.AuthType.Standard);default:throw new common.SigningError("Invalid origin auth type")}}function setFee(e,t){switch(e.authType){case exports.AuthType.Standard:const n=__spreadProps$1(__spreadValues$3({},e.spendingCondition),{fee:common.intToBigInt(t,!1)});return __spreadProps$1(__spreadValues$3({},e),{spendingCondition:n});case exports.AuthType.Sponsored:const r=__spreadProps$1(__spreadValues$3({},e.sponsorSpendingCondition),{fee:common.intToBigInt(t,!1)});return __spreadProps$1(__spreadValues$3({},e),{sponsorSpendingCondition:r})}}function getFee(e){switch(e.authType){case exports.AuthType.Standard:return e.spendingCondition.fee;case exports.AuthType.Sponsored:return e.sponsorSpendingCondition.fee}}function setNonce(e,t){const n=__spreadProps$1(__spreadValues$3({},e.spendingCondition),{nonce:common.intToBigInt(t,!1)});return __spreadProps$1(__spreadValues$3({},e),{spendingCondition:n})}function setSponsorNonce(e,t){const n=__spreadProps$1(__spreadValues$3({},e.sponsorSpendingCondition),{nonce:common.intToBigInt(t,!1)});return __spreadProps$1(__spreadValues$3({},e),{sponsorSpendingCondition:n})}function setSponsor(e,t){const n=__spreadProps$1(__spreadValues$3({},t),{nonce:common.intToBigInt(t.nonce,!1),fee:common.intToBigInt(t.fee,!1)});return __spreadProps$1(__spreadValues$3({},e),{sponsorSpendingCondition:n})}function serializeAuthorization(e){const t=new common.BufferArray;switch(t.appendByte(e.authType),e.authType){case exports.AuthType.Standard:t.push(serializeSpendingCondition(e.spendingCondition));break;case exports.AuthType.Sponsored:t.push(serializeSpendingCondition(e.spendingCondition)),t.push(serializeSpendingCondition(e.sponsorSpendingCondition));break}return t.concatBuffer()}function deserializeAuthorization(e){const t=e.readUInt8Enum(exports.AuthType,r=>{throw new common.DeserializationError(`Could not parse ${r} as AuthType`)});let n;switch(t){case exports.AuthType.Standard:return n=deserializeSpendingCondition(e),createStandardAuth(n);case exports.AuthType.Sponsored:n=deserializeSpendingCondition(e);const r=deserializeSpendingCondition(e);return createSponsoredAuth(n,r)}}var __defProp$2=Object.defineProperty,__defProps=Object.defineProperties,__getOwnPropDescs=Object.getOwnPropertyDescriptors,__getOwnPropSymbols$2=Object.getOwnPropertySymbols,__hasOwnProp$2=Object.prototype.hasOwnProperty,__propIsEnum$2=Object.prototype.propertyIsEnumerable,__defNormalProp$2=(e,t,n)=>t in e?__defProp$2(e,t,{enumerable:!0,configurable:!0,writable:!0,value:n}):e[t]=n,__spreadValues$2=(e,t)=>{for(var n in t||(t={}))__hasOwnProp$2.call(t,n)&&__defNormalProp$2(e,n,t[n]);if(__getOwnPropSymbols$2)for(var n of __getOwnPropSymbols$2(t))__propIsEnum$2.call(t,n)&&__defNormalProp$2(e,n,t[n]);return e},__spreadProps=(e,t)=>__defProps(e,__getOwnPropDescs(t));class StacksTransaction{constructor(t,n,r,s,i,o,a){if(this.version=t,this.auth=n,"amount"in r?this.payload=__spreadProps(__spreadValues$2({},r),{amount:common.intToBigInt(r.amount,!1)}):this.payload=r,this.chainId=a!=null?a:common.DEFAULT_CHAIN_ID,this.postConditionMode=i!=null?i:exports.PostConditionMode.Deny,this.postConditions=s!=null?s:createLPList([]),o)this.anchorMode=o;else switch(r.payloadType){case PayloadType.Coinbase:case PayloadType.PoisonMicroblock:{this.anchorMode=exports.AnchorMode.OnChainOnly;break}case PayloadType.ContractCall:case PayloadType.SmartContract:case PayloadType.TokenTransfer:{this.anchorMode=exports.AnchorMode.Any;break}}}signBegin(){const t=common.cloneDeep(this);return t.auth=intoInitialSighashAuth(t.auth),t.txid()}verifyBegin(){const t=common.cloneDeep(this);return t.auth=intoInitialSighashAuth(t.auth),t.txid()}createTxWithSignature(t){const n=typeof t=="string"?t:common.bytesToHex(t),r=common.cloneDeep(this);if(!r.auth.spendingCondition)throw new Error("Cannot set signature on transaction without spending condition");return r.auth.spendingCondition.signature=createMessageSignature(n),r}verifyOrigin(){return verifyOrigin(this.auth,this.verifyBegin())}async signNextOrigin(t,n){if(this.auth.spendingCondition===void 0)throw new Error('"auth.spendingCondition" is undefined');if(this.auth.authType===void 0)throw new Error('"auth.authType" is undefined');return this.signAndAppend(this.auth.spendingCondition,t,exports.AuthType.Standard,n)}async signNextSponsor(t,n){if(this.auth.authType===exports.AuthType.Sponsored)return await this.signAndAppend(this.auth.sponsorSpendingCondition,t,exports.AuthType.Sponsored,n);throw new Error('"auth.sponsorSpendingCondition" is undefined')}appendPubkey(t){const n=this.auth.spendingCondition;if(n&&!isSingleSig(n)){const r=isCompressed(t);n.fields.push(createTransactionAuthField(r?exports.PubKeyEncoding.Compressed:exports.PubKeyEncoding.Uncompressed,t))}else throw new Error("Can't append public key to a singlesig condition")}async signAndAppend(t,n,r,s){const{nextSig:i,nextSigHash:o}=await nextSignature(n,r,t.fee,t.nonce,s);if(isSingleSig(t))t.signature=i;else{const a=s.compressed||isPrivateKeyCompressed(s.data);t.fields.push(createTransactionAuthField(a?exports.PubKeyEncoding.Compressed:exports.PubKeyEncoding.Uncompressed,i))}return o}txid(){const t=this.serialize();return txidFromData(t)}setSponsor(t){if(this.auth.authType!=exports.AuthType.Sponsored)throw new common.SigningError("Cannot sponsor sign a non-sponsored transaction");this.auth=setSponsor(this.auth,t)}setFee(t){this.auth=setFee(this.auth,t)}setNonce(t){this.auth=setNonce(this.auth,t)}setSponsorNonce(t){if(this.auth.authType!=exports.AuthType.Sponsored)throw new common.SigningError("Cannot sponsor sign a non-sponsored transaction");this.auth=setSponsorNonce(this.auth,t)}serialize(){if(this.version===void 0)throw new common.SerializationError('"version" is undefined');if(this.chainId===void 0)throw new common.SerializationError('"chainId" is undefined');if(this.auth===void 0)throw new common.SerializationError('"auth" is undefined');if(this.anchorMode===void 0)throw new common.SerializationError('"anchorMode" is undefined');if(this.payload===void 0)throw new common.SerializationError('"payload" is undefined');const t=new common.BufferArray;t.appendByte(this.version);const n=new Uint8Array(4);return common.writeUInt32BE(n,this.chainId,0),t.push(n),t.push(serializeAuthorization(this.auth)),t.appendByte(this.anchorMode),t.appendByte(this.postConditionMode),t.push(serializeLPList(this.postConditions)),t.push(serializePayload(this.payload)),t.concatBuffer()}}function deserializeTransaction(e){let t;typeof e=="string"?e.slice(0,2).toLowerCase()==="0x"?t=new common.BufferReader(common.hexToBytes(e.slice(2))):t=new common.BufferReader(common.hexToBytes(e)):e instanceof Uint8Array?t=new common.BufferReader(e):t=e;const n=t.readUInt8Enum(common.TransactionVersion,c=>{throw new Error(`Could not parse ${c} as TransactionVersion`)}),r=t.readUInt32BE(),s=deserializeAuthorization(t),i=t.readUInt8Enum(exports.AnchorMode,c=>{throw new Error(`Could not parse ${c} as AnchorMode`)}),o=t.readUInt8Enum(exports.PostConditionMode,c=>{throw new Error(`Could not parse ${c} as PostConditionMode`)}),a=deserializeLPList(t,clarity.StacksMessageType.PostCondition),p=deserializePayload(t);return new StacksTransaction(n,s,p,a,o,i,r)}const isClarityAbiPrimitive=e=>typeof e=="string",isClarityAbiBuffer=e=>e.buffer!==void 0,isClarityAbiStringAscii=e=>e["string-ascii"]!==void 0,isClarityAbiStringUtf8=e=>e["string-utf8"]!==void 0,isClarityAbiResponse=e=>e.response!==void 0,isClarityAbiOptional=e=>e.optional!==void 0,isClarityAbiTuple=e=>e.tuple!==void 0,isClarityAbiList=e=>e.list!==void 0;function getTypeUnion(e){if(isClarityAbiPrimitive(e)){if(e==="uint128")return{id:clarity.ClarityAbiTypeId.ClarityAbiTypeUInt128,type:e};if(e==="int128")return{id:clarity.ClarityAbiTypeId.ClarityAbiTypeInt128,type:e};if(e==="bool")return{id:clarity.ClarityAbiTypeId.ClarityAbiTypeBool,type:e};if(e==="principal")return{id:clarity.ClarityAbiTypeId.ClarityAbiTypePrincipal,type:e};if(e==="trait_reference")return{id:clarity.ClarityAbiTypeId.ClarityAbiTypeTraitReference,type:e};if(e==="none")return{id:clarity.ClarityAbiTypeId.ClarityAbiTypeNone,type:e};throw new Error(`Unexpected Clarity ABI type primitive: ${JSON.stringify(e)}`)}else{if(isClarityAbiBuffer(e))return{id:clarity.ClarityAbiTypeId.ClarityAbiTypeBuffer,type:e};if(isClarityAbiResponse(e))return{id:clarity.ClarityAbiTypeId.ClarityAbiTypeResponse,type:e};if(isClarityAbiOptional(e))return{id:clarity.ClarityAbiTypeId.ClarityAbiTypeOptional,type:e};if(isClarityAbiTuple(e))return{id:clarity.ClarityAbiTypeId.ClarityAbiTypeTuple,type:e};if(isClarityAbiList(e))return{id:clarity.ClarityAbiTypeId.ClarityAbiTypeList,type:e};if(isClarityAbiStringAscii(e))return{id:clarity.ClarityAbiTypeId.ClarityAbiTypeStringAscii,type:e};if(isClarityAbiStringUtf8(e))return{id:clarity.ClarityAbiTypeId.ClarityAbiTypeStringUtf8,type:e};throw new Error(`Unexpected Clarity ABI type: ${JSON.stringify(e)}`)}}function encodeClarityValue(e,t){let n;switch(e.id!==void 0?n=e:n=getTypeUnion(e),n.id){case clarity.ClarityAbiTypeId.ClarityAbiTypeUInt128:return clarity.uintCV(t);case clarity.ClarityAbiTypeId.ClarityAbiTypeInt128:return clarity.intCV(t);case clarity.ClarityAbiTypeId.ClarityAbiTypeBool:if(t==="false"||t==="0")return clarity.falseCV();if(t==="true"||t==="1")return clarity.trueCV();throw new Error(`Unexpected Clarity bool value: ${JSON.stringify(t)}`);case clarity.ClarityAbiTypeId.ClarityAbiTypePrincipal:if(t.includes(".")){const[i,o]=t.split(".");return clarity.contractPrincipalCV(i,o)}else return clarity.standardPrincipalCV(t);case clarity.ClarityAbiTypeId.ClarityAbiTypeTraitReference:const[r,s]=t.split(".");return clarity.contractPrincipalCV(r,s);case clarity.ClarityAbiTypeId.ClarityAbiTypeNone:return clarity.noneCV();case clarity.ClarityAbiTypeId.ClarityAbiTypeBuffer:return clarity.bufferCV(common.utf8ToBytes(t));case clarity.ClarityAbiTypeId.ClarityAbiTypeStringAscii:return clarity.stringAsciiCV(t);case clarity.ClarityAbiTypeId.ClarityAbiTypeStringUtf8:return clarity.stringUtf8CV(t);case clarity.ClarityAbiTypeId.ClarityAbiTypeResponse:throw new common.NotImplementedError(`Unsupported encoding for Clarity type: ${n.id}`);case clarity.ClarityAbiTypeId.ClarityAbiTypeOptional:throw new common.NotImplementedError(`Unsupported encoding for Clarity type: ${n.id}`);case clarity.ClarityAbiTypeId.ClarityAbiTypeTuple:throw new common.NotImplementedError(`Unsupported encoding for Clarity type: ${n.id}`);case clarity.ClarityAbiTypeId.ClarityAbiTypeList:throw new common.NotImplementedError(`Unsupported encoding for Clarity type: ${n.id}`);default:throw new Error(`Unexpected Clarity type ID: ${JSON.stringify(n)}`)}}function getTypeString(e){if(isClarityAbiPrimitive(e))return e==="int128"?"int":e==="uint128"?"uint":e;if(isClarityAbiBuffer(e))return`(buff ${e.buffer.length})`;if(isClarityAbiStringAscii(e))return`(string-ascii ${e["string-ascii"].length})`;if(isClarityAbiStringUtf8(e))return`(string-utf8 ${e["string-utf8"].length})`;if(isClarityAbiResponse(e))return`(response ${getTypeString(e.response.ok)} ${getTypeString(e.response.error)})`;if(isClarityAbiOptional(e))return`(optional ${getTypeString(e.optional)})`;if(isClarityAbiTuple(e))return`(tuple ${e.tuple.map(t=>`(${t.name} ${getTypeString(t.type)})`).join(" ")})`;if(isClarityAbiList(e))return`(list ${e.list.length} ${getTypeString(e.list.type)})`;throw new Error(`Type string unsupported for Clarity type: ${JSON.stringify(e)}`)}function abiFunctionToString(e){return`(define-${e.access==="read_only"?"read-only":e.access} (${e.name} ${e.args.map(n=>`(${n.name} ${getTypeString(n.type)})`).join(" ")}))`}function matchType(e,t){const n=getTypeUnion(t);switch(e.type){case clarity.ClarityType.BoolTrue:case clarity.ClarityType.BoolFalse:return n.id===clarity.ClarityAbiTypeId.ClarityAbiTypeBool;case clarity.ClarityType.Int:return n.id===clarity.ClarityAbiTypeId.ClarityAbiTypeInt128;case clarity.ClarityType.UInt:return n.id===clarity.ClarityAbiTypeId.ClarityAbiTypeUInt128;case clarity.ClarityType.Buffer:return n.id===clarity.ClarityAbiTypeId.ClarityAbiTypeBuffer&&n.type.buffer.length>=e.buffer.length;case clarity.ClarityType.StringASCII:return n.id===clarity.ClarityAbiTypeId.ClarityAbiTypeStringAscii&&n.type["string-ascii"].length>=e.data.length;case clarity.ClarityType.StringUTF8:return n.id===clarity.ClarityAbiTypeId.ClarityAbiTypeStringUtf8&&n.type["string-utf8"].length>=e.data.length;case clarity.ClarityType.OptionalNone:return n.id===clarity.ClarityAbiTypeId.ClarityAbiTypeNone||n.id===clarity.ClarityAbiTypeId.ClarityAbiTypeOptional;case clarity.ClarityType.OptionalSome:return n.id===clarity.ClarityAbiTypeId.ClarityAbiTypeOptional&&matchType(e.value,n.type.optional);case clarity.ClarityType.ResponseErr:return n.id===clarity.ClarityAbiTypeId.ClarityAbiTypeResponse&&matchType(e.value,n.type.response.error);case clarity.ClarityType.ResponseOk:return n.id===clarity.ClarityAbiTypeId.ClarityAbiTypeResponse&&matchType(e.value,n.type.response.ok);case clarity.ClarityType.PrincipalContract:return n.id===clarity.ClarityAbiTypeId.ClarityAbiTypePrincipal||n.id===clarity.ClarityAbiTypeId.ClarityAbiTypeTraitReference;case clarity.ClarityType.PrincipalStandard:return n.id===clarity.ClarityAbiTypeId.ClarityAbiTypePrincipal;case clarity.ClarityType.List:return n.id==clarity.ClarityAbiTypeId.ClarityAbiTypeList&&n.type.list.length>=e.list.length&&e.list.every(r=>matchType(r,n.type.list.type));case clarity.ClarityType.Tuple:if(n.id==clarity.ClarityAbiTypeId.ClarityAbiTypeTuple){const r=common.cloneDeep(e.data);for(let s=0;s<n.type.tuple.length;s++){const i=n.type.tuple[s],o=i.name,a=r[o];if(a){if(!matchType(a,i.type))return!1;delete r[o]}else return!1}return!0}else return!1;default:return!1}}function validateContractCall(e,t){const n=t.functions.filter(r=>r.name===e.functionName.content);if(n.length===1){const s=n[0].args;if(e.functionArgs.length!==s.length)throw new Error(`Clarity function expects ${s.length} argument(s) but received ${e.functionArgs.length}`);for(let i=0;i<e.functionArgs.length;i++){const o=e.functionArgs[i],a=s[i];if(!matchType(o,a.type)){const p=i+1;throw new Error(`Clarity function \`${e.functionName.content}\` expects argument ${p} to be of type ${getTypeString(a.type)}, not ${clarity.getCVTypeString(o)}`)}}return!0}else throw n.length===0?new Error(`ABI doesn't contain a function with the name ${e.functionName.content}`):new Error(`Malformed ABI. Contains multiple functions with the name ${e.functionName.content}`)}function parseToCV(e,t){const n=getTypeString(t);if(isClarityAbiPrimitive(t)){if(t==="uint128")return clarity.uintCV(e);if(t==="int128")return clarity.intCV(e);if(t==="bool"){if(e.toLowerCase()==="true")return clarity.trueCV();if(e.toLowerCase()==="false")return clarity.falseCV();throw new Error(`Invalid bool value: ${e}`)}else if(t==="principal")if(e.includes(".")){const[r,s]=e.split(".");return clarity.contractPrincipalCV(r,s)}else return clarity.standardPrincipalCV(e);else throw new Error(`Contract function contains unsupported Clarity ABI type: ${n}`)}else if(isClarityAbiBuffer(t)){if(common.utf8ToBytes(e).byteLength>t.buffer.length)throw new Error(`Input exceeds specified buffer length limit of ${t.buffer.length}`);return clarity.bufferCVFromString(e)}else throw isClarityAbiResponse(t)?new Error(`Contract function contains unsupported Clarity ABI type: ${n}`):isClarityAbiOptional(t)?new Error(`Contract function contains unsupported Clarity ABI type: ${n}`):isClarityAbiTuple(t)?new Error(`Contract function contains unsupported Clarity ABI type: ${n}`):isClarityAbiList(t)?new Error(`Contract function contains unsupported Clarity ABI type: ${n}`):new Error(`Contract function contains unsupported Clarity ABI type: ${n}`)}class TransactionSigner{constructor(t){this.transaction=t,this.sigHash=t.signBegin(),this.originDone=!1,this.checkOversign=!0,this.checkOverlap=!0;const n=t.auth.spendingCondition;if(n&&!isSingleSig(n)){if(n.fields.filter(r=>r.contents.type===clarity.StacksMessageType.MessageSignature).length>=n.signaturesRequired)throw new Error("SpendingCondition has more signatures than are expected");n.fields.forEach(r=>{if(r.contents.type===clarity.StacksMessageType.MessageSignature){const s=r.contents,i=nextVerification(this.sigHash,t.auth.authType,n.fee,n.nonce,exports.PubKeyEncoding.Compressed,s);this.sigHash=i.nextSigHash}})}}static createSponsorSigner(t,n){if(t.auth.authType!=exports.AuthType.Sponsored)throw new common.SigningError("Cannot add sponsor to non-sponsored transaction");const r=common.cloneDeep(t);r.setSponsor(n);const s=r.verifyOrigin(),i=new this(r);return i.originDone=!0,i.sigHash=s,i.checkOversign=!0,i.checkOverlap=!0,i}async signOrigin(t){if(this.checkOverlap&&this.originDone)throw new common.SigningError("Cannot sign origin after sponsor key");if(this.transaction.auth===void 0)throw new common.SigningError('"transaction.auth" is undefined');if(this.transaction.auth.spendingCondition===void 0)throw new common.SigningError('"transaction.auth.spendingCondition" is undefined');if(!isSingleSig(this.transaction.auth.spendingCondition)){const n=this.transaction.auth.spendingCondition;if(this.checkOversign&&n.fields.filter(r=>r.contents.type===clarity.StacksMessageType.MessageSignature).length>=n.signaturesRequired)throw new Error("Origin would have too many signatures")}this.sigHash=await this.transaction.signNextOrigin(this.sigHash,t)}appendOrigin(t){if(this.checkOverlap&&this.originDone)throw Error("Cannot append public key to origin after sponsor key");if(this.transaction.auth===void 0)throw new Error('"transaction.auth" is undefined');if(this.transaction.auth.spendingCondition===void 0)throw new Error('"transaction.auth.spendingCondition" is undefined');this.transaction.appendPubkey(t)}async signSponsor(t){if(this.transaction.auth===void 0)throw new common.SigningError('"transaction.auth" is undefined');if(this.transaction.auth.authType!==exports.AuthType.Sponsored)throw new common.SigningError('"transaction.auth.authType" is not AuthType.Sponsored');this.sigHash=await this.transaction.signNextSponsor(this.sigHash,t),this.originDone=!0}getTxInComplete(){return common.cloneDeep(this.transaction)}resume(t){this.transaction=common.cloneDeep(t),this.sigHash=t.signBegin()}}async function getNonce(e,t){const n=new network.StacksMainnet,r=t?t.getAccountApiUrl(e):n.getAccountApiUrl(e),s=await common.fetchPrivate(r);if(!s.ok){let a="";try{a=await s.text()}catch{}throw new Error(`Error fetching nonce. Response ${s.status}: ${s.statusText}. Attempted to fetch ${r} and failed with the message: "${a}"`)}const i=await s.text(),o=JSON.parse(i);return BigInt(o.nonce)}async function estimateTransfer(e,t){if(e.payload.payloadType!==PayloadType.TokenTransfer)throw new Error(`Transaction fee estimation only possible with ${PayloadType[PayloadType.TokenTransfer]} transactions. Invoked with: ${PayloadType[e.payload.payloadType]}`);const r={method:"GET",headers:{Accept:"application/text"}},s=new network.StacksMainnet,i=t?t.getTransferFeeEstimateApiUrl():s.getTransferFeeEstimateApiUrl(),o=await common.fetchPrivate(i,r);if(!o.ok){let d="";try{d=await o.text()}catch{}throw new Error(`Error estimating transaction fee. Response ${o.status}: ${o.statusText}. Attempted to fetch ${i} and failed with the message: "${d}"`)}const a=await o.text(),p=BigInt(e.serialize().byteLength);return BigInt(a)*p}async function estimateContractFunctionCall(e,t){if(e.payload.payloadType!==PayloadType.ContractCall)throw new Error(`Contract call fee estimation only possible with ${PayloadType[PayloadType.ContractCall]} transactions. Invoked with: ${PayloadType[e.payload.payloadType]}`);const r={method:"GET",headers:{Accept:"application/text"}},s=new network.StacksMainnet,i=t?t.getTransferFeeEstimateApiUrl():s.getTransferFeeEstimateApiUrl(),o=await common.fetchPrivate(i,r);if(!o.ok){let d="";try{d=await o.text()}catch{}throw new Error(`Error estimating contract call fee. Response ${o.status}: ${o.statusText}. Attempted to fetch ${i} and failed with the message: "${d}"`)}const a=await o.text(),p=common.intToBigInt(e.serialize().byteLength,!1);return common.intToBigInt(a,!1)*p}async function estimateContractDeploy(e,t){if(e.payload.payloadType!==PayloadType.SmartContract)throw new Error(`Contract deploy fee estimation only possible with ${PayloadType[PayloadType.SmartContract]} transactions. Invoked with: ${PayloadType[e.payload.payloadType]}`);const r={method:"GET",headers:{Accept:"application/text"}},s=new network.StacksMainnet,i=t?t.getTransferFeeEstimateApiUrl():s.getTransferFeeEstimateApiUrl(),o=await common.fetchPrivate(i,r);if(!o.ok){let d="";try{d=await o.text()}catch{}throw new Error(`Error estimating contract deploy fee. Response ${o.status}: ${o.statusText}. Attempted to fetch ${i} and failed with the message: "${d}"`)}const a=await o.text(),p=common.intToBigInt(e.serialize().byteLength,!1);return common.intToBigInt(a,!1)*p}async function sponsorTransaction(e){var t;const n={fee:0,sponsorNonce:0,sponsorAddressHashmode:exports.AddressHashMode.SerializeP2PKH},r=Object.assign(n,e),s=(t=e.network)!=null?t:r.transaction.version===common.TransactionVersion.Mainnet?new network.StacksMainnet:new network.StacksTestnet,i=pubKeyfromPrivKey(r.sponsorPrivateKey);if(e.fee===void 0||e.fee===null){let c=BigInt(0);switch(r.transaction.payload.payloadType){case PayloadType.TokenTransfer:c=await estimateTransfer(r.transaction,s);break;case PayloadType.SmartContract:c=await estimateContractDeploy(r.transaction,s);break;case PayloadType.ContractCall:c=await estimateContractFunctionCall(r.transaction,s);break;default:throw new Error(`Sponsored transactions not supported for transaction type ${PayloadType[r.transaction.payload.payloadType]}`)}r.transaction.setFee(c),r.fee=c}if(e.sponsorNonce===void 0||e.sponsorNonce===null){const c=s.version===common.TransactionVersion.Mainnet?crypto.StacksNetworkVersion.mainnetP2PKH:crypto.StacksNetworkVersion.testnetP2PKH,d=crypto.publicKeyToStxAddress(publicKeyToString(i),c),u=await getNonce(d,s);r.sponsorNonce=u}const o=createSingleSigSpendingCondition(r.sponsorAddressHashmode,publicKeyToString(i),r.sponsorNonce,r.fee);r.transaction.setSponsor(o);const a=createStacksPrivateKey(r.sponsorPrivateKey),p=TransactionSigner.createSponsorSigner(r.transaction,o);return await p.signSponsor(a),p.transaction}function makeStandardSTXPostCondition(e,t,n){return createSTXPostCondition(createStandardPrincipal(e),t,n)}function makeContractSTXPostCondition(e,t,n,r){return createSTXPostCondition(createContractPrincipal(e,t),n,r)}function makeStandardFungiblePostCondition(e,t,n,r){return createFungiblePostCondition(createStandardPrincipal(e),t,n,r)}function makeContractFungiblePostCondition(e,t,n,r,s){return createFungiblePostCondition(createContractPrincipal(e,t),n,r,s)}function makeStandardNonFungiblePostCondition(e,t,n,r){return createNonFungiblePostCondition(createStandardPrincipal(e),t,n,r)}function makeContractNonFungiblePostCondition(e,t,n,r,s){return createNonFungiblePostCondition(createContractPrincipal(e,t),n,r,s)}async function getAbi(e,t,n){const r={method:"GET"},s=n.getAbiApiUrl(e,t),i=await common.fetchPrivate(s,r);if(!i.ok){let o="";try{o=await i.text()}catch{}throw new Error(`Error fetching contract ABI for contract "${t}" at address ${e}. Response ${i.status}: ${i.statusText}. Attempted to fetch ${s} and failed with the message: "${o}"`)}return JSON.parse(await i.text())}var __defProp$1=Object.defineProperty,__getOwnPropSymbols$1=Object.getOwnPropertySymbols,__hasOwnProp$1=Object.prototype.hasOwnProperty,__propIsEnum$1=Object.prototype.propertyIsEnumerable,__defNormalProp$1=(e,t,n)=>t in e?__defProp$1(e,t,{enumerable:!0,configurable:!0,writable:!0,value:n}):e[t]=n,__spreadValues$1=(e,t)=>{for(var n in t||(t={}))__hasOwnProp$1.call(t,n)&&__defNormalProp$1(e,n,t[n]);if(__getOwnPropSymbols$1)for(var n of __getOwnPropSymbols$1(t))__propIsEnum$1.call(t,n)&&__defNormalProp$1(e,n,t[n]);return e};async function makeUnsignedContractCall(e){const t={fee:BigInt(0),nonce:BigInt(0),network:new network.StacksMainnet,postConditionMode:exports.PostConditionMode.Deny,sponsored:!1},n=Object.assign(t,e),r=createContractCallPayload(n.contractAddress,n.contractName,n.functionName,n.functionArgs);if(n==null?void 0:n.validateWithAbi){let c;if(typeof n.validateWithAbi=="boolean")if(n==null?void 0:n.network)c=await getAbi(n.contractAddress,n.contractName,n.network);else throw new Error("Network option must be provided in order to validate with ABI");else c=n.validateWithAbi;validateContractCall(r,c)}let s=null,i=null;"publicKey"in n?s=createSingleSigSpendingCondition(exports.AddressHashMode.SerializeP2PKH,n.publicKey,n.nonce,n.fee):s=createMultiSigSpendingCondition(exports.AddressHashMode.SerializeP2SH,n.numSignatures,n.publicKeys,n.nonce,n.fee),n.sponsored?i=createSponsoredAuth(s):i=createStandardAuth(s);const o=[];n.postConditions&&n.postConditions.length>0&&n.postConditions.forEach(c=>{o.push(c)});const a=createLPList(o),p=new StacksTransaction(n.network.version,i,r,a,n.postConditionMode,n.anchorMode,n.network.chainId);if(e.fee===void 0||e.fee===null){const c=await estimateContractFunctionCall(p,n.network);p.setFee(c)}if(e.nonce===void 0||e.nonce===null){const c=n.network.version===common.TransactionVersion.Mainnet?crypto.StacksNetworkVersion.mainnetP2PKH:crypto.StacksNetworkVersion.testnetP2PKH,d=crypto.c32address(c,common.hexToBytes(p.auth.spendingCondition.signer)),u=await getNonce(d,n.network);p.setNonce(u)}return p}async function makeContractCall(e){if("senderKey"in e){const t=createStacksPrivateKey(e.senderKey),n=publicKeyToString(getPublicKeyFromStacksPrivateKey(t)),r=common.omit(e,"senderKey"),s=await makeUnsignedContractCall(__spreadValues$1({publicKey:n},r));return await new TransactionSigner(s).signOrigin(t),s}else{const t=common.omit(e,"signerKeys"),n=await makeUnsignedContractCall(t),r=new TransactionSigner(n);let s=e.publicKeys;for(const i of e.signerKeys){const o=pubKeyfromPrivKey(i);s=s.filter(a=>a!==common.bytesToHex(o.data)),await r.signOrigin(createStacksPrivateKey(i))}for(const i of s)r.appendOrigin(publicKeyFromBuffer(common.hexToBytes(i)));return n}}async function makeContractDeploy(e){const t={fee:BigInt(0),nonce:BigInt(0),network:new network.StacksMainnet,postConditionMode:exports.PostConditionMode.Deny,sponsored:!1},n=Object.assign(t,e),r=createSmartContractPayload(n.contractName,n.codeBody),s=exports.AddressHashMode.SerializeP2PKH,i=createStacksPrivateKey(n.senderKey),o=getPublicKeyFromStacksPrivateKey(i);let a=null;const p=createSingleSigSpendingCondition(s,publicKeyToString(o),n.nonce,n.fee);n.sponsored?a=createSponsoredAuth(p):a=createStandardAuth(p);const c=[];n.postConditions&&n.postConditions.length>0&&n.postConditions.forEach(l=>{c.push(l)});const d=createLPList(c),u=new StacksTransaction(n.network.version,a,r,d,n.postConditionMode,n.anchorMode,n.network.chainId);if(e.fee===void 0||e.fee===null){const l=await estimateContractDeploy(u,n.network);u.setFee(l)}if(e.nonce===void 0||e.nonce===null){const l=n.network.version===common.TransactionVersion.Mainnet?crypto.StacksNetworkVersion.mainnetP2PKH:crypto.StacksNetworkVersion.testnetP2PKH,y=crypto.publicKeyToStxAddress(publicKeyToString(o),l),g=await getNonce(y,n.network);u.setNonce(g)}return n.senderKey&&await new TransactionSigner(u).signOrigin(i),u}var __defProp=Object.defineProperty,__getOwnPropSymbols=Object.getOwnPropertySymbols,__hasOwnProp=Object.prototype.hasOwnProperty,__propIsEnum=Object.prototype.propertyIsEnumerable,__defNormalProp=(e,t,n)=>t in e?__defProp(e,t,{enumerable:!0,configurable:!0,writable:!0,value:n}):e[t]=n,__spreadValues=(e,t)=>{for(var n in t||(t={}))__hasOwnProp.call(t,n)&&__defNormalProp(e,n,t[n]);if(__getOwnPropSymbols)for(var n of __getOwnPropSymbols(t))__propIsEnum.call(t,n)&&__defNormalProp(e,n,t[n]);return e};async function makeUnsignedSTXTokenTransfer(e,t){const n={fee:BigInt(0),nonce:BigInt(0),network:new network.StacksMainnet,postConditionMode:exports.PostConditionMode.Deny,memo:"",sponsored:!1},r=Object.assign(n,e),s=createTokenTransferPayload(r.recipient,r.amount,r.memo);let i=null,o=null;"publicKey"in r?o=createSingleSigSpendingCondition(exports.AddressHashMode.SerializeP2PKH,r.publicKey,r.nonce,r.fee):o=createMultiSigSpendingCondition(exports.AddressHashMode.SerializeP2SH,r.numSignatures,r.publicKeys,r.nonce,r.fee),r.sponsored?i=createSponsoredAuth(o):i=createStandardAuth(o);const a=[];r.postConditions&&r.postConditions.length>0&&r.postConditions.forEach(d=>{a.push(d)});const p=createLPList(a),c=new StacksTransaction(r.network.version,i,s,p,r.postConditionMode,r.anchorMode,r.network.chainId);if(t)c.setFee(0),c.setNonce(0);else{if(e.fee===void 0||e.fee===null){const d=await estimateTransfer(c,r.network);c.setFee(d)}if(e.nonce===void 0||e.nonce===null){const d=r.network.version===common.TransactionVersion.Mainnet?crypto.StacksNetworkVersion.mainnetP2PKH:crypto.StacksNetworkVersion.testnetP2PKH,u=crypto.c32address(d,common.hexToBytes(c.auth.spendingCondition.signer)),l=await getNonce(u,r.network);c.setNonce(l)}}return c}async function makeSTXTokenTransfer(e){if("senderKey"in e){const t=createStacksPrivateKey(e.senderKey),n=publicKeyToString(getPublicKeyFromStacksPrivateKey(t)),r=common.omit(e,"senderKey"),s=await makeUnsignedSTXTokenTransfer(__spreadValues({publicKey:n},r));return await new TransactionSigner(s).signOrigin(t),s}else{const t=common.omit(e,"signerKeys"),n=await makeUnsignedSTXTokenTransfer(t),r=new TransactionSigner(n);let s=e.publicKeys;for(const i of e.signerKeys){const o=pubKeyfromPrivKey(i);s=s.filter(a=>a!==common.bytesToHex(o.data)),await r.signOrigin(createStacksPrivateKey(i))}for(const i of s)r.appendOrigin(publicKeyFromBuffer(common.hexToBytes(i)));return n}}function with0x(e){return e.startsWith("0x")?e:`0x${e}`}const validateTxId=e=>{if(e==="success")return!0;const t=with0x(e).toLowerCase();return t.length!==66?!1:with0x(BigInt(t).toString(16).padStart(64,"0"))===t};async function broadcastTransaction(e,t,n){return broadcastRawTransaction(e.serialize(),t.getBroadcastApiUrl(),n)}async function broadcastRawTransaction(e,t,n){const r={method:"POST",headers:{"Content-Type":n?"application/json":"application/octet-stream"},body:n?JSON.stringify({tx:common.bytesToHex(e),attachment:common.bytesToHex(n)}):e},s=await common.fetchPrivate(t,r);if(!s.ok)try{return await s.json()}catch(a){throw Error(`Failed to broadcast transaction: ${a.message}`)}const i=await s.text(),o=i.replace(/["]+/g,"");if(validateTxId(o))return{txid:o};throw new Error(i)}Object.defineProperty(exports,"callReadOnlyFunction",{enumerable:!0,get:function(){return api.callReadOnlyFunction}}),exports.CLARITY_INT_BYTE_SIZE=CLARITY_INT_BYTE_SIZE,exports.DEFAULT_CORE_NODE_API_URL=DEFAULT_CORE_NODE_API_URL,exports.DEFAULT_TRANSACTION_VERSION=DEFAULT_TRANSACTION_VERSION,exports.Deserializable=Deserializable,exports.TransactionSigner=TransactionSigner,exports.abiFunctionToString=abiFunctionToString,exports.addressFromHashMode=addressFromHashMode,exports.addressFromPublicKeys=addressFromPublicKeys,exports.addressFromVersionHash=addressFromVersionHash,exports.addressHashModeToVersion=addressHashModeToVersion,exports.broadcastRawTransaction=broadcastRawTransaction,exports.broadcastTransaction=broadcastTransaction,exports.codeBodyString=codeBodyString,exports.compressPublicKey=compressPublicKey,exports.createAssetInfo=createAssetInfo,exports.createContractPrincipal=createContractPrincipal,exports.createEmptyAddress=createEmptyAddress,exports.createFungiblePostCondition=createFungiblePostCondition,exports.createLPList=createLPList,exports.createMemoString=createMemoString,exports.createMessageSignature=createMessageSignature,exports.createMultiSigSpendingCondition=createMultiSigSpendingCondition,exports.createNonFungiblePostCondition=createNonFungiblePostCondition,exports.createSTXPostCondition=createSTXPostCondition,exports.createSingleSigSpendingCondition=createSingleSigSpendingCondition,exports.createSponsoredAuth=createSponsoredAuth,exports.createStacksPrivateKey=createStacksPrivateKey,exports.createStacksPublicKey=createStacksPublicKey,exports.createStandardAuth=createStandardAuth,exports.createStandardPrincipal=createStandardPrincipal,exports.createTransactionAuthField=createTransactionAuthField,exports.deserializeAssetInfo=deserializeAssetInfo,exports.deserializeAuthorization=deserializeAuthorization,exports.deserializeLPList=deserializeLPList,exports.deserializeMemoString=deserializeMemoString,exports.deserializeMessageSignature=deserializeMessageSignature,exports.deserializeMultiSigSpendingCondition=deserializeMultiSigSpendingCondition,exports.deserializePostCondition=deserializePostCondition,exports.deserializePrincipal=deserializePrincipal,exports.deserializePublicKey=deserializePublicKey,exports.deserializeSingleSigSpendingCondition=deserializeSingleSigSpendingCondition,exports.deserializeSpendingCondition=deserializeSpendingCondition,exports.deserializeStacksMessage=deserializeStacksMessage,exports.deserializeTransaction=deserializeTransaction,exports.deserializeTransactionAuthField=deserializeTransactionAuthField,exports.emptyMessageSignature=emptyMessageSignature,exports.encodeClarityValue=encodeClarityValue,exports.estimateContractDeploy=estimateContractDeploy,exports.estimateContractFunctionCall=estimateContractFunctionCall,exports.estimateTransfer=estimateTransfer,exports.getAbi=getAbi,exports.getFee=getFee,exports.getNonce=getNonce,exports.getPublicKeyFromStacksPrivateKey=getPublicKeyFromStacksPrivateKey,exports.getSignatureRecoveryParam=getSignatureRecoveryParam,exports.getTypeString=getTypeString,exports.getTypeUnion=getTypeUnion,exports.intoInitialSighashAuth=intoInitialSighashAuth,exports.isClarityAbiBuffer=isClarityAbiBuffer,exports.isClarityAbiList=isClarityAbiList,exports.isClarityAbiOptional=isClarityAbiOptional,exports.isClarityAbiPrimitive=isClarityAbiPrimitive,exports.isClarityAbiResponse=isClarityAbiResponse,exports.isClarityAbiStringAscii=isClarityAbiStringAscii,exports.isClarityAbiStringUtf8=isClarityAbiStringUtf8,exports.isClarityAbiTuple=isClarityAbiTuple,exports.isCompressed=isCompressed,exports.isPrivateKeyCompressed=isPrivateKeyCompressed,exports.isSingleSig=isSingleSig,exports.leftPadHex=leftPadHex,exports.leftPadHexToLength=leftPadHexToLength,exports.makeContractCall=makeContractCall,exports.makeContractDeploy=makeContractDeploy,exports.makeContractFungiblePostCondition=makeContractFungiblePostCondition,exports.makeContractNonFungiblePostCondition=makeContractNonFungiblePostCondition,exports.makeContractSTXPostCondition=makeContractSTXPostCondition,exports.makeRandomPrivKey=makeRandomPrivKey,exports.makeSTXTokenTransfer=makeSTXTokenTransfer,exports.makeSigHashPreSign=makeSigHashPreSign,exports.makeStandardFungiblePostCondition=makeStandardFungiblePostCondition,exports.makeStandardNonFungiblePostCondition=makeStandardNonFungiblePostCondition,exports.makeStandardSTXPostCondition=makeStandardSTXPostCondition,exports.makeUnsignedContractCall=makeUnsignedContractCall,exports.makeUnsignedSTXTokenTransfer=makeUnsignedSTXTokenTransfer,exports.nextSignature=nextSignature,exports.nextVerification=nextVerification,exports.parseAssetInfoString=parseAssetInfoString,exports.parsePrincipalString=parsePrincipalString,exports.parseReadOnlyResponse=parseReadOnlyResponse,exports.parseRecoverableSignature=parseRecoverableSignature,exports.parseToCV=parseToCV,exports.privateKeyToString=privateKeyToString,exports.pubKeyfromPrivKey=pubKeyfromPrivKey,exports.publicKeyFromBuffer=publicKeyFromBuffer,exports.publicKeyFromSignature=publicKeyFromSignature,exports.publicKeyToString=publicKeyToString,exports.rightPadHexToLength=rightPadHexToLength,exports.serializeAssetInfo=serializeAssetInfo,exports.serializeAuthorization=serializeAuthorization,exports.serializeLPList=serializeLPList,exports.serializeMemoString=serializeMemoString,exports.serializeMessageSignature=serializeMessageSignature,exports.serializeMultiSigSpendingCondition=serializeMultiSigSpendingCondition,exports.serializePostCondition=serializePostCondition,exports.serializePrincipal=serializePrincipal,exports.serializePublicKey=serializePublicKey,exports.serializeSingleSigSpendingCondition=serializeSingleSigSpendingCondition,exports.serializeSpendingCondition=serializeSpendingCondition,exports.serializeStacksMessage=serializeStacksMessage,exports.serializeTransactionAuthField=serializeTransactionAuthField,exports.setFee=setFee,exports.setNonce=setNonce,exports.setSponsor=setSponsor,exports.setSponsorNonce=setSponsorNonce,exports.signWithKey=signWithKey,exports.sponsorTransaction=sponsorTransaction,exports.txidFromData=txidFromData,exports.validateContractCall=validateContractCall,exports.verifyOrigin=verifyOrigin;
