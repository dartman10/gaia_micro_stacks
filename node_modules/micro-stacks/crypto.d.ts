import * as crypto from 'crypto';
export { getPublicKey } from '@noble/secp256k1';

declare type NodeCryptoCreateHash = typeof crypto.createHash;
declare type NodeCryptoCreateHmac = typeof crypto.createHmac;
interface Sha2Hash {
    digest(data: Uint8Array, algorithm?: 'sha256' | 'sha512'): Promise<Uint8Array>;
}
interface Hmac {
    digest(key: Uint8Array, data: Uint8Array): Promise<Uint8Array>;
}
interface EncryptECIESOptions {
    publicKey: string;
    content: Uint8Array;
    wasString: boolean;
    cipherTextEncoding?: CipherTextEncoding;
}
interface DecryptECIESOptions {
    privateKey: string;
    cipherObject: CipherObject;
}
/**
 * Controls how the encrypted data buffer will be encoded as a string in the JSON payload.
 * Options:
 *    `hex` -- the legacy default, file size increase 100% (2x).
 *    `base64` -- file size increased ~33%.
 * @ignore
 */
declare type CipherTextEncoding = 'hex' | 'base64';
declare type CipherObject = {
    iv: string;
    ephemeralPK: string;
    cipherText: string;
    /** If undefined then hex encoding is used for the `cipherText` string. */
    cipherTextEncoding?: CipherTextEncoding;
    mac: string;
    wasString: boolean;
};
declare type SignedCipherObject = {
    /** Hex encoded DER signature (up to 144 chars) */
    signature: string;
    /** Hex encoded public key (66 char length) */
    publicKey: string;
    /** The stringified json of a `CipherObject` */
    cipherText: string;
};
interface EncryptionOptions {
    /**
     * If set to `true` the data is signed using ECDSA on SHA256 hashes with the user's
     * app private key. If a string is specified, it is used as the private key instead
     * of the user's app private key.
     * @default false
     */
    sign?: boolean | string;
    /**
     * String encoding format for the cipherText buffer.
     * Currently defaults to 'hex' for legacy backwards-compatibility.
     * Only used if the `encrypt` option is also used.
     * Note: in the future this should default to 'base64' for the significant
     * file size reduction.
     */
    cipherTextEncoding?: CipherTextEncoding;
    /**
     * Specifies if the original unencrypted content is a ASCII or UTF-8 string.
     * For example stringified JSON.
     * If true, then when the ciphertext is decrypted, it will be returned as
     * a `string` type variable, otherwise will be returned as a Buffer.
     */
    wasString?: boolean;
}
/**
 * Specify encryption options, and whether to sign the ciphertext.
 */
interface EncryptContentOptions extends EncryptionOptions {
    /**
     * Encrypt the data with this key.
     */
    publicKey?: string;
    /**
     * Encrypt the data with the public key corresponding to the supplied private key
     */
    privateKey?: string;
}

/**
 * Calculate the AES-CBC ciphertext output byte length a given input length.
 * AES has a fixed block size of 16-bytes regardless key size.
 * @ignore
 */
declare function getAesCbcOutputLength(inputByteLength: number): number;
/**
 * Calculate the base64 encoded string length for a given input length.
 * This is equivalent to the byte length when the string is ASCII or UTF8-8
 * encoded.
 * @param inputByteLength
 */
declare function getBase64OutputLength(inputByteLength: number): number;
/**
 * Fast function that determines the final ASCII string byte length of the
 * JSON stringified ECIES encrypted payload.
 * @ignore
 */
/**
 * Get details about the JSON envelope size overhead for ciphertext payloads.
 * @ignore
 */
declare function getCipherObjectWrapper(opts: {
    wasString: boolean;
    cipherTextEncoding: CipherTextEncoding;
}): {
    /** The stringified JSON string of an empty `CipherObject`. */
    payloadShell: string;
    /** Total string length of all the `CipherObject` values that always have constant lengths. */
    payloadValuesLength: number;
};
/**
 * Get details about the JSON envelope size overhead for signed ciphertext payloads.
 * @param payloadShell - The JSON stringified empty `CipherObject`
 * @ignore
 */
declare function getSignedCipherObjectWrapper(payloadShell: string): {
    /** The stringified JSON string of an empty `SignedCipherObject`. */
    signedPayloadValuesLength: number;
    /** Total string length of all the `SignedCipherObject` values
     * that always have constant lengths */
    signedPayloadShell: string;
};
declare function eciesGetJsonStringLength(opts: {
    contentLength: number;
    wasString: boolean;
    sign: boolean;
    cipherTextEncoding: CipherTextEncoding;
}): number;

interface Ripemd160Digest {
    digest(data: Uint8Array): Uint8Array;
}
declare class Ripemd160PolyfillDigest implements Ripemd160Digest {
    digest(data: Uint8Array): Uint8Array;
}
declare function createHashRipemd160(): Ripemd160PolyfillDigest;
declare function hashRipemd160(data: Uint8Array): Uint8Array;

declare function ripemd160(message: Uint8Array): Uint8Array;
declare function ripemd160(message: string): string;

declare function sharedSecretToKeys(sharedSecret: Uint8Array): {
    encryptionKey: Uint8Array;
    hmacKey: Uint8Array;
};

declare function getRandomBytes(size?: number): Uint8Array;

declare const isCompressedPublicKey: (bytes: Uint8Array) => boolean;
declare const derivePublicKey: (pubKey: Uint8Array, il: Uint8Array) => Uint8Array;
declare const derivePrivateKey: (privateKey: Uint8Array, il: Uint8Array) => Uint8Array;

declare enum StacksNetworkVersion {
    mainnetP2PKH = 22,
    mainnetP2SH = 20,
    testnetP2PKH = 26,
    testnetP2SH = 21
}
declare const BITCOIN_TO_STACKS_NETWORK_VERSION: Record<number, number>;
declare const STACKS_TO_BITCOIN_NETWORK_VERSION: Record<number, number>;
/**
 * Make a c32check address with the given version and hash160
 * The only difference between a c32check string and c32 address
 * is that the letter 'S' is pre-pended.
 * @param version - the address version number
 * @param hash160 - the hash160 to encode
 * @returns the address
 */
declare function c32address(version: StacksNetworkVersion, hash160: Uint8Array): string;
/**
 * Convert a base58check address to a c32check address.
 * Try to convert the version number if one is not given.
 * @param b58check - the base58check encoded address
 * @param version - the version number, if not inferred from the address
 * @returns the c32 address with the semantically-equivalent c32 version number
 */
declare function b58ToC32(b58check: string): string;
/**
 * Convert a c32check address to a base58check address.
 * @param c32string - the c32check address
 * @returns the base58 address with the semantically-equivalent bitcoin version number
 */
declare function c32ToB58(c32string: string): string;
/**
 * Decode a c32 address into its version and hash160
 * @param c32addr - the c32check-encoded address
 * @returns a tuple with the version and hash160
 */
declare function c32addressDecode(c32addr: string): [number, Uint8Array];
/**
 * Decode a c32check string back into its version and data payload.  This is
 * a lot like how base58check works in Bitcoin-land, but this algorithm uses
 * the z-base-32 alphabet instead of the base58 alphabet.  The algorithm
 * is as follows:
 * * extract the version, data, and checksum
 * * verify the checksum matches c32checksum(version + data)
 * * return data
 * @param c32data - the c32check-encoded string
 * @returns [version, data]. Throws an exception if the checksum does not match.
 */
declare function c32checkDecode(c32data: string): [number, Uint8Array];
/**
 * Normalize a c32 string
 * @param c32input - the c32-encoded input string
 * @returns the canonical representation of the c32 input string
 */
declare function c32normalize(c32input: string): string;
/**
 * Decode a c32 string back into bytes.  Note that the c32 input
 * string is assumed to be big-endian (and the resulting byte array will
 * be as well).
 * @param c32input - the c32-encoded input to decode
 */
declare function c32decode(c32input: string): Uint8Array;
declare function validateStacksAddress(stacksAddress: string): boolean;

declare enum BitcoinNetworkVersion {
    mainnetP2PKH = 0,
    mainnetP2SH = 5,
    testnetP2PKH = 111,
    testnetP2SH = 196
}

declare function base58checkEncode(hash: Uint8Array, version: BitcoinNetworkVersion): string;
/**
 * Decode a b58 address into its version and hash160.
 */
declare function base58checkDecode(address: string): {
    hash: Uint8Array;
    version: number;
};

declare function privateKeyToStxAddress(privateKey: string | Uint8Array, addressVersion?: StacksNetworkVersion, isCompressed?: boolean): string;
declare function publicKeyToStxAddress(publicKey: string | Uint8Array, addressVersion?: StacksNetworkVersion): string;
declare function privateKeyToBase58Address(privateKey: string): string;
declare function publicKeyToBase58Address(publicKey: string | Uint8Array): string;
declare const hashP2PKH: (input: Uint8Array) => string;
declare const hashP2WPKH: (input: Uint8Array) => string;
declare const hashP2WSH: (numSigs: number, pubKeys: Uint8Array[]) => string;
declare const hashP2SH: (numSigs: number, pubKeys: Uint8Array[]) => string;

/**
 * Sign content using ECDSA
 *
 * @param {String} privateKey - secp256k1 private key hex string
 * @param {Object} content - content to sign
 * @return {Object} contains:
 * signature - Hex encoded DER signature
 * public key - Hex encoded private string taken from privateKey
 * @private
 * @ignore
 */
interface SignECDSA {
    privateKey: string;
    contents: string | ArrayBuffer | Uint8Array;
}
interface SignedResponse {
    signature: string;
    publicKey: string;
}
declare function signECDSA(params: SignECDSA): Promise<SignedResponse>;
/**
 * Verify content using ECDSA
 * @param {String | Buffer} content - Content to verify was signed
 * @param {String} publicKey - secp256k1 private key hex string
 * @param {String} signature - Hex encoded DER signature
 * @param {Boolean} strict - whether a signature s should be no more than 1/2 prime order. true makes signatures compatible with libsecp256k1, false makes signatures compatible with openssl
 * @return {Boolean} returns true when signature matches publickey + content, false if not
 * @private
 * @ignore
 */
interface VerifyESDSA {
    contents: string | ArrayBuffer | Uint8Array;
    publicKey: string;
    signature: string;
}
declare function verifyECDSA(params: VerifyESDSA, strict?: boolean): boolean;

/**
 * Encrypt content to elliptic curve publicKey using ECIES
 * @return Object containing:
 *  iv (initialization vector, hex encoding),
 *  cipherText (cipher text either hex or base64 encoded),
 *  mac (message authentication code, hex encoded),
 *  ephemeral public key (hex encoded),
 *  wasString (boolean indicating with or not to return a buffer or string on decrypt)
 * @see https://cryptobook.nakov.com/asymmetric-key-ciphers/ecies-public-key-encryption
 */
declare function encryptECIES(options: EncryptECIESOptions): Promise<CipherObject>;

declare function equalConstTime(b1: Uint8Array, b2: Uint8Array): boolean;
/**
 * Decrypt content encrypted using ECIES
 *  * @param options {DecryptECIESOptions}
 *  iv (initialization vector), cipherText (cipher text),
 *  mac (message authentication code), ephemeralPublicKey
 *  wasString (boolean indicating with or not to return a byte array or string on decrypt)
 * @return plaintext
 * @throws {Error} if unable to decrypt
 * @private
 * @ignore
 */
declare function decryptECIES(options: DecryptECIESOptions): Promise<Uint8Array | string>;

/**
 * Decrypts data encrypted with `encryptContent` with the
 * transit private key.
 * @param content - encrypted content.
 * @param {Object} [options=null] - options object
 * @param {String} options.privateKey - the hex string of the ECDSA private
 * key to use for decryption. If not provided, will use user's appPrivateKey.
 * @return decrypted content.
 */
declare function decryptContent(content: string, options: {
    privateKey: string;
}): Promise<string | Uint8Array>;

declare function encryptContent(content: string | Uint8Array, options: EncryptContentOptions): Promise<string>;

interface TokenInterface {
    header: {
        [key: string]: string | Json;
        alg?: any;
        typ?: any;
    };
    payload: {
        [key: string]: Json;
        iss?: any | string;
        jti?: any | string;
        iat?: any | string | number;
        exp?: any | string | number;
    } | string;
    signature: string;
}
interface TokenInterfaceEncodedObject {
    header: string[];
    payload: string;
    signature: string;
}
declare type Json = string | number | boolean | null | {
    [property: string]: Json;
} | Json[];
interface SignedToken {
    header: string[];
    payload: string;
    signature: string[];
}

declare class TokenSigner {
    tokenType: string;
    rawPrivateKey: string;
    constructor(signingAlgorithm: string | undefined, rawPrivateKey: string);
    header(header?: {}): {
        typ: string;
        alg: string;
    };
    sign(payload: Json): Promise<string>;
    sign(payload: Json, expanded: true, customHeader?: Json): Promise<SignedToken>;
    sign(payload: Json, expanded: false, customHeader?: Json): Promise<string>;
    createWithSignedHash(payload: Json, expanded: boolean, header: {
        typ: string;
        alg: string;
    }, signingInput: string, signingInputHash: Uint8Array): Promise<SignedToken | string>;
}

declare class TokenVerifier {
    tokenType: string;
    rawPublicKey: string;
    constructor(signingAlgorithm: string, rawPublicKey: string);
    verify(token: string | SignedToken, strict?: boolean): boolean;
    verifyCompact(token: string, strict?: boolean): boolean;
    verifyExpanded(token: SignedToken, strict?: boolean): boolean;
}

declare function decodeToken(token: string | TokenInterface | TokenInterfaceEncodedObject): TokenInterface | undefined;

declare function createSigningInput(payload: Json, header: Json): string;

declare function createUnsecuredToken(payload: Json): string;

export { BITCOIN_TO_STACKS_NETWORK_VERSION, CipherObject, CipherTextEncoding, DecryptECIESOptions, EncryptContentOptions, EncryptECIESOptions, EncryptionOptions, Hmac, Json, NodeCryptoCreateHash, NodeCryptoCreateHmac, Ripemd160Digest, Ripemd160PolyfillDigest, STACKS_TO_BITCOIN_NETWORK_VERSION, Sha2Hash, SignedCipherObject, SignedToken, StacksNetworkVersion, TokenInterface, TokenSigner, TokenVerifier, b58ToC32, base58checkDecode, base58checkEncode, c32ToB58, c32address, c32addressDecode, c32checkDecode, c32decode, c32normalize, createHashRipemd160, createSigningInput, createUnsecuredToken, decodeToken, decryptContent, decryptECIES, derivePrivateKey, derivePublicKey, eciesGetJsonStringLength, encryptContent, encryptECIES, equalConstTime, getAesCbcOutputLength, getBase64OutputLength, getCipherObjectWrapper, getRandomBytes, getSignedCipherObjectWrapper, hashP2PKH, hashP2SH, hashP2WPKH, hashP2WSH, hashRipemd160, isCompressedPublicKey, privateKeyToBase58Address, privateKeyToStxAddress, publicKeyToBase58Address, publicKeyToStxAddress, ripemd160, sharedSecretToKeys, signECDSA, validateStacksAddress, verifyECDSA };
