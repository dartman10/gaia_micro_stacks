"use strict";Object.defineProperty(exports,"__esModule",{value:!0});var common=require("micro-stacks/common");class WebCryptoAesCipher{constructor(e){this.webCrypto=e}async encrypt(e,r,s,n){let c,o;if(e==="aes-128-cbc")c="AES-CBC",o=128;else if(e==="aes-256-cbc")c="AES-CBC",o=256;else throw new Error(`Unsupported cipher algorithm "${e}"`);const p=await this.webCrypto.subtle.importKey("raw",r,{name:c,length:o},!1,["encrypt"]),a=await this.webCrypto.subtle.encrypt({name:c,iv:s},p,n);return new Uint8Array(a)}async decrypt(e,r,s,n){let c,o;if(e==="aes-128-cbc")c="AES-CBC",o=128;else if(e==="aes-256-cbc")c="AES-CBC",o=256;else throw new Error(`Unsupported cipher algorithm "${e}"`);const p=await this.webCrypto.subtle.importKey("raw",r,{name:c,length:o},!1,["decrypt"]),a=await this.webCrypto.subtle.decrypt({name:c,iv:s},p,n);return new Uint8Array(a)}}class NodeCryptoAesCipher{constructor(e,r){this.createCipher=e,this.createDecipher=r}async encrypt(e,r,s,n){if(e!=="aes-128-cbc"&&e!=="aes-256-cbc")throw new Error(`Unsupported cipher algorithm "${e}"`);const c=this.createCipher(e,r,s),o=common.concatByteArrays([c.update(n),c.final()]);return Promise.resolve(o)}async decrypt(e,r,s,n){if(e!=="aes-128-cbc"&&e!=="aes-256-cbc")throw new Error(`Unsupported cipher algorithm "${e}"`);const c=this.createDecipher(e,r,s),o=common.concatByteArrays([c.update(n),c.final()]);return Promise.resolve(o)}}function isSubtleCryptoAvailable(){return typeof crypto!="undefined"&&typeof crypto.subtle!="undefined"}function isNodeCryptoAvailable(t){try{if(!require.resolve("crypto"))return!1;const r=require("crypto");return r?t?t(r):!0:!1}catch{return!1}}const NO_CRYPTO_LIB='Crypto lib not found. Either the WebCrypto "crypto.subtle" or Node.js "crypto" module must be available.';async function getCryptoLib(){if(isSubtleCryptoAvailable())return{lib:crypto,name:"webCrypto"};try{return{lib:require("crypto"),name:"nodeCrypto"}}catch{throw new Error(NO_CRYPTO_LIB)}}async function createCipher(){const t=await getCryptoLib();return t.name==="webCrypto"?new WebCryptoAesCipher(t.lib):new NodeCryptoAesCipher(t.lib.createCipheriv,t.lib.createDecipheriv)}async function aes256CbcEncrypt(t,e,r){return(await createCipher()).encrypt("aes-256-cbc",e,t,r)}async function aes256CbcDecrypt(t,e,r){return(await createCipher()).decrypt("aes-256-cbc",e,t,r)}async function aes128CbcEncrypt(t,e,r){return(await createCipher()).encrypt("aes-128-cbc",e,t,r)}async function aes128CbcDecrypt(t,e,r){return(await createCipher()).decrypt("aes-128-cbc",e,t,r)}exports.NO_CRYPTO_LIB=NO_CRYPTO_LIB,exports.aes128CbcDecrypt=aes128CbcDecrypt,exports.aes128CbcEncrypt=aes128CbcEncrypt,exports.aes256CbcDecrypt=aes256CbcDecrypt,exports.aes256CbcEncrypt=aes256CbcEncrypt,exports.getCryptoLib=getCryptoLib,exports.isNodeCryptoAvailable=isNodeCryptoAvailable,exports.isSubtleCryptoAvailable=isSubtleCryptoAvailable;
