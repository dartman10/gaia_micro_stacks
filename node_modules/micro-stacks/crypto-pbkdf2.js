"use strict";Object.defineProperty(exports,"__esModule",{value:!0});var cryptoAes=require("micro-stacks/crypto-aes"),common=require("micro-stacks/common"),pbkdf2=require("@noble/hashes/pbkdf2"),sha512=require("@noble/hashes/sha512");class NodeCryptoPbkdf2{constructor(e){this.nodePbkdf2=e}async derive(e,s,o,a,r){if(r!=="sha512"&&r!=="sha256")throw new Error(`Unsupported digest "${r}" for Pbkdf2`);return new Promise((n,c)=>{this.nodePbkdf2(e,s,o,a,r,(i,b)=>{i&&c(i),n(b)})})}}class WebCryptoPbkdf2{constructor(e){this.webCrypto=e}async derive(e,s,o,a,r){let n;if(r==="sha256")n="SHA-256";else if(r==="sha512")n="SHA-512";else throw new Error(`Unsupported Pbkdf2 digest algorithm "${r}"`);const c=await this.webCrypto.subtle.importKey("raw",common.utf8ToBytes(e),"PBKDF2",!1,["deriveBits"]),i=await this.webCrypto.subtle.deriveBits({name:"PBKDF2",salt:s,iterations:o,hash:{name:n}},c,a*8);return new Uint8Array(i)}}async function createPbkdf2(){try{const t=await cryptoAes.getCryptoLib();return t.name==="webCrypto"?new WebCryptoPbkdf2(t.lib):new NodeCryptoPbkdf2(t.lib.pbkdf2)}catch{return{derive(e,s,o,a,r="sha512"){return pbkdf2.pbkdf2Async(sha512.sha512,common.ensureUint8Array(common.utf8ToBytes(e)),common.ensureUint8Array(s),{c:o,dkLen:a})}}}}exports.createPbkdf2=createPbkdf2;
