import { BufferReader, IntegerType, TransactionVersion, ChainID } from 'micro-stacks/common';
import { StacksMessageType, PostConditionPrincipal, AssetInfo, ClarityValue, Address, LengthPrefixedString, StandardPrincipal, ContractPrincipal, PrincipalCV, ClarityAbiType, ClarityAbiTypePrimitive, ClarityAbiTypeBuffer, ClarityAbiTypeStringAscii, ClarityAbiTypeStringUtf8, ClarityAbiTypeResponse, ClarityAbiTypeOptional, ClarityAbiTypeTuple, ClarityAbiTypeList, ClarityAbiTypeUnion, ClarityAbiFunction, ClarityAbi } from 'micro-stacks/clarity';
import { StacksNetworkVersion } from 'micro-stacks/crypto';
import { StacksNetwork } from 'micro-stacks/network';
export { callReadOnlyFunction } from 'micro-stacks/api';

declare const CLARITY_INT_BYTE_SIZE = 16;
declare const DEFAULT_CORE_NODE_API_URL = "https://stacks-node-api.mainnet.stacks.co";
/**
 * How a transaction should get appended to the Stacks blockchain.
 *
 * In the Stacks blockchain, there are two kinds of blocks: anchored
 * blocks and streaming microblocks. A transactions AnchorMode specifies
 * which kind of block it should be included in.
 *
 * For more information about the kinds of Stacks blocks and the various
 * AnchorModes, check out {@link https://github.com/stacksgov/sips/blob/main/sips/sip-001/sip-001-burn-election.md SIP 001} and
 * {@link https://github.com/stacksgov/sips/blob/main/sips/sip-005/sip-005-blocks-and-transactions.md SIP 005}
 */
declare enum AnchorMode {
    /** The transaction MUST be included in an anchored block */
    OnChainOnly = 1,
    /** The transaction MUST be included in a microblock */
    OffChainOnly = 2,
    /** The leader can choose where to include the transaction (anchored block or microblock)*/
    Any = 3
}
declare const DEFAULT_TRANSACTION_VERSION = TransactionVersion.Mainnet;
declare enum PostConditionMode {
    Allow = 1,
    Deny = 2
}
declare enum PostConditionType {
    STX = 0,
    Fungible = 1,
    NonFungible = 2
}
declare enum AuthType {
    Standard = 4,
    Sponsored = 5
}
declare enum AddressHashMode {
    /** SingleSigHashMode - hash160(public-key), same as bitcoin's p2pkh */
    SerializeP2PKH = 0,
    /** MultiSigHashMode - hash160(multisig-redeem-script), same as bitcoin's multisig p2sh */
    SerializeP2SH = 1,
    /** SingleSigHashMode - hash160(segwit-program-00(p2pkh)), same as bitcoin's p2sh-p2wpkh */
    SerializeP2WPKH = 2,
    /** MultiSigHashMode - hash160(segwit-program-00(public-keys)), same as bitcoin's p2sh-p2wsh */
    SerializeP2WSH = 3
}
declare type SingleSigHashMode = AddressHashMode.SerializeP2PKH | AddressHashMode.SerializeP2WPKH;
declare type MultiSigHashMode = AddressHashMode.SerializeP2SH | AddressHashMode.SerializeP2WSH;
declare enum AddressVersion {
    MainnetSingleSig = 22,
    MainnetMultiSig = 20,
    TestnetSingleSig = 26,
    TestnetMultiSig = 21
}
declare enum PubKeyEncoding {
    Compressed = 0,
    Uncompressed = 1
}
declare enum FungibleConditionCode {
    Equal = 1,
    Greater = 2,
    GreaterEqual = 3,
    Less = 4,
    LessEqual = 5
}
declare enum NonFungibleConditionCode {
    DoesNotOwn = 16,
    Owns = 17
}
declare enum AssetType {
    STX = 0,
    Fungible = 1,
    NonFungible = 2
}
declare enum TxRejectedReason {
    Serialization = "Serialization",
    Deserialization = "Deserialization",
    SignatureValidation = "SignatureValidation",
    FeeTooLow = "FeeTooLow",
    BadNonce = "BadNonce",
    NotEnoughFunds = "NotEnoughFunds",
    NoSuchContract = "NoSuchContract",
    NoSuchPublicFunction = "NoSuchPublicFunction",
    BadFunctionArgument = "BadFunctionArgument",
    ContractAlreadyExists = "ContractAlreadyExists",
    PoisonMicroblocksDoNotConflict = "PoisonMicroblocksDoNotConflict",
    PoisonMicroblockHasUnknownPubKeyHash = "PoisonMicroblockHasUnknownPubKeyHash",
    PoisonMicroblockIsInvalid = "PoisonMicroblockIsInvalid",
    BadAddressVersionByte = "BadAddressVersionByte",
    NoCoinbaseViaMempool = "NoCoinbaseViaMempool",
    ServerFailureNoSuchChainTip = "ServerFailureNoSuchChainTip",
    ServerFailureDatabase = "ServerFailureDatabase",
    ServerFailureOther = "ServerFailureOther"
}

interface StacksPublicKey {
    readonly type: StacksMessageType.PublicKey;
    readonly data: Uint8Array;
}
declare function createStacksPublicKey(key: string): StacksPublicKey;
declare function publicKeyFromSignature(message: string, messageSignature: MessageSignature, pubKeyEncoding?: PubKeyEncoding): string;
declare function publicKeyFromBuffer(data: Uint8Array): StacksPublicKey;
declare function publicKeyToString(key: StacksPublicKey): string;
declare function isCompressed(key: StacksPublicKey): boolean;
declare function isPrivateKeyCompressed(key: string | Uint8Array): boolean;
declare function serializePublicKey(key: StacksPublicKey): Uint8Array;
declare function pubKeyfromPrivKey(privateKey: string | Uint8Array): StacksPublicKey;
declare function compressPublicKey(publicKey: string | Uint8Array): StacksPublicKey;
declare function deserializePublicKey(bufferReader: BufferReader): StacksPublicKey;
interface StacksPrivateKey {
    data: Uint8Array;
    compressed: boolean;
}
declare function createStacksPrivateKey(key: string | Uint8Array): StacksPrivateKey;
declare function makeRandomPrivKey(): StacksPrivateKey;
declare function signWithKey(privateKey: StacksPrivateKey, input: string): Promise<MessageSignature>;
declare function getSignatureRecoveryParam(signature: string): number;
declare function parseRecoverableSignature(signature: string): {
    recoveryParam: number;
    r: string;
    s: string;
};
declare function getPublicKeyFromStacksPrivateKey(privateKey: StacksPrivateKey): StacksPublicKey;
declare function privateKeyToString(privateKey: StacksPrivateKey): string;

declare abstract class Deserializable {
    abstract serialize(): Uint8Array;
    abstract deserialize(bufferReader: BufferReader): void;
    static deserialize<T extends Deserializable>(this: new () => T, bufferReader: BufferReader): T;
}
interface MessageSignature {
    readonly type: StacksMessageType.MessageSignature;
    data: string;
}
declare function createMessageSignature(signature: string): MessageSignature;
declare function emptyMessageSignature(): MessageSignature;
declare function serializeMessageSignature(messageSignature: MessageSignature): Uint8Array;
declare function deserializeMessageSignature(bufferReader: BufferReader): MessageSignature;
declare type TransactionAuthFieldContents = StacksPublicKey | MessageSignature;
interface TransactionAuthField {
    type: StacksMessageType.TransactionAuthField;
    pubKeyEncoding: PubKeyEncoding;
    contents: TransactionAuthFieldContents;
}
declare function createTransactionAuthField(pubKeyEncoding: PubKeyEncoding, contents: TransactionAuthFieldContents): TransactionAuthField;
declare function serializeTransactionAuthField(field: TransactionAuthField): Uint8Array;
declare function deserializeTransactionAuthField(bufferReader: BufferReader): TransactionAuthField;
interface SingleSigSpendingCondition {
    hashMode: SingleSigHashMode;
    signer: string;
    nonce: bigint;
    fee: bigint;
    keyEncoding: PubKeyEncoding;
    signature: MessageSignature;
}
interface SingleSigSpendingConditionOpts extends Omit<SingleSigSpendingCondition, 'nonce' | 'fee'> {
    nonce: IntegerType;
    fee: IntegerType;
}
interface MultiSigSpendingCondition {
    hashMode: MultiSigHashMode;
    signer: string;
    nonce: bigint;
    fee: bigint;
    fields: TransactionAuthField[];
    signaturesRequired: number;
}
interface MultiSigSpendingConditionOpts extends Omit<MultiSigSpendingCondition, 'nonce' | 'fee'> {
    nonce: IntegerType;
    fee: IntegerType;
}
declare type SpendingCondition = SingleSigSpendingCondition | MultiSigSpendingCondition;
declare type SpendingConditionOpts = SingleSigSpendingConditionOpts | MultiSigSpendingConditionOpts;
declare function createSingleSigSpendingCondition(hashMode: SingleSigHashMode, pubKey: string, nonce: IntegerType, fee: IntegerType): SingleSigSpendingCondition;
declare function createMultiSigSpendingCondition(hashMode: MultiSigHashMode, numSigs: number, pubKeys: string[], nonce: IntegerType, fee: IntegerType): MultiSigSpendingCondition;
declare function isSingleSig(condition: SpendingConditionOpts): condition is SingleSigSpendingConditionOpts;
declare function serializeSingleSigSpendingCondition(condition: SingleSigSpendingConditionOpts): Uint8Array;
declare function serializeMultiSigSpendingCondition(condition: MultiSigSpendingConditionOpts): Uint8Array;
declare function deserializeSingleSigSpendingCondition(hashMode: SingleSigHashMode, bufferReader: BufferReader): SingleSigSpendingCondition;
declare function deserializeMultiSigSpendingCondition(hashMode: MultiSigHashMode, bufferReader: BufferReader): MultiSigSpendingCondition;
declare function serializeSpendingCondition(condition: SpendingConditionOpts): Uint8Array;
declare function deserializeSpendingCondition(bufferReader: BufferReader): SpendingCondition;
declare function makeSigHashPreSign(curSigHash: string, authType: AuthType, fee: IntegerType, nonce: IntegerType): string;
declare function nextSignature(curSigHash: string, authType: AuthType, fee: IntegerType, nonce: IntegerType, privateKey: StacksPrivateKey): Promise<{
    nextSig: MessageSignature;
    nextSigHash: string;
}>;
declare function nextVerification(initialSigHash: string, authType: AuthType, fee: IntegerType, nonce: IntegerType, pubKeyEncoding: PubKeyEncoding, signature: MessageSignature): {
    pubKey: StacksPublicKey;
    nextSigHash: string;
};
declare type Authorization = StandardAuthorization | SponsoredAuthorization;
interface StandardAuthorization {
    authType: AuthType.Standard;
    spendingCondition: SpendingCondition;
}
interface SponsoredAuthorization {
    authType: AuthType.Sponsored;
    spendingCondition: SpendingCondition;
    sponsorSpendingCondition: SpendingCondition;
}
declare function createStandardAuth(spendingCondition: SpendingCondition): StandardAuthorization;
declare function createSponsoredAuth(spendingCondition: SpendingCondition, sponsorSpendingCondition?: SpendingCondition): Authorization;
declare function intoInitialSighashAuth(auth: Authorization): Authorization;
declare function verifyOrigin(auth: Authorization, initialSigHash: string): string;
declare function setFee(auth: Authorization, amount: IntegerType): Authorization;
declare function getFee(auth: Authorization): bigint;
declare function setNonce(auth: Authorization, nonce: IntegerType): Authorization;
declare function setSponsorNonce(auth: SponsoredAuthorization, nonce: IntegerType): Authorization;
declare function setSponsor(auth: SponsoredAuthorization, sponsorSpendingCondition: SpendingConditionOpts): Authorization;
declare function serializeAuthorization(auth: Authorization): Uint8Array;
declare function deserializeAuthorization(bufferReader: BufferReader): Authorization;

declare type PostCondition = STXPostCondition | FungiblePostCondition | NonFungiblePostCondition;
interface STXPostCondition {
    readonly type: StacksMessageType.PostCondition;
    readonly conditionType: PostConditionType.STX;
    readonly principal: PostConditionPrincipal;
    readonly conditionCode: FungibleConditionCode;
    readonly amount: bigint;
}
declare function createSTXPostCondition(principal: string | PostConditionPrincipal, conditionCode: FungibleConditionCode, amount: IntegerType): STXPostCondition;
interface FungiblePostCondition {
    readonly type: StacksMessageType.PostCondition;
    readonly conditionType: PostConditionType.Fungible;
    readonly principal: PostConditionPrincipal;
    readonly conditionCode: FungibleConditionCode;
    readonly amount: bigint;
    readonly assetInfo: AssetInfo;
}
declare function createFungiblePostCondition(principal: string | PostConditionPrincipal, conditionCode: FungibleConditionCode, amount: IntegerType, assetInfo: string | AssetInfo): FungiblePostCondition;
interface NonFungiblePostCondition {
    readonly type: StacksMessageType.PostCondition;
    readonly conditionType: PostConditionType.NonFungible;
    readonly principal: PostConditionPrincipal;
    readonly conditionCode: NonFungibleConditionCode;
    /** Structure that identifies the token type. */
    readonly assetInfo: AssetInfo;
    /** The Clarity value that names the token instance. */
    readonly assetName: ClarityValue;
}
declare function createNonFungiblePostCondition(principal: string | PostConditionPrincipal, conditionCode: NonFungibleConditionCode, assetInfo: string | AssetInfo, assetName: ClarityValue): NonFungiblePostCondition;
declare function serializePostCondition(postCondition: PostCondition): Uint8Array;
declare function deserializePostCondition(bufferReader: BufferReader): PostCondition;

declare type StacksMessage = Address | PostConditionPrincipal | LengthPrefixedString | LengthPrefixedList | Payload | MemoString | AssetInfo | PostCondition | StacksPublicKey | TransactionAuthField | MessageSignature;
declare function serializeStacksMessage(message: StacksMessage): Uint8Array;
declare function deserializeStacksMessage(bufferReader: BufferReader, type: StacksMessageType, listType?: StacksMessageType): StacksMessage;
declare function createEmptyAddress(): Address;
declare function addressFromVersionHash(version: StacksNetworkVersion, hash: string): Address;
/**
 * Translates the tx auth hash mode to the corresponding address version.
 * @see https://github.com/blockstack/stacks-blockchain/blob/master/sip/sip-005-blocks-and-transactions.md#transaction-authorization
 */
declare function addressHashModeToVersion(hashMode: AddressHashMode, txVersion: TransactionVersion): StacksNetworkVersion;
declare function addressFromHashMode(hashMode: AddressHashMode, txVersion: TransactionVersion, data: string): Address;
declare function addressFromPublicKeys(version: StacksNetworkVersion, hashMode: AddressHashMode, numSigs: number, publicKeys: StacksPublicKey[]): Address;
/**
 * Parses a principal string for either a standard principal or contract principal.
 * @param principalString - String in the format `{address}.{contractName}`
 * @example "SP13N5TE1FBBGRZD1FCM49QDGN32WAXM2E5F8WT2G.example-contract"
 * @example "SP13N5TE1FBBGRZD1FCM49QDGN32WAXM2E5F8WT2G"
 */
declare function parsePrincipalString(principalString: string): StandardPrincipal | ContractPrincipal;
declare function createStandardPrincipal(addressString: string): StandardPrincipal;
declare function createContractPrincipal(addressString: string, contractName: string): ContractPrincipal;
declare function serializePrincipal(principal: PostConditionPrincipal): Uint8Array;
declare function deserializePrincipal(bufferReader: BufferReader): PostConditionPrincipal;
declare function codeBodyString(content: string): LengthPrefixedString;
interface MemoString {
    readonly type: StacksMessageType.MemoString;
    readonly content: string;
}
declare function createMemoString(content: string): MemoString;
declare function serializeMemoString(memoString: MemoString): Uint8Array;
declare function deserializeMemoString(bufferReader: BufferReader): MemoString;
/**
 * Parse a fully qualified string that identifies the token type.
 * @param id - String in the format `{address}.{contractName}::{assetName}`
 * @example "SP13N5TE1FBBGRZD1FCM49QDGN32WAXM2E5F8WT2G.example-contract::example-token"
 */
declare function parseAssetInfoString(id: string): AssetInfo;
declare function createAssetInfo(addressString: string, contractName: string, assetName: string): AssetInfo;
declare function serializeAssetInfo(info: AssetInfo): Uint8Array;
declare function deserializeAssetInfo(bufferReader: BufferReader): AssetInfo;
interface LengthPrefixedList {
    readonly type: StacksMessageType.LengthPrefixedList;
    readonly lengthPrefixBytes: number;
    readonly values: StacksMessage[];
}
declare function createLPList<T extends StacksMessage>(values: T[], lengthPrefixBytes?: number): LengthPrefixedList;
declare function serializeLPList(lpList: LengthPrefixedList): Uint8Array;
declare function deserializeLPList(bufferReader: BufferReader, type: StacksMessageType, lengthPrefixBytes?: number): LengthPrefixedList;

declare type Payload = TokenTransferPayload | ContractCallPayload | SmartContractPayload | PoisonPayload | CoinbasePayload;
declare enum PayloadType {
    TokenTransfer = 0,
    SmartContract = 1,
    ContractCall = 2,
    PoisonMicroblock = 3,
    Coinbase = 4
}
interface TokenTransferPayload {
    readonly type: StacksMessageType.Payload;
    readonly payloadType: PayloadType.TokenTransfer;
    readonly recipient: PrincipalCV;
    readonly amount: bigint;
    readonly memo: MemoString;
}
declare type PayloadInput = (TokenTransferPayload | (Omit<TokenTransferPayload, 'amount'> & {
    amount: IntegerType;
})) | ContractCallPayload | SmartContractPayload | PoisonPayload | CoinbasePayload;
interface ContractCallPayload {
    readonly type: StacksMessageType.Payload;
    readonly payloadType: PayloadType.ContractCall;
    readonly contractAddress: Address;
    readonly contractName: LengthPrefixedString;
    readonly functionName: LengthPrefixedString;
    readonly functionArgs: ClarityValue[];
}
interface SmartContractPayload {
    readonly type: StacksMessageType.Payload;
    readonly payloadType: PayloadType.SmartContract;
    readonly contractName: LengthPrefixedString;
    readonly codeBody: LengthPrefixedString;
}
interface PoisonPayload {
    readonly type: StacksMessageType.Payload;
    readonly payloadType: PayloadType.PoisonMicroblock;
}
interface CoinbasePayload {
    readonly type: StacksMessageType.Payload;
    readonly payloadType: PayloadType.Coinbase;
    readonly coinbaseBuffer: Uint8Array;
}

declare class StacksTransaction {
    version: TransactionVersion;
    chainId: ChainID;
    auth: Authorization;
    anchorMode: AnchorMode;
    payload: Payload;
    postConditionMode: PostConditionMode;
    postConditions: LengthPrefixedList;
    constructor(version: TransactionVersion, auth: Authorization, payload: PayloadInput, postConditions?: LengthPrefixedList, postConditionMode?: PostConditionMode, anchorMode?: AnchorMode, chainId?: ChainID);
    signBegin(): string;
    verifyBegin(): string;
    createTxWithSignature(signature: string | Uint8Array): StacksTransaction;
    verifyOrigin(): string;
    signNextOrigin(sigHash: string, privateKey: StacksPrivateKey): Promise<string>;
    signNextSponsor(sigHash: string, privateKey: StacksPrivateKey): Promise<string>;
    appendPubkey(publicKey: StacksPublicKey): void;
    signAndAppend(condition: SpendingConditionOpts, curSigHash: string, authType: AuthType, privateKey: StacksPrivateKey): Promise<string>;
    txid(): string;
    setSponsor(sponsorSpendingCondition: SpendingConditionOpts): void;
    /**
     * Set the total fee to be paid for this transaction
     *
     * @param fee - the fee amount in microstacks
     */
    setFee(amount: IntegerType): void;
    /**
     * Set the transaction nonce
     *
     * @param nonce - the nonce value
     */
    setNonce(nonce: IntegerType): void;
    /**
     * Set the transaction sponsor nonce
     *
     * @param nonce - the sponsor nonce value
     */
    setSponsorNonce(nonce: IntegerType): void;
    serialize(): Uint8Array;
}
/**
 * @param data Buffer or hex string
 */
declare function deserializeTransaction(data: BufferReader | Uint8Array | string): StacksTransaction;

declare const isClarityAbiPrimitive: (val: ClarityAbiType) => val is ClarityAbiTypePrimitive;
declare const isClarityAbiBuffer: (val: ClarityAbiType) => val is ClarityAbiTypeBuffer;
declare const isClarityAbiStringAscii: (val: ClarityAbiType) => val is ClarityAbiTypeStringAscii;
declare const isClarityAbiStringUtf8: (val: ClarityAbiType) => val is ClarityAbiTypeStringUtf8;
declare const isClarityAbiResponse: (val: ClarityAbiType) => val is ClarityAbiTypeResponse;
declare const isClarityAbiOptional: (val: ClarityAbiType) => val is ClarityAbiTypeOptional;
declare const isClarityAbiTuple: (val: ClarityAbiType) => val is ClarityAbiTypeTuple;
declare const isClarityAbiList: (val: ClarityAbiType) => val is ClarityAbiTypeList;
declare function getTypeUnion(val: ClarityAbiType): ClarityAbiTypeUnion;
declare function encodeClarityValue(type: ClarityAbiType, val: string): ClarityValue;
declare function encodeClarityValue(type: ClarityAbiTypeUnion, val: string): ClarityValue;

declare function getTypeString(val: ClarityAbiType): string;
declare function abiFunctionToString(func: ClarityAbiFunction): string;
/**
 * Validates a contract-call payload with a contract ABI
 *
 * @param {ContractCallPayload} payload - a contract-call payload
 * @param {ClarityAbi} abi - a contract ABI
 *
 * @returns {boolean} true if the payloads functionArgs type check against those in the ABI
 */
declare function validateContractCall(payload: ContractCallPayload, abi: ClarityAbi): boolean;
/**
 * Convert string input to Clarity value based on contract ABI data. Only handles Clarity
 * primitives and buffers. Responses, optionals, tuples and lists are not supported.
 *
 * @param {string} input - string to be parsed into Clarity value
 * @param {ClarityAbiType} type - the contract function argument object
 *
 * @returns {ClarityValue} returns a Clarity value
 */
declare function parseToCV(input: string, type: ClarityAbiType): ClarityValue;

declare class TransactionSigner {
    transaction: StacksTransaction;
    sigHash: string;
    originDone: boolean;
    checkOversign: boolean;
    checkOverlap: boolean;
    constructor(transaction: StacksTransaction);
    static createSponsorSigner(transaction: StacksTransaction, spendingCondition: SpendingConditionOpts): TransactionSigner;
    signOrigin(privateKey: StacksPrivateKey): Promise<void>;
    appendOrigin(publicKey: StacksPublicKey): void;
    signSponsor(privateKey: StacksPrivateKey): Promise<void>;
    getTxInComplete(): StacksTransaction;
    resume(transaction: StacksTransaction): void;
}

declare const leftPadHex: (hexString: string) => string;
declare const leftPadHexToLength: (hexString: string, length: number) => string;
declare const rightPadHexToLength: (hexString: string, length: number) => string;
declare const txidFromData: (data: Uint8Array) => string;
/**
 * Read only function response object
 *
 * @param {Boolean} okay - the status of the response
 * @param {string} result - serialized hex clarity value
 */
interface ReadOnlyFunctionSuccessResponse {
    okay: true;
    result: string;
}
interface ReadOnlyFunctionErrorResponse {
    okay: false;
    cause: string;
}
declare type ReadOnlyFunctionResponse = ReadOnlyFunctionSuccessResponse | ReadOnlyFunctionErrorResponse;
/**
 * Converts the response of a read-only function call into its Clarity Value
 * @param response - {@link ReadOnlyFunctionResponse}
 */
declare function parseReadOnlyResponse<T extends ClarityValue>(response: ReadOnlyFunctionResponse): T;

interface MultiSigOptions {
    numSignatures: number;
    publicKeys: string[];
    signerKeys?: string[];
}
/**
 * Contract function call transaction options
 */
interface ContractCallOptions {
    /** the Stacks address of the contract */
    contractAddress: string;
    contractName: string;
    functionName: string;
    functionArgs: ClarityValue[];
    /** transaction fee in microstacks */
    fee?: IntegerType;
    feeEstimateApiUrl?: string;
    /** the transaction nonce, which must be increased monotonically with each new transaction */
    nonce?: IntegerType;
    /** the Stacks blockchain network that will ultimately be used to broadcast this transaction */
    network?: StacksNetwork;
    /** the transaction anchorMode, which specifies whether it should be
     * included in an anchor block or a microblock */
    anchorMode: AnchorMode;
    /** the post condition mode, specifying whether or not post-conditions must fully cover all
     * transfered assets */
    postConditionMode?: PostConditionMode;
    /** a list of post conditions to add to the transaction */
    postConditions?: PostCondition[];
    /** set to true to validate that the supplied function args match those specified in
     * the published contract */
    validateWithAbi?: boolean | ClarityAbi;
    /** set to true if another account is sponsoring the transaction (covering the transaction fee) */
    sponsored?: boolean;
}
interface UnsignedContractCallOptions extends ContractCallOptions {
    publicKey: string;
}
interface SignedContractCallOptions extends ContractCallOptions {
    senderKey: string;
}
interface UnsignedMultiSigContractCallOptions extends ContractCallOptions {
    numSignatures: number;
    publicKeys: string[];
}
interface SignedMultiSigContractCallOptions extends ContractCallOptions {
    numSignatures: number;
    publicKeys: string[];
    signerKeys: string[];
}
/**
 * Contract deploy transaction options
 */
interface ContractDeployOptions {
    contractName: string;
    /** the Clarity code to be deployed */
    codeBody: string;
    /** a hex string of the private key of the transaction sender */
    senderKey: string;
    /** transaction fee in microstacks */
    fee?: IntegerType;
    /** the transaction nonce, which must be increased monotonically with each new transaction */
    nonce?: IntegerType;
    /** the network that the transaction will ultimately be broadcast to */
    network?: StacksNetwork;
    /** the transaction anchorMode, which specifies whether it should be
     * included in an anchor block or a microblock */
    anchorMode: AnchorMode;
    /** the post condition mode, specifying whether or not post-conditions must fully cover all
     * transfered assets */
    postConditionMode?: PostConditionMode;
    /** a list of post conditions to add to the transaction */
    postConditions?: PostCondition[];
    /** set to true if another account is sponsoring the transaction (covering the transaction fee) */
    sponsored?: boolean;
}
/**
 * STX token transfer transaction options
 */
interface TokenTransferOptions {
    /** the address of the recipient of the token transfer */
    recipient: string | PrincipalCV;
    /** the amount to be transfered in microstacks */
    amount: IntegerType;
    /** the transaction fee in microstacks */
    fee?: IntegerType;
    /** the transaction nonce, which must be increased monotonically with each new transaction */
    nonce?: IntegerType;
    /** the network that the transaction will ultimately be broadcast to */
    network?: StacksNetwork;
    /** the transaction anchorMode, which specifies whether it should be
     * included in an anchor block or a microblock */
    anchorMode: AnchorMode;
    /** an arbitrary string to include in the transaction, must be less than 34 bytes */
    memo?: string;
    /** the post condition mode, specifying whether or not post-conditions must fully cover all
     * transfered assets */
    postConditionMode?: PostConditionMode;
    /** a list of post conditions to add to the transaction */
    postConditions?: PostCondition[];
    /** set to true if another account is sponsoring the transaction (covering the transaction fee) */
    sponsored?: boolean;
}
interface UnsignedTokenTransferOptions extends TokenTransferOptions {
    publicKey: string;
}
interface SignedTokenTransferOptions extends TokenTransferOptions {
    senderKey: string;
}
interface UnsignedMultiSigTokenTransferOptions extends TokenTransferOptions {
    numSignatures: number;
    publicKeys: string[];
}
interface SignedMultiSigTokenTransferOptions extends TokenTransferOptions {
    numSignatures: number;
    publicKeys: string[];
    signerKeys: string[];
}
/**
 * Sponsored transaction options
 */
interface SponsorOptionsOpts {
    /** the origin-signed transaction */
    transaction: StacksTransaction;
    /** the sponsor's private key */
    sponsorPrivateKey: string;
    /** the transaction fee amount to sponsor */
    fee?: IntegerType;
    /** the nonce of the sponsor account */
    sponsorNonce?: IntegerType;
    /** the hashmode of the sponsor's address */
    sponsorAddressHashmode?: AddressHashMode;
    /** the Stacks blockchain network that this transaction will ultimately be broadcast to */
    network?: StacksNetwork;
}

/**
 * Constructs and signs a sponsored transaction as the sponsor
 *
 * @param  {SponsorOptionsOpts} sponsorOptions - the sponsor options object
 *
 * Returns a signed sponsored transaction.
 *
 * @return {ClarityValue}
 */
declare function sponsorTransaction(sponsorOptions: SponsorOptionsOpts): Promise<StacksTransaction>;

/**
 * Generates a STX post condition with a standard principal
 *
 * Returns a STX post condition object
 *
 * @param address - the c32check address
 * @param conditionCode - the condition code
 * @param amount - the amount of STX tokens
 */
declare function makeStandardSTXPostCondition(address: string, conditionCode: FungibleConditionCode, amount: IntegerType): STXPostCondition;
/**
 * Generates a STX post condition with a contract principal
 *
 * Returns a STX post condition object
 *
 * @param address - the c32check address of the contract
 * @param contractName - the name of the contract
 * @param conditionCode - the condition code
 * @param amount - the amount of STX tokens
 *
 * @return {STXPostCondition}
 */
declare function makeContractSTXPostCondition(address: string, contractName: string, conditionCode: FungibleConditionCode, amount: IntegerType): STXPostCondition;
/**
 * Generates a fungible token post condition with a standard principal
 *
 * Returns a fungible token post condition object
 *
 * @param address - the c32check address
 * @param conditionCode - the condition code
 * @param amount - the amount of fungible tokens
 * @param assetInfo - asset info describing the fungible token
 */
declare function makeStandardFungiblePostCondition(address: string, conditionCode: FungibleConditionCode, amount: IntegerType, assetInfo: string | AssetInfo): FungiblePostCondition;
/**
 * Generates a fungible token post condition with a contract principal
 *
 * Returns a fungible token post condition object
 *
 * @param address - the c32check address
 * @param contractName - the name of the contract
 * @param conditionCode - the condition code
 * @param amount - the amount of fungible tokens
 * @param assetInfo - asset info describing the fungible token
 */
declare function makeContractFungiblePostCondition(address: string, contractName: string, conditionCode: FungibleConditionCode, amount: IntegerType, assetInfo: string | AssetInfo): FungiblePostCondition;
/**
 * Generates a non-fungible token post condition with a standard principal
 *
 * Returns a non-fungible token post condition object
 *
 * @param  {String} address - the c32check address
 * @param  {FungibleConditionCode} conditionCode - the condition code
 * @param  {AssetInfo} assetInfo - asset info describing the non-fungible token
 * @param  {ClarityValue} assetName - asset name describing the non-fungible token
 *
 * @return {NonFungiblePostCondition}
 */
declare function makeStandardNonFungiblePostCondition(address: string, conditionCode: NonFungibleConditionCode, assetInfo: string | AssetInfo, assetName: ClarityValue): NonFungiblePostCondition;
/**
 * Generates a non-fungible token post condition with a contract principal
 *
 * Returns a non-fungible token post condition object
 *
 * @param  {String} address - the c32check address
 * @param  {String} contractName - the name of the contract
 * @param  {FungibleConditionCode} conditionCode - the condition code
 * @param  {AssetInfo} assetInfo - asset info describing the non-fungible token
 * @param  {ClarityValue} assetName - asset name describing the non-fungible token
 *
 * @return {NonFungiblePostCondition}
 */
declare function makeContractNonFungiblePostCondition(address: string, contractName: string, conditionCode: NonFungibleConditionCode, assetInfo: string | AssetInfo, assetName: ClarityValue): NonFungiblePostCondition;

/**
 * Generates an unsigned Clarity smart contract function call transaction
 *
 * @param {UnsignedContractCallOptions | UnsignedMultiSigContractCallOptions} txOptions - an options object for the contract call
 *
 * @returns {Promise<StacksTransaction>}
 */
declare function makeUnsignedContractCall(txOptions: UnsignedContractCallOptions | UnsignedMultiSigContractCallOptions): Promise<StacksTransaction>;
/**
 * Generates a Clarity smart contract function call transaction
 *
 * @param  {SignedContractCallOptions | SignedMultiSigContractCallOptions} txOptions - an options object for the contract function call
 *
 * Returns a signed Stacks smart contract function call transaction.
 *
 * @return {StacksTransaction}
 */
declare function makeContractCall(txOptions: SignedContractCallOptions | SignedMultiSigContractCallOptions): Promise<StacksTransaction>;

/**
 * Generates a Clarity smart contract deploy transaction
 *
 * @param  {ContractDeployOptions} txOptions - an options object for the contract deploy
 *
 * Returns a signed Stacks smart contract deploy transaction.
 *
 * @return {StacksTransaction}
 */
declare function makeContractDeploy(txOptions: ContractDeployOptions): Promise<StacksTransaction>;

/**
 * Generates an unsigned Stacks token transfer transaction
 *
 * Returns a Stacks token transfer transaction.
 *
 * @param  {UnsignedTokenTransferOptions | UnsignedMultiSigTokenTransferOptions} txOptions - an options object for the token transfer
 *
 * @return {Promise<StacksTransaction>}
 */
declare function makeUnsignedSTXTokenTransfer(txOptions: UnsignedTokenTransferOptions | UnsignedMultiSigTokenTransferOptions, sync?: boolean): Promise<StacksTransaction>;
/**
 * Generates a signed Stacks token transfer transaction
 *
 * Returns a signed Stacks token transfer transaction.
 *
 * @param  {SignedTokenTransferOptions | SignedMultiSigTokenTransferOptions} txOptions - an options object for the token transfer
 *
 * @return {StacksTransaction}
 */
declare function makeSTXTokenTransfer(txOptions: SignedTokenTransferOptions | SignedMultiSigTokenTransferOptions): Promise<StacksTransaction>;

declare type TxBroadcastResultOk = {
    txid: string;
};
declare type TxBroadcastResultRejected = {
    error: string;
    reason: TxRejectedReason;
    reason_data: any;
    txid: string;
};
declare type TxBroadcastResult = TxBroadcastResultOk | TxBroadcastResultRejected;
/**
 * Broadcast the signed transaction to a core node
 *
 * @param {StacksTransaction} transaction - the token transfer transaction to broadcast
 * @param {StacksNetwork} network - the Stacks network to broadcast transaction to
 * @param {Uint8Array} attachment - Optional attachment to include
 *
 * @returns {Promise} that resolves to a response if the operation succeeds
 */
declare function broadcastTransaction(transaction: StacksTransaction, network: StacksNetwork, attachment?: Uint8Array): Promise<TxBroadcastResult>;
/**
 * Broadcast the signed transaction to a core node
 *
 * @param {Uint8Array} rawTx - the raw serialized transaction buffer to broadcast
 * @param {string} url - the broadcast endpoint URL
 * @param {Uint8Array} attachment - optional attachment
 * @returns {Promise} that resolves to a response if the operation succeeds
 */
declare function broadcastRawTransaction(rawTx: Uint8Array, url: string, attachment?: Uint8Array): Promise<TxBroadcastResult>;

/**
 * Lookup the nonce for an address from a core node
 *
 * @param {string} address - the c32check address to look up
 * @param {StacksNetwork} network - the Stacks network to look up address on
 *
 * @return a promise that resolves to an integer
 */
declare function getNonce(address: string, network?: StacksNetwork): Promise<bigint>;

/**
 * Estimate the total transaction fee in microstacks for a token transfer
 *
 * @param {StacksTransaction} transaction - the token transfer transaction to estimate fees for
 * @param {StacksNetwork} network - the Stacks network to estimate transaction for
 *
 * @return a promise that resolves to number of microstacks per byte
 */
declare function estimateTransfer(transaction: StacksTransaction, network?: StacksNetwork): Promise<bigint>;

/**
 * Fetch a contract's ABI
 *
 * @param {string} address - the contracts address
 * @param {string} contractName - the contracts name
 * @param {StacksNetwork} network - the Stacks network to broadcast transaction to
 *
 * @returns {Promise} that resolves to a ClarityAbi if the operation succeeds
 */
declare function getAbi(address: string, contractName: string, network: StacksNetwork): Promise<ClarityAbi>;

/**
 * Estimate the total transaction fee in microstacks for a contract function call
 *
 * @param {StacksTransaction} transaction - the token transfer transaction to estimate fees for
 * @param {StacksNetwork} network - the Stacks network to estimate transaction for
 *
 * @return a promise that resolves to number of microstacks per byte
 */
declare function estimateContractFunctionCall(transaction: StacksTransaction, network?: StacksNetwork): Promise<bigint>;

/**
 * Estimate the total transaction fee in microstacks for a contract deploy
 *
 * @param {StacksTransaction} transaction - the token transfer transaction to estimate fees for
 * @param {StacksNetwork} network - the Stacks network to estimate transaction for
 *
 * @return a promise that resolves to number of microstacks per byte
 */
declare function estimateContractDeploy(transaction: StacksTransaction, network?: StacksNetwork): Promise<bigint>;

export { AddressHashMode, AddressVersion, AnchorMode, AssetType, AuthType, Authorization, CLARITY_INT_BYTE_SIZE, ContractCallOptions, ContractDeployOptions, DEFAULT_CORE_NODE_API_URL, DEFAULT_TRANSACTION_VERSION, Deserializable, FungibleConditionCode, LengthPrefixedList, MemoString, MessageSignature, MultiSigHashMode, MultiSigOptions, MultiSigSpendingCondition, MultiSigSpendingConditionOpts, NonFungibleConditionCode, PostCondition, PostConditionMode, PostConditionType, PubKeyEncoding, ReadOnlyFunctionErrorResponse, ReadOnlyFunctionResponse, ReadOnlyFunctionSuccessResponse, SignedContractCallOptions, SignedMultiSigContractCallOptions, SignedMultiSigTokenTransferOptions, SignedTokenTransferOptions, SingleSigHashMode, SingleSigSpendingCondition, SingleSigSpendingConditionOpts, SpendingCondition, SpendingConditionOpts, SponsorOptionsOpts, SponsoredAuthorization, StacksMessage, StacksPrivateKey, StacksPublicKey, StacksTransaction, StandardAuthorization, TokenTransferOptions, TransactionAuthField, TransactionAuthFieldContents, TransactionSigner, TxBroadcastResult, TxBroadcastResultOk, TxBroadcastResultRejected, TxRejectedReason, UnsignedContractCallOptions, UnsignedMultiSigContractCallOptions, UnsignedMultiSigTokenTransferOptions, UnsignedTokenTransferOptions, abiFunctionToString, addressFromHashMode, addressFromPublicKeys, addressFromVersionHash, addressHashModeToVersion, broadcastRawTransaction, broadcastTransaction, codeBodyString, compressPublicKey, createAssetInfo, createContractPrincipal, createEmptyAddress, createFungiblePostCondition, createLPList, createMemoString, createMessageSignature, createMultiSigSpendingCondition, createNonFungiblePostCondition, createSTXPostCondition, createSingleSigSpendingCondition, createSponsoredAuth, createStacksPrivateKey, createStacksPublicKey, createStandardAuth, createStandardPrincipal, createTransactionAuthField, deserializeAssetInfo, deserializeAuthorization, deserializeLPList, deserializeMemoString, deserializeMessageSignature, deserializeMultiSigSpendingCondition, deserializePostCondition, deserializePrincipal, deserializePublicKey, deserializeSingleSigSpendingCondition, deserializeSpendingCondition, deserializeStacksMessage, deserializeTransaction, deserializeTransactionAuthField, emptyMessageSignature, encodeClarityValue, estimateContractDeploy, estimateContractFunctionCall, estimateTransfer, getAbi, getFee, getNonce, getPublicKeyFromStacksPrivateKey, getSignatureRecoveryParam, getTypeString, getTypeUnion, intoInitialSighashAuth, isClarityAbiBuffer, isClarityAbiList, isClarityAbiOptional, isClarityAbiPrimitive, isClarityAbiResponse, isClarityAbiStringAscii, isClarityAbiStringUtf8, isClarityAbiTuple, isCompressed, isPrivateKeyCompressed, isSingleSig, leftPadHex, leftPadHexToLength, makeContractCall, makeContractDeploy, makeContractFungiblePostCondition, makeContractNonFungiblePostCondition, makeContractSTXPostCondition, makeRandomPrivKey, makeSTXTokenTransfer, makeSigHashPreSign, makeStandardFungiblePostCondition, makeStandardNonFungiblePostCondition, makeStandardSTXPostCondition, makeUnsignedContractCall, makeUnsignedSTXTokenTransfer, nextSignature, nextVerification, parseAssetInfoString, parsePrincipalString, parseReadOnlyResponse, parseRecoverableSignature, parseToCV, privateKeyToString, pubKeyfromPrivKey, publicKeyFromBuffer, publicKeyFromSignature, publicKeyToString, rightPadHexToLength, serializeAssetInfo, serializeAuthorization, serializeLPList, serializeMemoString, serializeMessageSignature, serializeMultiSigSpendingCondition, serializePostCondition, serializePrincipal, serializePublicKey, serializeSingleSigSpendingCondition, serializeSpendingCondition, serializeStacksMessage, serializeTransactionAuthField, setFee, setNonce, setSponsor, setSponsorNonce, signWithKey, sponsorTransaction, txidFromData, validateContractCall, verifyOrigin };
