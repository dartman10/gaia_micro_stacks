"use strict";Object.defineProperty(exports,"__esModule",{value:!0});var ripemd160$1=require("@noble/hashes/ripemd160"),common=require("micro-stacks/common"),cryptoSha=require("micro-stacks/crypto-sha"),secp256k1=require("@noble/secp256k1"),cryptoAes=require("micro-stacks/crypto-aes"),cryptoHmacSha=require("micro-stacks/crypto-hmac-sha");function getAesCbcOutputLength(e){return(Math.floor(e/16)+1)*16}function getBase64OutputLength(e){return Math.ceil(e/3)*4}function getCipherObjectWrapper(e){const t={iv:"",ephemeralPK:"",mac:"",cipherText:"",wasString:!!e.wasString};e.cipherTextEncoding==="base64"&&(t.cipherTextEncoding="base64");const n=32,r=66,s=64;return{payloadValuesLength:n+r+s,payloadShell:JSON.stringify(t)}}function getSignedCipherObjectWrapper(e){const t={signature:"",publicKey:"",cipherText:e};return{signedPayloadValuesLength:144+66,signedPayloadShell:JSON.stringify(t)}}function eciesGetJsonStringLength(e){const{payloadShell:t,payloadValuesLength:n}=getCipherObjectWrapper(e),r=getAesCbcOutputLength(e.contentLength);let s;if(!e.cipherTextEncoding||e.cipherTextEncoding==="hex")s=r*2;else if(e.cipherTextEncoding==="base64")s=getBase64OutputLength(r);else throw new Error(`Unexpected cipherTextEncoding "${e.cipherTextEncoding}"`);if(e.sign){const{signedPayloadShell:o,signedPayloadValuesLength:i}=getSignedCipherObjectWrapper(t);return o.length+i+n+s}else return t.length+n+s}function ripemd160(e){return typeof e=="string"?ripemd160$1.ripemd160(e):ripemd160$1.ripemd160.create().update(common.ensureUint8Array(e)).digest()}class Ripemd160PolyfillDigest{digest(t){return ripemd160(t)}}function createHashRipemd160(){return new Ripemd160PolyfillDigest}function hashRipemd160(e){return createHashRipemd160().digest(e)}function sharedSecretToKeys(e){const t=cryptoSha.hashSha512(e);return{encryptionKey:t.slice(0,32),hmacKey:t.slice(32)}}function getRandomBytes(e=32){return secp256k1.utils.randomBytes(e)}const isCompressedPublicKey=e=>{const t=e[0];return e.length===32||e.length===33&&(t===2||t===3)},derivePublicKey=(e,t)=>{const n=secp256k1.Point.fromHex(common.bytesToHex(e));return new secp256k1.Point(secp256k1.CURVE.Gx,secp256k1.CURVE.Gy).multiply(common.bytesToBigInt(t)).add(n).toRawBytes(isCompressedPublicKey(e))};function mod(e,t=secp256k1.CURVE.P){const n=e%t;return n>=0?n:t+n}const derivePrivateKey=(e,t)=>common.intToBytes(mod(common.bytesToBigInt(t)+common.bytesToBigInt(e),secp256k1.CURVE.n),!1,32);function base58checkEncode(e,t){const n=new Uint8Array([t]),r=new Uint8Array(25),s=new Uint8Array(21);s[0]=t,s.set(e,1);const o=cryptoSha.hashSha256(s),c=cryptoSha.hashSha256(o).slice(0,4);return r.set(n,0),r.set(e,1),r.set(c,e.length+1),common.encodeB58(r)}function base58checkDecode(e){const t=common.decodeB58(e),n=t.slice(-4),r=cryptoSha.hashSha256(t.slice(0,-4)),s=cryptoSha.hashSha256(r);for(let c=0;c<4;c++)if(s[c]!==n[c])throw new Error("base58 address has invalid checksum");const o=t[0];return{hash:t.slice(1,-4),version:o}}var BitcoinNetworkVersion;(function(e){e[e.mainnetP2PKH=0]="mainnetP2PKH",e[e.mainnetP2SH=5]="mainnetP2SH",e[e.testnetP2PKH=111]="testnetP2PKH",e[e.testnetP2SH=196]="testnetP2SH"})(BitcoinNetworkVersion||(BitcoinNetworkVersion={}));const bitcoin={messagePrefix:`Bitcoin Signed Message:
`,bech32:"bc",bip32:{public:76067358,private:76066276},pubKeyHash:0,scriptHash:5,wif:128},testnet={messagePrefix:`Bitcoin Signed Message:
`,bech32:"tb",bip32:{public:70617039,private:70615956},pubKeyHash:111,scriptHash:196,wif:239},networks={bitcoin,testnet};exports.StacksNetworkVersion=void 0,function(e){e[e.mainnetP2PKH=22]="mainnetP2PKH",e[e.mainnetP2SH=20]="mainnetP2SH",e[e.testnetP2PKH=26]="testnetP2PKH",e[e.testnetP2SH=21]="testnetP2SH"}(exports.StacksNetworkVersion||(exports.StacksNetworkVersion={}));const BITCOIN_TO_STACKS_NETWORK_VERSION={[BitcoinNetworkVersion.mainnetP2PKH]:22,[BitcoinNetworkVersion.mainnetP2SH]:20,[BitcoinNetworkVersion.testnetP2PKH]:26,[BitcoinNetworkVersion.testnetP2SH]:21},STACKS_TO_BITCOIN_NETWORK_VERSION={[22]:BitcoinNetworkVersion.mainnetP2PKH,[20]:BitcoinNetworkVersion.mainnetP2SH,[26]:BitcoinNetworkVersion.testnetP2PKH,[21]:BitcoinNetworkVersion.testnetP2SH},c32="0123456789ABCDEFGHJKMNPQRSTVWXYZ",c32Lookup=new Map;[...c32].forEach((e,t)=>c32Lookup.set(e,t));const hex="0123456789abcdef",hexLookup=new Map;[...hex].forEach((e,t)=>hexLookup.set(e,t));function c32address(e,t){const n=c32checksum(e,t),r=c32encode(common.concatByteArrays([t,n]));return`S${c32[e]}${r}`}function b58ToC32(e){const t=base58checkDecode(e),n=t.hash,r=t.version;let s=r;return BITCOIN_TO_STACKS_NETWORK_VERSION[r]!==void 0&&(s=BITCOIN_TO_STACKS_NETWORK_VERSION[r]),c32address(s,n)}function c32ToB58(e){const t=c32addressDecode(e),n=t[0],r=t[1];let s=n;return STACKS_TO_BITCOIN_NETWORK_VERSION[n]!==void 0&&(s=STACKS_TO_BITCOIN_NETWORK_VERSION[n]),base58checkEncode(r,s)}function c32encode(e){const t=common.bytesToHex(e);let n=[],r=0;for(let c=t.length-1;c>=0;c--)if(r<4){const h=hexLookup.get(t[c])>>r;let a=0;c!==0&&(a=hexLookup.get(t[c-1]));const p=1+r,d=a%(1<<p)<<5-p,u=c32[h+d];r=p,n.unshift(u)}else r=0;let s=0;for(let c=0;c<n.length&&n[c]==="0";c++)s++;n=n.slice(s);const o=/^\u0000*/.exec(new TextDecoder().decode(e)),i=o?o[0].length:0;for(let c=0;c<i;c++)n.unshift(c32[0]);return n.join("")}function c32checksum(e,t){const n=cryptoSha.hashSha256(common.concatByteArrays([Uint8Array.of(e),t]));return cryptoSha.hashSha256(n).slice(0,4)}function c32addressDecode(e){if(e.length<=5)throw new Error("Invalid c32 address: invalid length");if(e[0]!=="S")throw new Error('Invalid c32 address: must start with "S"');return c32checkDecode(e.slice(1))}function c32checkDecode(e){e=c32normalize(e);const t=c32decode(e.slice(1)),n=e[0],r=c32Lookup.get(n),s=t.slice(-4),o=c32checksum(r,t.slice(0,-4));for(let i=0;i<s.length;i++)if(s[i]!==o[i])throw new Error("Invalid c32check string: checksum mismatch");return[r,t.slice(0,-4)]}function c32normalize(e){return e.toUpperCase().replace(/O/g,"0").replace(/L|I/g,"1")}function c32decode(e){if(e=c32normalize(e),!RegExp(`^[${c32}]*$`).exec(e))throw new Error("Not a c32-encoded string");const t=RegExp(`^${c32[0]}*`).exec(e),n=t?t[0].length:0;let r=[],s=0,o=0;for(let h=e.length-1;h>=0;h--){o===4&&(r.unshift(hex[s]),o=0,s=0);const p=(c32Lookup.get(e[h])<<o)+s,d=hex[p%16];if(o+=1,s=p>>4,s>1<<o)throw new Error("Panic error in decoding.");r.unshift(d)}r.unshift(hex[s]),r.length%2==1&&r.unshift("0");let i=0;for(let h=0;h<r.length&&r[h]==="0";h++)i++;r=r.slice(i-i%2);let c=r.join("");for(let h=0;h<n;h++)c=`00${c}`;return common.hexToBytes(c)}function validateStacksAddress(e){try{return c32addressDecode(e),!0}catch{return!1}}function privateKeyToStxAddress(e,t=exports.StacksNetworkVersion.mainnetP2PKH,n){return publicKeyToStxAddress(common.bytesToHex(secp256k1.getPublicKey(common.ensureHexBytes(e),n)),t)}function publicKeyToStxAddress(e,t=exports.StacksNetworkVersion.mainnetP2PKH){return c32address(t,hash160(common.ensureHexBytes(e)))}function privateKeyToBase58Address(e){const t=secp256k1.getPublicKey(e,!0),n=cryptoSha.hashSha256(t),r=hashRipemd160(n);return base58checkEncode(r,networks.bitcoin.pubKeyHash)}function publicKeyToBase58Address(e){const t=typeof e=="string"?e:common.bytesToHex(e),n=cryptoSha.hashSha256(common.hexToBytes(t)),r=hashRipemd160(n);return base58checkEncode(r,networks.bitcoin.pubKeyHash)}function hash160(e){const t=cryptoSha.hashSha256(e);return hashRipemd160(t)}const hashP2PKH=e=>common.bytesToHex(hash160(e)),hashP2WPKH=e=>{const t=hash160(e),n=new common.BufferArray;n.appendByte(0),n.appendByte(t.length),n.push(t);const r=n.concatBuffer(),s=hash160(r);return common.bytesToHex(s)},hashP2WSH=(e,t)=>{if(e>15||t.length>15)throw Error("P2WSH multisig address can only contain up to 15 public keys");const n=new common.BufferArray;n.appendByte(80+e),t.forEach(h=>{n.appendByte(h.length),n.push(h)}),n.appendByte(80+t.length),n.appendByte(174);const r=n.concatBuffer(),s=cryptoSha.hashSha256(r),o=new common.BufferArray;o.appendByte(0),o.appendByte(s.length),o.push(s);const i=o.concatBuffer(),c=hash160(i);return common.bytesToHex(c)},hashP2SH=(e,t)=>{if(e>15||t.length>15)throw Error("P2SH multisig address can only contain up to 15 public keys");const n=new common.BufferArray;n.appendByte(80+e),t.forEach(o=>{n.appendByte(o.length),n.push(o)}),n.appendByte(80+t.length),n.appendByte(174);const r=n.concatBuffer(),s=hash160(r);return common.bytesToHex(s)};async function signECDSA(e){const{contents:t,privateKey:n}=e,r=t instanceof ArrayBuffer?common.arrayBufferToUint8(t):typeof t=="string"?common.utf8ToBytes(t):t,s=common.bytesToHex(secp256k1.getPublicKey(n,!0)),o=cryptoSha.hashSha256(r),i=await secp256k1.sign(o,n,{canonical:!1});return{signature:common.bytesToHex(i),publicKey:s}}function verifyECDSA(e,t=!1){const{contents:n,publicKey:r,signature:s}=e,o=n instanceof ArrayBuffer?common.arrayBufferToUint8(n):typeof n=="string"?common.utf8ToBytes(n):n,i=cryptoSha.hashSha256(o);return secp256k1.verify(s,i,r,{strict:t})}async function encryptECIES(e){const{publicKey:t,content:n,cipherTextEncoding:r="hex",wasString:s}=e,o=secp256k1.utils.randomPrivateKey(),i=secp256k1.getPublicKey(o,!0);let c=secp256k1.getSharedSecret(o,t,!0);c=c.slice(1);const h=sharedSecretToKeys(c),a=getRandomBytes(16),p=await cryptoAes.aes256CbcEncrypt(a,h.encryptionKey,n),d=common.concatByteArrays([a,i,p]),u=cryptoHmacSha.hmacSha256(h.hmacKey,d);let f;if(!r||r==="hex")f=common.bytesToHex(p);else if(r==="base64")f=common.bytesToBase64(p);else throw new Error(`Unexpected cipherTextEncoding "${r}"`);const l={iv:common.bytesToHex(a),ephemeralPK:common.bytesToHex(i),cipherText:f,mac:common.bytesToHex(u),wasString:s};return r&&r!=="hex"&&(l.cipherTextEncoding=r),l}function equalConstTime(e,t){if(e.length!==t.length)return!1;let n=0;for(let r=0;r<e.length;r++)n|=e[r]^t[r];return n===0}async function decryptECIES(e){const{privateKey:t,cipherObject:n}=e;if(!n.ephemeralPK)throw Error("No ephemeralPK found in cipher object");const r=n.ephemeralPK;let s=secp256k1.getSharedSecret(t,r,!0);s=s.slice(1);const o=sharedSecretToKeys(s),i=common.hexToBytes(n.iv);let c;if(!n.cipherTextEncoding||n.cipherTextEncoding==="hex")c=common.hexToBytes(n.cipherText);else if(n.cipherTextEncoding==="base64")c=common.base64ToBytes(n.cipherText);else throw new Error(`Unexpected cipherTextEncoding "${n.cipherText}"`);const h=common.concatByteArrays([i,common.hexToBytes(r),c]),a=cryptoHmacSha.hmacSha256(o.hmacKey,h),p=common.hexToBytes(n.mac);if(!equalConstTime(p,a))throw new Error("Decryption failed: failure in MAC check");const d=await cryptoAes.aes256CbcDecrypt(i,o.encryptionKey,c);return n.wasString?new TextDecoder().decode(d):d}function decryptContent(e,t){if(!t.privateKey)throw new Error("Private key is required for decryption.");try{const n=JSON.parse(e);return decryptECIES({privateKey:t.privateKey,cipherObject:n})}catch(n){throw n instanceof SyntaxError?new Error("Failed to parse encrypted content JSON. The content may not be encrypted. If using getFile, try passing { decrypt: false }."):n}}var __defProp$1=Object.defineProperty,__defProps=Object.defineProperties,__getOwnPropDescs=Object.getOwnPropertyDescriptors,__getOwnPropSymbols$1=Object.getOwnPropertySymbols,__hasOwnProp$1=Object.prototype.hasOwnProperty,__propIsEnum$1=Object.prototype.propertyIsEnumerable,__defNormalProp$1=(e,t,n)=>t in e?__defProp$1(e,t,{enumerable:!0,configurable:!0,writable:!0,value:n}):e[t]=n,__spreadValues$1=(e,t)=>{for(var n in t||(t={}))__hasOwnProp$1.call(t,n)&&__defNormalProp$1(e,n,t[n]);if(__getOwnPropSymbols$1)for(var n of __getOwnPropSymbols$1(t))__propIsEnum$1.call(t,n)&&__defNormalProp$1(e,n,t[n]);return e},__spreadProps=(e,t)=>__defProps(e,__getOwnPropDescs(t));async function encryptContent(e,t){let{publicKey:n,privateKey:r,wasString:s}=t;const{cipherTextEncoding:o,sign:i}=t;if(!r&&!n)throw new Error("Either public key or private key must be supplied for encryption.");if(!n&&r&&(n=common.bytesToHex(secp256k1.getPublicKey(r,!0))),typeof s!="boolean"&&(s=typeof e=="string"),!n)throw new Error("micro-stacks/crypto - no public key found to encrypt content");const c=typeof e=="string"?common.utf8ToBytes(e):e,h=await encryptECIES({publicKey:n,content:c,wasString:s,cipherTextEncoding:o});if(!i)return JSON.stringify(h);if(typeof i=="string"&&(r=i),!r)throw new Error("micro-stacks/crypto - need private key to sign contents");const a=await signECDSA({contents:JSON.stringify(h),privateKey:r});return JSON.stringify(__spreadProps(__spreadValues$1({},a),{cipherText:JSON.stringify(h)}))}function padString(e){const t=4,n=e.length,r=n%t;if(!r)return e;const s=t-r,o=n+s;return e.padEnd(o,"=")}function encode(e){return e instanceof Uint8Array?fromBase64(common.bytesToBase64(e)):fromBase64(common.bytesToBase64(new TextEncoder().encode(e)))}function decode(e){const t=common.base64ToBytes(toBase64(e));return new TextDecoder().decode(t)}function toBase64(e){let t;return e instanceof Uint8Array?t=new TextDecoder().decode(e):t=e,padString(t).replace(/\-/g,"+").replace(/_/g,"/")}function fromBase64(e){return e.replace(/=/g,"").replace(/\+/g,"-").replace(/\//g,"_")}var base64url={encode,decode};const MAX_OCTET=128,CLASS_UNIVERSAL=0,PRIMITIVE_BIT=32,TAG_SEQ=16,TAG_INT=2,ENCODED_TAG_SEQ=TAG_SEQ|PRIMITIVE_BIT|CLASS_UNIVERSAL<<6,ENCODED_TAG_INT=TAG_INT|CLASS_UNIVERSAL<<6;function getSignature(e){return typeof e=="string"?common.base64ToBytes(e):e}function derToJoseES256(e){const t=getSignature(e),n=32,r=n+1,s=t.length;let o=0;if(t[o++]!==ENCODED_TAG_SEQ)throw new Error('Could not find expected "seq"');let i=t[o++];if(i===(MAX_OCTET|1)&&(i=t[o++]),s-o<i)throw new Error('"seq" specified length of "'+i+'", only "'+(s-o)+'" remaining');if(t[o++]!==ENCODED_TAG_INT)throw new Error('Could not find expected "int" for "r"');const c=t[o++];if(s-o-2<c)throw new Error('"r" specified length of "'+c+'", only "'+(s-o-2)+'" available');if(r<c)throw new Error('"r" specified length of "'+c+'", max of "'+r+'" is acceptable');const h=o;if(o+=c,t[o++]!==ENCODED_TAG_INT)throw new Error('Could not find expected "int" for "s"');const a=t[o++];if(s-o!==a)throw new Error('"s" specified length of "'+a+'", expected "'+(s-o)+'"');if(r<a)throw new Error('"s" specified length of "'+a+'", max of "'+r+'" is acceptable');const p=o;if(o+=a,o!==s)throw new Error('Expected to consume entire buffer, but "'+(s-o)+'" bytes remain');const d=n-c,u=n-a,f=new Uint8Array(d+c+u+a);for(o=0;o<d;++o)f[o]=0;f.set(t.slice(h+Math.max(-d,0),h+c),o),o=n;for(let l=o;o<l+u;++o)f[o]=0;return f.set(t.slice(p+Math.max(-u,0),p+a),o),common.bytesToBase64(f).replace(/=/g,"")}function countPadding(e,t,n){let r=0;for(;t+r<n&&e[t+r]===0;)++r;return e[t+r]>=MAX_OCTET&&--r,r}function joseToDerES256(e){const t=getSignature(e),n=32,r=countPadding(t,0,n),s=countPadding(t,n,t.length),o=n-r,i=n-s,c=1+1+o+1+1+i,h=c<MAX_OCTET,a=new Uint8Array((h?2:3)+c);let p=0;return a[p++]=ENCODED_TAG_SEQ,h?a[p++]=c:(a[p++]=MAX_OCTET|1,a[p++]=c&255),a[p++]=ENCODED_TAG_INT,a[p++]=o,r<0?(a[p++]=0,p+=common.copy(t,a,p,0,n)):p+=common.copy(t,a,p,r,n),a[p++]=ENCODED_TAG_INT,a[p++]=i,s<0?(a[p++]=0,common.copy(t,a,p,n)):common.copy(t,a,p,n+s),common.bytesToBase64(a).replace(/=/g,"")}function createSigningInput(e,t){const n=[],r=base64url.encode(JSON.stringify(t));n.push(r);const s=base64url.encode(JSON.stringify(e));return n.push(s),n.join(".")}var __defProp=Object.defineProperty,__getOwnPropSymbols=Object.getOwnPropertySymbols,__hasOwnProp=Object.prototype.hasOwnProperty,__propIsEnum=Object.prototype.propertyIsEnumerable,__defNormalProp=(e,t,n)=>t in e?__defProp(e,t,{enumerable:!0,configurable:!0,writable:!0,value:n}):e[t]=n,__spreadValues=(e,t)=>{for(var n in t||(t={}))__hasOwnProp.call(t,n)&&__defNormalProp(e,n,t[n]);if(__getOwnPropSymbols)for(var n of __getOwnPropSymbols(t))__propIsEnum.call(t,n)&&__defNormalProp(e,n,t[n]);return e};class TokenSigner{constructor(t="ES256K",n){if(!n)throw new common.MissingParametersError("TokenSigner: rawPrivateKey is required to sign a token");this.tokenType="JWT",this.rawPrivateKey=n}header(t={}){const n={typ:this.tokenType,alg:"ES256K"};return __spreadValues(__spreadValues({},n),t)}async sign(t,n=!1,r={}){const s=this.header(r),o=createSigningInput(t,s),i=cryptoSha.hashSha256(common.utf8ToBytes(o));return this.createWithSignedHash(t,n,s,o,i)}async createWithSignedHash(t,n,r,s,o){const i=await secp256k1.sign(o,this.rawPrivateKey,{canonical:!1}),c=derToJoseES256(i);return n?{header:[base64url.encode(JSON.stringify(r))],payload:JSON.stringify(t),signature:[c]}:[s,c].join(".")}}class TokenVerifier{constructor(t,n){this.tokenType="JWT",this.rawPublicKey=n}verify(t,n=!1){return typeof t=="string"?this.verifyCompact(t,n):typeof t=="object"?this.verifyExpanded(t,n):!1}verifyCompact(t,n){const r=t.split("."),s=r[0]+"."+r[1],o=c=>{const h=r[2],a=joseToDerES256(h);return secp256k1.verify(common.bytesToHex(common.base64ToBytes(a)),common.bytesToHex(c),this.rawPublicKey,{strict:n})},i=cryptoSha.hashSha256(common.utf8ToBytes(s));return o(i)}verifyExpanded(t,n){const r=[t.header.join("."),base64url.encode(t.payload)].join(".");let s=!0;const o=c=>(t.signature.map(h=>{const a=joseToDerES256(h);secp256k1.verify(common.bytesToHex(common.base64ToBytes(a)),common.bytesToHex(c),this.rawPublicKey,{strict:n})||(s=!1)}),s),i=cryptoSha.hashSha256(common.utf8ToBytes(r));return o(i)}}function decodeToken(e){if(typeof e=="string"){const t=e.split("."),n=JSON.parse(base64url.decode(t[0])),r=JSON.parse(base64url.decode(t[1])),s=t[2];return{header:n,payload:r,signature:s}}else if(typeof e=="object"){if(typeof e.payload!="string")throw new Error("Expected token payload to be a base64 or json string");let t=e.payload;e.payload[0]!=="{"&&(t=base64url.decode(t));const n=[];return e.header.map(r=>{const s=JSON.parse(base64url.decode(r));n.push(s)}),{header:n,payload:JSON.parse(t),signature:e.signature}}}function createUnsecuredToken(e){return createSigningInput(e,{typ:"JWT",alg:"none"})+"."}Object.defineProperty(exports,"getPublicKey",{enumerable:!0,get:function(){return secp256k1.getPublicKey}}),exports.BITCOIN_TO_STACKS_NETWORK_VERSION=BITCOIN_TO_STACKS_NETWORK_VERSION,exports.Ripemd160PolyfillDigest=Ripemd160PolyfillDigest,exports.STACKS_TO_BITCOIN_NETWORK_VERSION=STACKS_TO_BITCOIN_NETWORK_VERSION,exports.TokenSigner=TokenSigner,exports.TokenVerifier=TokenVerifier,exports.b58ToC32=b58ToC32,exports.base58checkDecode=base58checkDecode,exports.base58checkEncode=base58checkEncode,exports.c32ToB58=c32ToB58,exports.c32address=c32address,exports.c32addressDecode=c32addressDecode,exports.c32checkDecode=c32checkDecode,exports.c32decode=c32decode,exports.c32normalize=c32normalize,exports.createHashRipemd160=createHashRipemd160,exports.createSigningInput=createSigningInput,exports.createUnsecuredToken=createUnsecuredToken,exports.decodeToken=decodeToken,exports.decryptContent=decryptContent,exports.decryptECIES=decryptECIES,exports.derivePrivateKey=derivePrivateKey,exports.derivePublicKey=derivePublicKey,exports.eciesGetJsonStringLength=eciesGetJsonStringLength,exports.encryptContent=encryptContent,exports.encryptECIES=encryptECIES,exports.equalConstTime=equalConstTime,exports.getAesCbcOutputLength=getAesCbcOutputLength,exports.getBase64OutputLength=getBase64OutputLength,exports.getCipherObjectWrapper=getCipherObjectWrapper,exports.getRandomBytes=getRandomBytes,exports.getSignedCipherObjectWrapper=getSignedCipherObjectWrapper,exports.hashP2PKH=hashP2PKH,exports.hashP2SH=hashP2SH,exports.hashP2WPKH=hashP2WPKH,exports.hashP2WSH=hashP2WSH,exports.hashRipemd160=hashRipemd160,exports.isCompressedPublicKey=isCompressedPublicKey,exports.privateKeyToBase58Address=privateKeyToBase58Address,exports.privateKeyToStxAddress=privateKeyToStxAddress,exports.publicKeyToBase58Address=publicKeyToBase58Address,exports.publicKeyToStxAddress=publicKeyToStxAddress,exports.ripemd160=ripemd160,exports.sharedSecretToKeys=sharedSecretToKeys,exports.signECDSA=signECDSA,exports.validateStacksAddress=validateStacksAddress,exports.verifyECDSA=verifyECDSA;
