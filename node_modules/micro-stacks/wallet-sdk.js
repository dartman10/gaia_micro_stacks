"use strict";Object.defineProperty(exports,"__esModule",{value:!0});var bip39=require("@scure/bip39"),bip32=require("@scure/bip32"),english=require("@scure/bip39/wordlists/english"),common=require("micro-stacks/common"),cryptoSha=require("micro-stacks/crypto-sha"),crypto=require("micro-stacks/crypto"),cryptoAes=require("micro-stacks/crypto-aes"),cryptoHmacSha=require("micro-stacks/crypto-hmac-sha"),cryptoPbkdf2=require("micro-stacks/crypto-pbkdf2"),storage=require("micro-stacks/storage");const DATA_DERIVATION_PATH="m/888'/0'",WALLET_CONFIG_PATH="m/44/5757'/0'/1",STX_DERIVATION_PATH="m/44'/5757'/0'/0",WALLET_CONFIG_GAIA_PATH="wallet-config.json",DEFAULT_GAIA_HUB_URL="https://hub.blockstack.org";function isCompressed(e){return e.length===32||e.length===33&&(e[0]===2||e[0]===3)}function isHardened(e){return e+bip32.HARDENED_OFFSET}const deriveConfigPrivateKey=e=>{const t=e.derive(WALLET_CONFIG_PATH).privateKey;if(!t)throw new TypeError("Unable to derive config key for wallet identities");return common.bytesToHex(t)},deriveLegacyConfigPrivateKey=e=>{const o=bip32.HDKey.fromExtendedKey(e).deriveChild(isHardened(45)).privateKey;if(!o)throw new TypeError("Unable to derive config key for wallet identities");return common.bytesToHex(o)};function deriveSalt(e){const t=e.derive(DATA_DERIVATION_PATH).publicKey;if(!t)throw new TypeError("Unable to derive public key from data derivation path");return common.bytesToHex(cryptoSha.hashSha256(common.utf8ToBytes(common.bytesToHex(t))))}function deriveWalletKeys(e){if(!e.privateKey)throw Error("no private key");const t=deriveSalt(e),r=e.privateExtendedKey,o=deriveConfigPrivateKey(e);return{salt:t,rootKey:r,configPrivateKey:o}}async function encryptMnemonic(e,t,r=crypto.getRandomBytes(16)){if(!bip39.validateMnemonic(e,english.wordlist))throw new Error("Not a valid bip39 mnemonic");const o=await cryptoPbkdf2.createPbkdf2(),a=bip39.mnemonicToEntropy(e,english.wordlist),n=await o.derive(t,r,1e5,48,"sha512"),s=n.slice(0,16),i=n.slice(16,32),c=n.slice(32,48),p=await cryptoAes.aes128CbcEncrypt(c,s,a),l=common.concatByteArrays([r,p]),y=cryptoHmacSha.hmacSha256(i,l);return common.concatByteArrays([r,y,p])}function deriveAccount(e,t,r){const o=e.derive(STX_DERIVATION_PATH).deriveChild(t);if(!o.privateKey)throw Error("no private key");const n=e.derive(DATA_DERIVATION_PATH).deriveChild(isHardened(t));if(!n.privateKey)throw new Error("Must have private key to derive identities");const s=common.bytesToHex(n.privateKey),i=n.deriveChild(isHardened(0)).privateExtendedKey;return{stxPrivateKey:`${common.bytesToHex(o.privateKey)}${isCompressed(o.privateKey)?"01":""}`,dataPrivateKey:s,appsKey:i,salt:r,index:t}}function deriveNextAccountFromWallet(e){return deriveAccount(bip32.HDKey.fromExtendedKey(e.rootKey),e.accounts.length,e.salt)}function deriveManyAccountsForWallet(e,t,r){const o=[],a=[...Array(t).keys()];for(const n of a){const i=(r||(e.accounts.length>0?e.accounts.length-1:0))+n;e.accounts[i]||o.push(deriveAccount(bip32.HDKey.fromExtendedKey(e.rootKey),i,e.salt))}return o}var __defProp$3=Object.defineProperty,__defProps$2=Object.defineProperties,__getOwnPropDescs$2=Object.getOwnPropertyDescriptors,__getOwnPropSymbols$3=Object.getOwnPropertySymbols,__hasOwnProp$3=Object.prototype.hasOwnProperty,__propIsEnum$3=Object.prototype.propertyIsEnumerable,__defNormalProp$3=(e,t,r)=>t in e?__defProp$3(e,t,{enumerable:!0,configurable:!0,writable:!0,value:r}):e[t]=r,__spreadValues$3=(e,t)=>{for(var r in t||(t={}))__hasOwnProp$3.call(t,r)&&__defNormalProp$3(e,r,t[r]);if(__getOwnPropSymbols$3)for(var r of __getOwnPropSymbols$3(t))__propIsEnum$3.call(t,r)&&__defNormalProp$3(e,r,t[r]);return e},__spreadProps$2=(e,t)=>__defProps$2(e,__getOwnPropDescs$2(t));function generateSecretKey(e=256){if(e!==256&&e!==128)throw TypeError(`Incorrect entropy bits provided, expected 256 or 128 (24 or 12 word results), got: "${String(e)}".`);return bip39.generateMnemonic(english.wordlist,e)}async function generateWallet(e,t){const[r,o]=await Promise.all([bip39.mnemonicToSeed(e),encryptMnemonic(e,t)]),a=common.bytesToHex(o),n=deriveWalletKeys(bip32.HDKey.fromMasterSeed(r));return generateAndInsertNewAccount(__spreadProps$2(__spreadValues$3({},n),{encryptedSecretKey:a,accounts:[]}))}function generateAndInsertNewAccount(e){return __spreadProps$2(__spreadValues$3({},e),{accounts:[...e.accounts,deriveNextAccountFromWallet(e)]})}function getStxAddressFromAccount(e,t=crypto.StacksNetworkVersion.mainnetP2PKH){const r=e.stxPrivateKey.endsWith("01");return crypto.privateKeyToStxAddress(e.stxPrivateKey.slice(0,64),t,r)}const BITCOIN_VERSIONS={private:76066276,public:76067358};function hashCode(e){let t=0;if(e.length===0)return t;for(let r=0;r<e.length;r++){const o=e.charCodeAt(r);t=(t<<5)-t+o,t&=t}return t&2147483647}function getAppPrivateKey(e,t,r=!0){if(r)return getLegacyAppPrivateKey(e,t);const o=cryptoSha.hashSha256(common.utf8ToBytes(`${t}${e.salt}`)),a=bip32.HDKey.fromExtendedKey(e.appsKey);if(!a.privateKey)throw Error("no rootNode.privateKey");const n=new bip32.HDKey({privateKey:a.privateKey,chainCode:o,versions:BITCOIN_VERSIONS}).deriveChild(isHardened(0));if(!n.privateKey)throw new Error("[micro-stacks/wallet-sdk] getAppPrivateKey: No private key found");return common.bytesToHex(n.privateKey)}function getLegacyAppPrivateKey(e,t){const r=common.bytesToHex(cryptoSha.hashSha256(common.utf8ToBytes(`${t}${e.salt}`))),o=hashCode(r),a=bip32.HDKey.fromExtendedKey(e.appsKey).deriveChild(isHardened(o));if(!a.privateKey)throw new Error("[micro-stacks/wallet-sdk] getLegacyAppPrivateKey: No private key found");return common.bytesToHex(a.privateKey)}function getGaiaAddress(e){const t=e.stxPrivateKey.endsWith("01");return crypto.publicKeyToBase58Address(crypto.getPublicKey(e.dataPrivateKey,t))}async function decryptMnemonic(e,t){const r=typeof e=="string"?common.hexToBytes(e):e,o=r.slice(0,16),a=r.slice(16,48),n=r.slice(48),s=common.concatByteArrays([o,n]),c=await(await cryptoPbkdf2.createPbkdf2()).derive(t,o,1e5,48,"sha512"),p=c.slice(0,16),l=c.slice(16,32),y=c.slice(32,48),v=await cryptoAes.aes128CbcDecrypt(y,p,n),h=cryptoHmacSha.hmacSha256(l,s),d=cryptoSha.hashSha256(a),f=cryptoSha.hashSha256(h);if(common.bytesToHex(d)!==common.bytesToHex(f))throw new Error("Wrong password (HMAC mismatch)");let u;try{u=bip39.entropyToMnemonic(v,english.wordlist)}catch(m){throw console.error("Error thrown by `entropyToMnemonic`"),console.error(m),new Error("Wrong password (invalid plaintext)")}if(!bip39.validateMnemonic(u,english.wordlist))throw new Error("Wrong password (invalid plaintext)");return u}var __defProp$2=Object.defineProperty,__getOwnPropSymbols$2=Object.getOwnPropertySymbols,__hasOwnProp$2=Object.prototype.hasOwnProperty,__propIsEnum$2=Object.prototype.propertyIsEnumerable,__defNormalProp$2=(e,t,r)=>t in e?__defProp$2(e,t,{enumerable:!0,configurable:!0,writable:!0,value:r}):e[t]=r,__spreadValues$2=(e,t)=>{for(var r in t||(t={}))__hasOwnProp$2.call(t,r)&&__defNormalProp$2(e,r,t[r]);if(__getOwnPropSymbols$2)for(var r of __getOwnPropSymbols$2(t))__propIsEnum$2.call(t,r)&&__defNormalProp$2(e,r,t[r]);return e};function makeDIDFromAddress(e){return`did:btc-addr:${e}`}function nextMonth(){return new Date(new Date().setMonth(new Date().getMonth()+1))}function makeUUID4(){let e=new Date().getTime();return typeof performance!="undefined"&&typeof performance.now=="function"&&(e+=performance.now()),"xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx".replace(/[xy]/g,t=>{const r=(e+Math.random()*16)%16|0;return e=Math.floor(e/16),(t==="x"?r:r&3|8).toString(16)})}async function encryptPrivateKey(e,t){const r=await crypto.encryptECIES({content:common.hexToBytes(t),publicKey:e,cipherTextEncoding:"hex",wasString:!1}),o=JSON.stringify(r);return common.bytesToHex(common.utf8ToBytes(o))}async function makeAuthResponse(e){let{expiresAt:t}=e;const{privateKey:r,appPrivateKey:o,coreToken:a,transitPublicKey:n,metadata:s,hubUrl:i,blockstackAPIUrl:c,associationToken:p,username:l,profile:y}=e,v=common.bytesToHex(crypto.getPublicKey(r)),h=crypto.publicKeyToStxAddress(v);t||(t=nextMonth().getTime());let d=o,f=a,u={};o!=null&&(n!=null&&(d=await encryptPrivateKey(n,o),a!=null&&(f=await encryptPrivateKey(n,a))),u={email:(s==null?void 0:s.email)?s.email:null,profile_url:(s==null?void 0:s.profileUrl)?s.profileUrl:null,hubUrl:i,blockstackAPIUrl:c,associationToken:p,version:"undefined"});const m=__spreadValues$2({jti:makeUUID4(),iat:Math.floor(new Date().getTime()/1e3),exp:Math.floor(t/1e3),iss:makeDIDFromAddress(h),private_key:d!=null?d:null,public_keys:[v],profile:y!=null?y:null,username:l!=null?l:null,core_token:f!=null?f:null},u);return new crypto.TokenSigner("ES256k",r).sign(m)}function createWalletConfigGaiaHubConfig(e,t=DEFAULT_GAIA_HUB_URL){return storage.generateGaiaHubConfig({gaiaHubUrl:t,privateKey:e})}async function fetchWalletConfig(e,t){try{let r=t==null?void 0:t.gaiaHubConfig;r||(r=await createWalletConfigGaiaHubConfig(e,t==null?void 0:t.gaiaHubUrl));const o=await storage.getFile(WALLET_CONFIG_GAIA_PATH,{privateKey:e,gaiaHubConfig:r});if(typeof o!="string"){console.error("Wallet config response should be of type string");return}return JSON.parse(o)}catch{}}function makeWalletConfig(e){return{accounts:e.accounts.map(t=>({username:t.username,apps:{}}))}}async function saveWalletConfig({walletConfig:e,privateKey:t,gaiaHubConfig:r,gaiaHubUrl:o}){r||(r=await createWalletConfigGaiaHubConfig(t,o)),await storage.putFile(WALLET_CONFIG_GAIA_PATH,JSON.stringify(e),{gaiaHubConfig:r,privateKey:t,encrypt:!0,sign:!0})}async function getOrSetWalletConfig({wallet:e,gaiaHubConfig:t,gaiaHubUrl:r}){let o=await fetchWalletConfig(e.configPrivateKey,{gaiaHubConfig:t,gaiaHubUrl:r});return o||(o=makeWalletConfig(e),await saveWalletConfig({walletConfig:o,gaiaHubConfig:t,gaiaHubUrl:r,privateKey:e.configPrivateKey})),o}var __defProp$1=Object.defineProperty,__defProps$1=Object.defineProperties,__getOwnPropDescs$1=Object.getOwnPropertyDescriptors,__getOwnPropSymbols$1=Object.getOwnPropertySymbols,__hasOwnProp$1=Object.prototype.hasOwnProperty,__propIsEnum$1=Object.prototype.propertyIsEnumerable,__defNormalProp$1=(e,t,r)=>t in e?__defProp$1(e,t,{enumerable:!0,configurable:!0,writable:!0,value:r}):e[t]=r,__spreadValues$1=(e,t)=>{for(var r in t||(t={}))__hasOwnProp$1.call(t,r)&&__defNormalProp$1(e,r,t[r]);if(__getOwnPropSymbols$1)for(var r of __getOwnPropSymbols$1(t))__propIsEnum$1.call(t,r)&&__defNormalProp$1(e,r,t[r]);return e},__spreadProps$1=(e,t)=>__defProps$1(e,__getOwnPropDescs$1(t));function restoreWalletAccountsFromWalletConfig({wallet:e,walletConfig:t}){if(!t||t.accounts.length===0)return e;const r=t.accounts.length,o=deriveManyAccountsForWallet(e,r);return __spreadProps$1(__spreadValues$1({},e),{accounts:o})}var __defProp=Object.defineProperty,__defProps=Object.defineProperties,__getOwnPropDescs=Object.getOwnPropertyDescriptors,__getOwnPropSymbols=Object.getOwnPropertySymbols,__hasOwnProp=Object.prototype.hasOwnProperty,__propIsEnum=Object.prototype.propertyIsEnumerable,__defNormalProp=(e,t,r)=>t in e?__defProp(e,t,{enumerable:!0,configurable:!0,writable:!0,value:r}):e[t]=r,__spreadValues=(e,t)=>{for(var r in t||(t={}))__hasOwnProp.call(t,r)&&__defNormalProp(e,r,t[r]);if(__getOwnPropSymbols)for(var r of __getOwnPropSymbols(t))__propIsEnum.call(t,r)&&__defNormalProp(e,r,t[r]);return e},__spreadProps=(e,t)=>__defProps(e,__getOwnPropDescs(t));function updateAppsMeta({wallet:e,walletConfig:t,app:r,account:o}){for(const a of e.accounts){let n=0;const s=t.accounts[n];if(s?(s.apps=s.apps||{},s.username=a==null?void 0:a.username,t.accounts[n]=s):t.accounts.push({username:a==null?void 0:a.username,apps:{}}),n===o.index){const i=t.accounts[n];i.apps=i.apps||{},i.apps[r.origin]=r,t.accounts[n]=i}n+=1}return t}const updateWalletConfigWithApp=async({wallet:e,account:t,app:r,walletConfig:o,gaiaHubConfig:a})=>{const n=updateAppsMeta({wallet:e,walletConfig:o,app:r,account:t});return await saveWalletConfig({walletConfig:n,gaiaHubConfig:a,privateKey:e.configPrivateKey}),o},addNewAccountToWalletConfig=async({wallet:e,walletConfig:t,gaiaHubConfig:r})=>{const o=__spreadProps(__spreadValues({},t),{accounts:[...t.accounts,{apps:{}}]});return await saveWalletConfig({walletConfig:o,gaiaHubConfig:r,privateKey:e.configPrivateKey}),t};exports.addNewAccountToWalletConfig=addNewAccountToWalletConfig,exports.createWalletConfigGaiaHubConfig=createWalletConfigGaiaHubConfig,exports.decryptMnemonic=decryptMnemonic,exports.deriveAccount=deriveAccount,exports.deriveConfigPrivateKey=deriveConfigPrivateKey,exports.deriveLegacyConfigPrivateKey=deriveLegacyConfigPrivateKey,exports.deriveManyAccountsForWallet=deriveManyAccountsForWallet,exports.deriveNextAccountFromWallet=deriveNextAccountFromWallet,exports.deriveSalt=deriveSalt,exports.deriveWalletKeys=deriveWalletKeys,exports.encryptMnemonic=encryptMnemonic,exports.encryptPrivateKey=encryptPrivateKey,exports.fetchWalletConfig=fetchWalletConfig,exports.generateAndInsertNewAccount=generateAndInsertNewAccount,exports.generateSecretKey=generateSecretKey,exports.generateWallet=generateWallet,exports.getAppPrivateKey=getAppPrivateKey,exports.getGaiaAddress=getGaiaAddress,exports.getOrSetWalletConfig=getOrSetWalletConfig,exports.getStxAddressFromAccount=getStxAddressFromAccount,exports.makeAuthResponse=makeAuthResponse,exports.makeDIDFromAddress=makeDIDFromAddress,exports.makeUUID4=makeUUID4,exports.makeWalletConfig=makeWalletConfig,exports.nextMonth=nextMonth,exports.restoreWalletAccountsFromWalletConfig=restoreWalletAccountsFromWalletConfig,exports.saveWalletConfig=saveWalletConfig,exports.updateWalletConfigWithApp=updateWalletConfigWithApp;
