import { TransactionVersion, ChainID } from 'micro-stacks/common';
export { ChainID, TransactionVersion } from 'micro-stacks/common';

declare type Fetcher = (input: RequestInfo, init?: RequestInit) => Promise<Response>;
declare const HIRO_MAINNET_DEFAULT = "https://stacks-node-api.mainnet.stacks.co";
declare const HIRO_TESTNET_DEFAULT = "https://stacks-node-api.testnet.stacks.co";
declare const HIRO_MOCKNET_DEFAULT = "http://localhost:3999";
interface NetworkConfig {
    url?: string;
    coreApiUrl?: string;
    bnsLookupUrl?: string;
    fetcher?: Fetcher;
}
interface StacksNetwork {
    version: TransactionVersion;
    chainId: ChainID;
    bnsLookupUrl: string;
    broadcastEndpoint: string;
    transferFeeEstimateEndpoint: string;
    accountEndpoint: string;
    contractAbiEndpoint: string;
    readOnlyFunctionCallEndpoint: string;
    isMainnet(): boolean;
    getBroadcastApiUrl: () => string;
    getTransferFeeEstimateApiUrl: () => string;
    getAccountApiUrl: (address: string) => string;
    getAbiApiUrl: (address: string, contract: string) => string;
    getReadOnlyFunctionCallApiUrl: (contractAddress: string, contractName: string, functionName: string) => string;
    getCoreApiUrl: () => string;
    getInfoUrl: () => string;
    getBlockTimeInfoUrl: () => string;
    getPoxInfoUrl: () => string;
    getRewardsUrl: (address: string, options?: any) => string;
    getRewardHoldersUrl: (address: string, options?: any) => string;
    getRewardsTotalUrl: (address: string) => string;
    getStackerInfoUrl: (contractAddress: string, contractName: string) => string;
    /**
     * Get WHOIS-like information for a name, including the address that owns it,
     * the block at which it expires, and the zone file anchored to it (if available).
     *
     * This is intended for use in third-party wallets or in DApps that register names.
     * @param fullyQualifiedName the name to query.  Can be on-chain of off-chain.
     * @return a promise that resolves to the WHOIS-like information
     */
    getNameInfo: (fullyQualifiedName: string) => any;
}
declare class StacksMainnet implements StacksNetwork {
    version: TransactionVersion;
    chainId: ChainID;
    broadcastEndpoint: string;
    transferFeeEstimateEndpoint: string;
    accountEndpoint: string;
    contractAbiEndpoint: string;
    readOnlyFunctionCallEndpoint: string;
    bnsLookupUrl: string;
    private _coreApiUrl;
    private fetcher;
    get coreApiUrl(): string;
    set coreApiUrl(_url: string);
    constructor(networkConfig?: NetworkConfig);
    getCoreApiUrl: () => string;
    isMainnet: () => boolean;
    getBroadcastApiUrl: () => string;
    getTransferFeeEstimateApiUrl: () => string;
    getAccountApiUrl: (address: string) => string;
    getAbiApiUrl: (address: string, contract: string) => string;
    getReadOnlyFunctionCallApiUrl: (contractAddress: string, contractName: string, functionName: string) => string;
    getInfoUrl: () => string;
    getBlockTimeInfoUrl: () => string;
    getPoxInfoUrl: () => string;
    getRewardsUrl: (address: string, options?: any) => string;
    getRewardsTotalUrl: (address: string) => string;
    getRewardHoldersUrl: (address: string, options?: any) => string;
    getStackerInfoUrl: (contractAddress: string, contractName: string) => string;
    getNameInfo(fullyQualifiedName: string): Promise<any>;
}
declare class StacksTestnet extends StacksMainnet implements StacksNetwork {
    version: TransactionVersion;
    chainId: ChainID;
    constructor(networkConfig?: NetworkConfig);
}
declare class StacksMocknet extends StacksMainnet implements StacksNetwork {
    version: TransactionVersion;
    chainId: ChainID;
    constructor(networkConfig?: NetworkConfig);
}

export { HIRO_MAINNET_DEFAULT, HIRO_MOCKNET_DEFAULT, HIRO_TESTNET_DEFAULT, NetworkConfig, StacksMainnet, StacksMocknet, StacksNetwork, StacksTestnet };
